
# python wrapper for package k8s.io/client-go/dynamic within overall package dynamic
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg k8s.io/client-go/dynamic

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _dynamic
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from dynamic import dynamic
# and then refer to everything using dynamic. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []*x509.Certificate
class Slice_Ptr_x509_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_Ptr_x509_Certificate_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_x509_Certificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_Ptr_x509_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_Ptr_x509_Certificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_Ptr_x509_Certificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_Ptr_x509_Certificate_len(self.handle)
				return Slice_Ptr_x509_Certificate(handle=_dynamic.Slice_Ptr_x509_Certificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_x509_Certificate(handle=_dynamic.Slice_Ptr_x509_Certificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_Ptr_x509_Certificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_x509_Certificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_x509_Certificate(handle=_dynamic.Slice_Ptr_x509_Certificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_Ptr_x509_Certificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*multipart.FileHeader
class Slice_Ptr_multipart_FileHeader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_Ptr_multipart_FileHeader_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_multipart_FileHeader.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_Ptr_multipart_FileHeader len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_Ptr_multipart_FileHeader([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_Ptr_multipart_FileHeader_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_Ptr_multipart_FileHeader_len(self.handle)
				return Slice_Ptr_multipart_FileHeader(handle=_dynamic.Slice_Ptr_multipart_FileHeader_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_multipart_FileHeader(handle=_dynamic.Slice_Ptr_multipart_FileHeader_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_Ptr_multipart_FileHeader_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_multipart_FileHeader.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_multipart_FileHeader(handle=_dynamic.Slice_Ptr_multipart_FileHeader_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_Ptr_multipart_FileHeader_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*net.IPNet
class Slice_Ptr_net_IPNet(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_Ptr_net_IPNet_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_net_IPNet.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_Ptr_net_IPNet len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_Ptr_net_IPNet([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_Ptr_net_IPNet_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_Ptr_net_IPNet_len(self.handle)
				return Slice_Ptr_net_IPNet(handle=_dynamic.Slice_Ptr_net_IPNet_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_net_IPNet(handle=_dynamic.Slice_Ptr_net_IPNet_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_Ptr_net_IPNet_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_net_IPNet.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_net_IPNet(handle=_dynamic.Slice_Ptr_net_IPNet_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_Ptr_net_IPNet_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*http.Cookie
class Slice_Ptr_http_Cookie(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_Ptr_http_Cookie_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_http_Cookie.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_Ptr_http_Cookie len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_Ptr_http_Cookie([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_Ptr_http_Cookie_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_Ptr_http_Cookie_len(self.handle)
				return Slice_Ptr_http_Cookie(handle=_dynamic.Slice_Ptr_http_Cookie_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_http_Cookie(handle=_dynamic.Slice_Ptr_http_Cookie_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_Ptr_http_Cookie_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_http_Cookie.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_http_Cookie(handle=_dynamic.Slice_Ptr_http_Cookie_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_Ptr_http_Cookie_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*url.URL
class Slice_Ptr_url_URL(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_Ptr_url_URL_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_url_URL.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_Ptr_url_URL len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_Ptr_url_URL([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_Ptr_url_URL_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_Ptr_url_URL_len(self.handle)
				return Slice_Ptr_url_URL(handle=_dynamic.Slice_Ptr_url_URL_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_url_URL(handle=_dynamic.Slice_Ptr_url_URL_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_Ptr_url_URL_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_url_URL.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_url_URL(handle=_dynamic.Slice_Ptr_url_URL_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_Ptr_url_URL_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]*x509.Certificate
class Slice_Slice_Ptr_x509_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_Slice_Ptr_x509_Certificate_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_Ptr_x509_Certificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_Slice_Ptr_x509_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_Slice_Ptr_x509_Certificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_Slice_Ptr_x509_Certificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_Slice_Ptr_x509_Certificate_len(self.handle)
				return Slice_Slice_Ptr_x509_Certificate(handle=_dynamic.Slice_Slice_Ptr_x509_Certificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Slice_Ptr_x509_Certificate(handle=_dynamic.Slice_Slice_Ptr_x509_Certificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_Slice_Ptr_x509_Certificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_Ptr_x509_Certificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Slice_Ptr_x509_Certificate(handle=_dynamic.Slice_Slice_Ptr_x509_Certificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_Slice_Ptr_x509_Certificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]byte
class Slice_Slice_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_Slice_byte_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_byte.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_Slice_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_Slice_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_Slice_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_Slice_byte_len(self.handle)
				return Slice_Slice_byte(handle=_dynamic.Slice_Slice_byte_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_byte(handle=_dynamic.Slice_Slice_byte_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_Slice_byte_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_byte.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_byte(handle=_dynamic.Slice_Slice_byte_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_Slice_byte_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []x509.ExtKeyUsage
class Slice_x509_ExtKeyUsage(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_x509_ExtKeyUsage_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_x509_ExtKeyUsage.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_x509_ExtKeyUsage len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_x509_ExtKeyUsage([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_x509_ExtKeyUsage_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_x509_ExtKeyUsage_len(self.handle)
				return Slice_x509_ExtKeyUsage(handle=_dynamic.Slice_x509_ExtKeyUsage_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _dynamic.Slice_x509_ExtKeyUsage_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_x509_ExtKeyUsage_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_x509_ExtKeyUsage.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _dynamic.Slice_x509_ExtKeyUsage_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_x509_ExtKeyUsage_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []x509.OID
class Slice_x509_OID(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_x509_OID_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_x509_OID.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_x509_OID len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_x509_OID([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_x509_OID_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_x509_OID_len(self.handle)
				return Slice_x509_OID(handle=_dynamic.Slice_x509_OID_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.x509_OID(handle=_dynamic.Slice_x509_OID_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_x509_OID_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_x509_OID.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.x509_OID(handle=_dynamic.Slice_x509_OID_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_x509_OID_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.AttributeTypeAndValue
class Slice_pkix_AttributeTypeAndValue(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_pkix_AttributeTypeAndValue_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_AttributeTypeAndValue.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_pkix_AttributeTypeAndValue len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_pkix_AttributeTypeAndValue([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_pkix_AttributeTypeAndValue_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_pkix_AttributeTypeAndValue_len(self.handle)
				return Slice_pkix_AttributeTypeAndValue(handle=_dynamic.Slice_pkix_AttributeTypeAndValue_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_AttributeTypeAndValue(handle=_dynamic.Slice_pkix_AttributeTypeAndValue_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_pkix_AttributeTypeAndValue_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_AttributeTypeAndValue.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_AttributeTypeAndValue(handle=_dynamic.Slice_pkix_AttributeTypeAndValue_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_pkix_AttributeTypeAndValue_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.Extension
class Slice_pkix_Extension(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_pkix_Extension_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_Extension.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_pkix_Extension len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_pkix_Extension([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_pkix_Extension_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_pkix_Extension_len(self.handle)
				return Slice_pkix_Extension(handle=_dynamic.Slice_pkix_Extension_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_Extension(handle=_dynamic.Slice_pkix_Extension_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_pkix_Extension_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_Extension.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_Extension(handle=_dynamic.Slice_pkix_Extension_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_pkix_Extension_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.RevokedCertificate
class Slice_pkix_RevokedCertificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_pkix_RevokedCertificate_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_RevokedCertificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_pkix_RevokedCertificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_pkix_RevokedCertificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_pkix_RevokedCertificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_pkix_RevokedCertificate_len(self.handle)
				return Slice_pkix_RevokedCertificate(handle=_dynamic.Slice_pkix_RevokedCertificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_RevokedCertificate(handle=_dynamic.Slice_pkix_RevokedCertificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_pkix_RevokedCertificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_RevokedCertificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_RevokedCertificate(handle=_dynamic.Slice_pkix_RevokedCertificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_pkix_RevokedCertificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []asn1.ObjectIdentifier
class Slice_asn1_ObjectIdentifier(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_asn1_ObjectIdentifier_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_asn1_ObjectIdentifier.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_asn1_ObjectIdentifier len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_asn1_ObjectIdentifier([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_asn1_ObjectIdentifier_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_asn1_ObjectIdentifier_len(self.handle)
				return Slice_asn1_ObjectIdentifier(handle=_dynamic.Slice_asn1_ObjectIdentifier_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.asn1_ObjectIdentifier(handle=_dynamic.Slice_asn1_ObjectIdentifier_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_asn1_ObjectIdentifier_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_asn1_ObjectIdentifier.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.asn1_ObjectIdentifier(handle=_dynamic.Slice_asn1_ObjectIdentifier_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_asn1_ObjectIdentifier_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []v1.ManagedFieldsEntry
class Slice_v1_ManagedFieldsEntry(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_v1_ManagedFieldsEntry_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_v1_ManagedFieldsEntry.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_v1_ManagedFieldsEntry len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_v1_ManagedFieldsEntry([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_v1_ManagedFieldsEntry_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_v1_ManagedFieldsEntry_len(self.handle)
				return Slice_v1_ManagedFieldsEntry(handle=_dynamic.Slice_v1_ManagedFieldsEntry_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.v1_ManagedFieldsEntry(handle=_dynamic.Slice_v1_ManagedFieldsEntry_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_v1_ManagedFieldsEntry_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_v1_ManagedFieldsEntry.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.v1_ManagedFieldsEntry(handle=_dynamic.Slice_v1_ManagedFieldsEntry_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_v1_ManagedFieldsEntry_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []v1.OwnerReference
class Slice_v1_OwnerReference(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_v1_OwnerReference_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_v1_OwnerReference.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_v1_OwnerReference len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_v1_OwnerReference([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_v1_OwnerReference_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_v1_OwnerReference_len(self.handle)
				return Slice_v1_OwnerReference(handle=_dynamic.Slice_v1_OwnerReference_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.v1_OwnerReference(handle=_dynamic.Slice_v1_OwnerReference_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_v1_OwnerReference_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_v1_OwnerReference.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.v1_OwnerReference(handle=_dynamic.Slice_v1_OwnerReference_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_v1_OwnerReference_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []unstructured.Unstructured
class Slice_unstructured_Unstructured(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_unstructured_Unstructured_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_unstructured_Unstructured.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_unstructured_Unstructured len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_unstructured_Unstructured([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_unstructured_Unstructured_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_unstructured_Unstructured_len(self.handle)
				return Slice_unstructured_Unstructured(handle=_dynamic.Slice_unstructured_Unstructured_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.unstructured_Unstructured(handle=_dynamic.Slice_unstructured_Unstructured_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_unstructured_Unstructured_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_unstructured_Unstructured.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.unstructured_Unstructured(handle=_dynamic.Slice_unstructured_Unstructured_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_unstructured_Unstructured_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []api.ExecEnvVar
class Slice_api_ExecEnvVar(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_api_ExecEnvVar_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_api_ExecEnvVar.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_api_ExecEnvVar len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_api_ExecEnvVar([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_api_ExecEnvVar_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_api_ExecEnvVar_len(self.handle)
				return Slice_api_ExecEnvVar(handle=_dynamic.Slice_api_ExecEnvVar_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.api_ExecEnvVar(handle=_dynamic.Slice_api_ExecEnvVar_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_api_ExecEnvVar_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_api_ExecEnvVar.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.api_ExecEnvVar(handle=_dynamic.Slice_api_ExecEnvVar_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_api_ExecEnvVar_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []big.Word
class Slice_big_Word(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_big_Word_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_big_Word.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_big_Word len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_big_Word([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_big_Word_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_big_Word_len(self.handle)
				return Slice_big_Word(handle=_dynamic.Slice_big_Word_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _dynamic.Slice_big_Word_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_big_Word_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_big_Word.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _dynamic.Slice_big_Word_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_big_Word_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []net.IP
class Slice_net_IP(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_net_IP_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_net_IP.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Slice_net_IP len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'dynamic.Slice_net_IP([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_net_IP_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_net_IP_len(self.handle)
				return Slice_net_IP(handle=_dynamic.Slice_net_IP_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.net_IP(handle=_dynamic.Slice_net_IP_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_net_IP_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_net_IP.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.net_IP(handle=_dynamic.Slice_net_IP_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_net_IP_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string][]*multipart.FileHeader
class Map_string_Slice_Ptr_multipart_FileHeader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Map_string_Slice_Ptr_multipart_FileHeader_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_Ptr_multipart_FileHeader.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_dynamic.Map_string_Slice_Ptr_multipart_FileHeader_set(self.handle, k, v)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Map_string_Slice_Ptr_multipart_FileHeader len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'dynamic.Map_string_Slice_Ptr_multipart_FileHeader({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _dynamic.Map_string_Slice_Ptr_multipart_FileHeader_len(self.handle)
	def __getitem__(self, key):
		return Slice_Ptr_multipart_FileHeader(handle=_dynamic.Map_string_Slice_Ptr_multipart_FileHeader_elem(self.handle, key))
	def __setitem__(self, key, value):
		_dynamic.Map_string_Slice_Ptr_multipart_FileHeader_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _dynamic.Map_string_Slice_Ptr_multipart_FileHeader_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_dynamic.Map_string_Slice_Ptr_multipart_FileHeader_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _dynamic.Map_string_Slice_Ptr_multipart_FileHeader_contains(self.handle, key)

# Python type for map map[string][]string
class Map_string_Slice_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Map_string_Slice_string_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_dynamic.Map_string_Slice_string_set(self.handle, k, v)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Map_string_Slice_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'dynamic.Map_string_Slice_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _dynamic.Map_string_Slice_string_len(self.handle)
	def __getitem__(self, key):
		return go.Slice_string(handle=_dynamic.Map_string_Slice_string_elem(self.handle, key))
	def __setitem__(self, key, value):
		_dynamic.Map_string_Slice_string_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _dynamic.Map_string_Slice_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_dynamic.Map_string_Slice_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _dynamic.Map_string_Slice_string_contains(self.handle, key)

# Python type for map map[string]bool
class Map_string_bool(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Map_string_bool_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_bool.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_dynamic.Map_string_bool_set(self.handle, k, v)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Map_string_bool len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'dynamic.Map_string_bool({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _dynamic.Map_string_bool_len(self.handle)
	def __getitem__(self, key):
		return _dynamic.Map_string_bool_elem(self.handle, key)
	def __setitem__(self, key, value):
		_dynamic.Map_string_bool_set(self.handle, key, value)
	def __delitem__(self, key):
		return _dynamic.Map_string_bool_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_dynamic.Map_string_bool_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _dynamic.Map_string_bool_contains(self.handle, key)

# Python type for map map[string]interface{}
class Map_string_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Map_string_interface__CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_interface_.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_dynamic.Map_string_interface__set(self.handle, k, v)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Map_string_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'dynamic.Map_string_interface_({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _dynamic.Map_string_interface__len(self.handle)
	def __getitem__(self, key):
		return _dynamic.Map_string_interface__elem(self.handle, key)
	def __setitem__(self, key, value):
		_dynamic.Map_string_interface__set(self.handle, key, value)
	def __delitem__(self, key):
		return _dynamic.Map_string_interface__delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_dynamic.Map_string_interface__keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _dynamic.Map_string_interface__contains(self.handle, key)

# Python type for map map[string]string
class Map_string_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Map_string_string_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_dynamic.Map_string_string_set(self.handle, k, v)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Map_string_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'dynamic.Map_string_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _dynamic.Map_string_string_len(self.handle)
	def __getitem__(self, key):
		return _dynamic.Map_string_string_elem(self.handle, key)
	def __setitem__(self, key, value):
		_dynamic.Map_string_string_set(self.handle, key, value)
	def __delitem__(self, key):
		return _dynamic.Map_string_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_dynamic.Map_string_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _dynamic.Map_string_string_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---

# Python type for interface dynamic.Interface
class Interface(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = 0
	def Resource(self, resource):
		"""Resource(object resource) object"""
		return NamespaceableResourceInterface(handle=_dynamic.dynamic_Interface_Resource(self.handle, resource.handle))

# Python type for interface dynamic.NamespaceableResourceInterface
class NamespaceableResourceInterface(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = 0
	def Apply(self, ctx, name, obj, options, *args):
		"""Apply(object ctx, str name, object obj, object options, []str subresources) object, str"""
		subresources = go.Slice_string(args)
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_NamespaceableResourceInterface_Apply(self.handle, ctx.handle, name, obj.handle, options.handle, subresources.handle))
	def ApplyStatus(self, ctx, name, obj, options):
		"""ApplyStatus(object ctx, str name, object obj, object options) object, str"""
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_NamespaceableResourceInterface_ApplyStatus(self.handle, ctx.handle, name, obj.handle, options.handle))
	def Create(self, ctx, obj, options, *args):
		"""Create(object ctx, object obj, object options, []str subresources) object, str"""
		subresources = go.Slice_string(args)
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_NamespaceableResourceInterface_Create(self.handle, ctx.handle, obj.handle, options.handle, subresources.handle))
	def Delete(self, ctx, name, options, *args):
		"""Delete(object ctx, str name, object options, []str subresources) str"""
		subresources = go.Slice_string(args)
		return _dynamic.dynamic_NamespaceableResourceInterface_Delete(self.handle, ctx.handle, name, options.handle, subresources.handle)
	def DeleteCollection(self, ctx, options, listOptions):
		"""DeleteCollection(object ctx, object options, object listOptions) str"""
		return _dynamic.dynamic_NamespaceableResourceInterface_DeleteCollection(self.handle, ctx.handle, options.handle, listOptions.handle)
	def Get(self, ctx, name, options, *args):
		"""Get(object ctx, str name, object options, []str subresources) object, str"""
		subresources = go.Slice_string(args)
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_NamespaceableResourceInterface_Get(self.handle, ctx.handle, name, options.handle, subresources.handle))
	def List(self, ctx, opts):
		"""List(object ctx, object opts) object, str"""
		return go.Ptr_unstructured_UnstructuredList(handle=_dynamic.dynamic_NamespaceableResourceInterface_List(self.handle, ctx.handle, opts.handle))
	def Namespace(self, arg_0):
		"""Namespace(str) object"""
		return ResourceInterface(handle=_dynamic.dynamic_NamespaceableResourceInterface_Namespace(self.handle, arg_0))
	def Patch(self, ctx, name, pt, data, options, *args):
		"""Patch(object ctx, str name, str pt, []int data, object options, []str subresources) object, str"""
		subresources = go.Slice_string(args)
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_NamespaceableResourceInterface_Patch(self.handle, ctx.handle, name, pt, data.handle, options.handle, subresources.handle))
	def Update(self, ctx, obj, options, *args):
		"""Update(object ctx, object obj, object options, []str subresources) object, str"""
		subresources = go.Slice_string(args)
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_NamespaceableResourceInterface_Update(self.handle, ctx.handle, obj.handle, options.handle, subresources.handle))
	def UpdateStatus(self, ctx, obj, options):
		"""UpdateStatus(object ctx, object obj, object options) object, str"""
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_NamespaceableResourceInterface_UpdateStatus(self.handle, ctx.handle, obj.handle, options.handle))
	def Watch(self, ctx, opts):
		"""Watch(object ctx, object opts) object, str"""
		return go.watch_Interface(handle=_dynamic.dynamic_NamespaceableResourceInterface_Watch(self.handle, ctx.handle, opts.handle))

# Python type for interface dynamic.ResourceInterface
class ResourceInterface(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = 0
	def Apply(self, ctx, name, obj, options, *args):
		"""Apply(object ctx, str name, object obj, object options, []str subresources) object, str"""
		subresources = go.Slice_string(args)
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_ResourceInterface_Apply(self.handle, ctx.handle, name, obj.handle, options.handle, subresources.handle))
	def ApplyStatus(self, ctx, name, obj, options):
		"""ApplyStatus(object ctx, str name, object obj, object options) object, str"""
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_ResourceInterface_ApplyStatus(self.handle, ctx.handle, name, obj.handle, options.handle))
	def Create(self, ctx, obj, options, *args):
		"""Create(object ctx, object obj, object options, []str subresources) object, str"""
		subresources = go.Slice_string(args)
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_ResourceInterface_Create(self.handle, ctx.handle, obj.handle, options.handle, subresources.handle))
	def Delete(self, ctx, name, options, *args):
		"""Delete(object ctx, str name, object options, []str subresources) str"""
		subresources = go.Slice_string(args)
		return _dynamic.dynamic_ResourceInterface_Delete(self.handle, ctx.handle, name, options.handle, subresources.handle)
	def DeleteCollection(self, ctx, options, listOptions):
		"""DeleteCollection(object ctx, object options, object listOptions) str"""
		return _dynamic.dynamic_ResourceInterface_DeleteCollection(self.handle, ctx.handle, options.handle, listOptions.handle)
	def Get(self, ctx, name, options, *args):
		"""Get(object ctx, str name, object options, []str subresources) object, str"""
		subresources = go.Slice_string(args)
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_ResourceInterface_Get(self.handle, ctx.handle, name, options.handle, subresources.handle))
	def List(self, ctx, opts):
		"""List(object ctx, object opts) object, str"""
		return go.Ptr_unstructured_UnstructuredList(handle=_dynamic.dynamic_ResourceInterface_List(self.handle, ctx.handle, opts.handle))
	def Patch(self, ctx, name, pt, data, options, *args):
		"""Patch(object ctx, str name, str pt, []int data, object options, []str subresources) object, str"""
		subresources = go.Slice_string(args)
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_ResourceInterface_Patch(self.handle, ctx.handle, name, pt, data.handle, options.handle, subresources.handle))
	def Update(self, ctx, obj, options, *args):
		"""Update(object ctx, object obj, object options, []str subresources) object, str"""
		subresources = go.Slice_string(args)
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_ResourceInterface_Update(self.handle, ctx.handle, obj.handle, options.handle, subresources.handle))
	def UpdateStatus(self, ctx, obj, options):
		"""UpdateStatus(object ctx, object obj, object options) object, str"""
		return go.Ptr_unstructured_Unstructured(handle=_dynamic.dynamic_ResourceInterface_UpdateStatus(self.handle, ctx.handle, obj.handle, options.handle))
	def Watch(self, ctx, opts):
		"""Watch(object ctx, object opts) object, str"""
		return go.watch_Interface(handle=_dynamic.dynamic_ResourceInterface_Watch(self.handle, ctx.handle, opts.handle))


# ---- Structs ---

# Python type for struct dynamic.DynamicClient
class DynamicClient(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.dynamic_DynamicClient_CTor()
			_dynamic.IncRef(self.handle)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'dynamic.DynamicClient{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'dynamic.DynamicClient ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Resource(self, resource):
		"""Resource(object resource) object"""
		return NamespaceableResourceInterface(handle=_dynamic.dynamic_DynamicClient_Resource(self.handle, resource.handle))


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def New(c):
	"""New(object c) object
	
	New creates a new DynamicClient for the given RESTClient.
	"""
	return DynamicClient(handle=_dynamic.dynamic_New(c.handle))
def NewForConfig(inConfig):
	"""NewForConfig(object inConfig) object, str
	
	NewForConfig creates a new dynamic client or returns an error.
	NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
	where httpClient was generated with rest.HTTPClientFor(c).
	"""
	return DynamicClient(handle=_dynamic.dynamic_NewForConfig(inConfig.handle))
def NewForConfigAndClient(inConfig, h):
	"""NewForConfigAndClient(object inConfig, object h) object, str
	
	NewForConfigAndClient creates a new dynamic client for the given config and http client.
	Note the http client provided takes precedence over the configured transport values.
	"""
	return DynamicClient(handle=_dynamic.dynamic_NewForConfigAndClient(inConfig.handle, h.handle))
def NewForConfigOrDie(c):
	"""NewForConfigOrDie(object c) object
	
	NewForConfigOrDie creates a new DynamicClient for the given config and
	panics if there is an error in the config.
	"""
	return DynamicClient(handle=_dynamic.dynamic_NewForConfigOrDie(c.handle))


# ---- Functions ---
def ConfigFor(inConfig):
	"""ConfigFor(object inConfig) object
	
	ConfigFor returns a copy of the provided config with the
	appropriate dynamic client defaults set.
	"""
	return go.Ptr_rest_Config(handle=_dynamic.dynamic_ConfigFor(inConfig.handle))
def LegacyAPIPathResolverFunc(kind):
	"""LegacyAPIPathResolverFunc(object kind) str
	
	LegacyAPIPathResolverFunc can resolve paths properly with the legacy API.
	TODO find a better place to move this for existing callers
	"""
	return _dynamic.dynamic_LegacyAPIPathResolverFunc(kind.handle)


