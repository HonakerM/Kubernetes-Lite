
# python wrapper for package k8s.io/client-go/dynamic/fake within overall package dynamic
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg k8s.io/client-go/dynamic

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _dynamic
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from dynamic import fake
# and then refer to everything using fake. prefix
# packages imported by this package listed below:

from . import dynamic



# ---- Types ---

# Python type for slice []runtime.Object
class Slice_runtime_Object(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_runtime_Object_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_runtime_Object.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'fake.Slice_runtime_Object len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'fake.Slice_runtime_Object([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_runtime_Object_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_runtime_Object_len(self.handle)
				return Slice_runtime_Object(handle=_dynamic.Slice_runtime_Object_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.runtime_Object(handle=_dynamic.Slice_runtime_Object_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_runtime_Object_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_runtime_Object.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.runtime_Object(handle=_dynamic.Slice_runtime_Object_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_runtime_Object_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []schema.GroupVersion
class Slice_schema_GroupVersion(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_schema_GroupVersion_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_schema_GroupVersion.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'fake.Slice_schema_GroupVersion len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'fake.Slice_schema_GroupVersion([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_schema_GroupVersion_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_schema_GroupVersion_len(self.handle)
				return Slice_schema_GroupVersion(handle=_dynamic.Slice_schema_GroupVersion_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.schema_GroupVersion(handle=_dynamic.Slice_schema_GroupVersion_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_schema_GroupVersion_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_schema_GroupVersion.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.schema_GroupVersion(handle=_dynamic.Slice_schema_GroupVersion_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_schema_GroupVersion_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []schema.GroupVersionKind
class Slice_schema_GroupVersionKind(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_schema_GroupVersionKind_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_schema_GroupVersionKind.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'fake.Slice_schema_GroupVersionKind len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'fake.Slice_schema_GroupVersionKind([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_schema_GroupVersionKind_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_schema_GroupVersionKind_len(self.handle)
				return Slice_schema_GroupVersionKind(handle=_dynamic.Slice_schema_GroupVersionKind_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.schema_GroupVersionKind(handle=_dynamic.Slice_schema_GroupVersionKind_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_schema_GroupVersionKind_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_schema_GroupVersionKind.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.schema_GroupVersionKind(handle=_dynamic.Slice_schema_GroupVersionKind_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_schema_GroupVersionKind_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []schema.GroupVersionResource
class Slice_schema_GroupVersionResource(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Slice_schema_GroupVersionResource_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_schema_GroupVersionResource.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'fake.Slice_schema_GroupVersionResource len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'fake.Slice_schema_GroupVersionResource([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _dynamic.Slice_schema_GroupVersionResource_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _dynamic.Slice_schema_GroupVersionResource_len(self.handle)
				return Slice_schema_GroupVersionResource(handle=_dynamic.Slice_schema_GroupVersionResource_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.schema_GroupVersionResource(handle=_dynamic.Slice_schema_GroupVersionResource_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_dynamic.Slice_schema_GroupVersionResource_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_schema_GroupVersionResource.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.schema_GroupVersionResource(handle=_dynamic.Slice_schema_GroupVersionResource_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_dynamic.Slice_schema_GroupVersionResource_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[schema.GroupVersionKind]reflect.Type
class Map_schema_GroupVersionKind_reflect_Type(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Map_schema_GroupVersionKind_reflect_Type_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_schema_GroupVersionKind_reflect_Type.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_dynamic.Map_schema_GroupVersionKind_reflect_Type_set(self.handle, k, v)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Map_schema_GroupVersionKind_reflect_Type len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'dynamic.Map_schema_GroupVersionKind_reflect_Type({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _dynamic.Map_schema_GroupVersionKind_reflect_Type_len(self.handle)
	def __getitem__(self, key):
		return go.reflect_Type(handle=_dynamic.Map_schema_GroupVersionKind_reflect_Type_elem(self.handle, key.handle))
	def __setitem__(self, key, value):
		_dynamic.Map_schema_GroupVersionKind_reflect_Type_set(self.handle, key.handle, value.handle)
	def __delitem__(self, key):
		return _dynamic.Map_schema_GroupVersionKind_reflect_Type_delete(self.handle, key.handle)
	def keys(self):
		return Slice_schema_GroupVersionKind(handle=_dynamic.Map_schema_GroupVersionKind_reflect_Type_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _dynamic.Map_schema_GroupVersionKind_reflect_Type_contains(self.handle, key.handle)

# Python type for map map[schema.GroupVersionResource]string
class Map_schema_GroupVersionResource_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Map_schema_GroupVersionResource_string_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_schema_GroupVersionResource_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_dynamic.Map_schema_GroupVersionResource_string_set(self.handle, k, v)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Map_schema_GroupVersionResource_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'dynamic.Map_schema_GroupVersionResource_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _dynamic.Map_schema_GroupVersionResource_string_len(self.handle)
	def __getitem__(self, key):
		return _dynamic.Map_schema_GroupVersionResource_string_elem(self.handle, key.handle)
	def __setitem__(self, key, value):
		_dynamic.Map_schema_GroupVersionResource_string_set(self.handle, key.handle, value)
	def __delitem__(self, key):
		return _dynamic.Map_schema_GroupVersionResource_string_delete(self.handle, key.handle)
	def keys(self):
		return Slice_schema_GroupVersionResource(handle=_dynamic.Map_schema_GroupVersionResource_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _dynamic.Map_schema_GroupVersionResource_string_contains(self.handle, key.handle)

# Python type for map map[string]reflect.Type
class Map_string_reflect_Type(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.Map_string_reflect_Type_CTor()
			_dynamic.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_reflect_Type.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_dynamic.Map_string_reflect_Type_set(self.handle, k, v)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		s = 'dynamic.Map_string_reflect_Type len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'dynamic.Map_string_reflect_Type({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _dynamic.Map_string_reflect_Type_len(self.handle)
	def __getitem__(self, key):
		return go.reflect_Type(handle=_dynamic.Map_string_reflect_Type_elem(self.handle, key))
	def __setitem__(self, key, value):
		_dynamic.Map_string_reflect_Type_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _dynamic.Map_string_reflect_Type_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_dynamic.Map_string_reflect_Type_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _dynamic.Map_string_reflect_Type_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct fake.FakeDynamicClient
class FakeDynamicClient(go.GoClass):
	"""Clientset implements clientset.Interface. Meant to be embedded into a\nstruct to get a default implementation. This makes faking out just the method\nyou want to test easier.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_dynamic.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_dynamic.IncRef(self.handle)
		else:
			self.handle = _dynamic.fake_FakeDynamicClient_CTor()
			_dynamic.IncRef(self.handle)
	def __del__(self):
		_dynamic.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'fake.FakeDynamicClient{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'fake.FakeDynamicClient ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Tracker(self):
		"""Tracker() object"""
		return go.testing_ObjectTracker(handle=_dynamic.fake_FakeDynamicClient_Tracker(self.handle))
	def Resource(self, resource):
		"""Resource(object resource) object"""
		return dynamic.NamespaceableResourceInterface(handle=_dynamic.fake_FakeDynamicClient_Resource(self.handle, resource.handle))


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewSimpleDynamicClient(scheme, *args):
	"""NewSimpleDynamicClient(object scheme, []object objects) object"""
	objects = Slice_runtime_Object(args)
	return FakeDynamicClient(handle=_dynamic.fake_NewSimpleDynamicClient(scheme.handle, objects.handle))
def NewSimpleDynamicClientWithCustomListKinds(scheme, gvrToListKind, *args):
	"""NewSimpleDynamicClientWithCustomListKinds(object scheme, object gvrToListKind, []object objects) object
	
	NewSimpleDynamicClientWithCustomListKinds try not to use this.  In general you want to have the scheme have the List types registered
	and allow the default guessing for resources match.  Sometimes that doesn't work, so you can specify a custom mapping here.
	"""
	objects = Slice_runtime_Object(args)
	return FakeDynamicClient(handle=_dynamic.fake_NewSimpleDynamicClientWithCustomListKinds(scheme.handle, gvrToListKind.handle, objects.handle))


# ---- Functions ---


