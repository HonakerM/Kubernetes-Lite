/*
cgo stubs for package dynamic.
File is generated by gopy. Do not edit.
gopy pkg k8s.io/client-go/dynamic
*/

package main

/*

#cgo CFLAGS: "-I/usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/include/python3.11" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/lib" "-lpython3.11" -ldl  -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"context"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/asn1"
	"fmt"
	"io"
	"math/big"
	"math/rand"
	"mime/multipart"
	"net"
	"net/http"
	"net/textproto"
	"net/url"
	"reflect"
	"time"

	"github.com/gogo/protobuf/proto"
	fuzz "github.com/google/gofuzz"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/conversion"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/dynamic/dynamicinformer"
	"k8s.io/client-go/dynamic/dynamiclister"
	"k8s.io/client-go/dynamic/fake"
	"k8s.io/client-go/informers"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/testing"
	"k8s.io/client-go/tools/cache"
	"k8s.io/client-go/tools/clientcmd/api"
	"k8s.io/client-go/transport"
	"k8s.io/client-go/util/flowcontrol"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: dynamic below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *tls.ConnectionState
func ptrFromHandle_Ptr_tls_ConnectionState(h CGoHandle) *tls.ConnectionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tls.ConnectionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.ConnectionState{})).(*tls.ConnectionState)
}
func handleFromPtr_Ptr_tls_ConnectionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tls.ConnectionState", p))
}

// Converters for pointer handles for type: *x509.CertPool
func ptrFromHandle_Ptr_x509_CertPool(h CGoHandle) *x509.CertPool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*x509.CertPool")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.CertPool{})).(*x509.CertPool)
}
func handleFromPtr_Ptr_x509_CertPool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*x509.CertPool", p))
}

// Converters for pointer handles for type: *x509.Certificate
func ptrFromHandle_Ptr_x509_Certificate(h CGoHandle) *x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*x509.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.Certificate{})).(*x509.Certificate)
}
func handleFromPtr_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*x509.Certificate", p))
}

// Converters for pointer handles for type: *pkix.CertificateList
func ptrFromHandle_Ptr_pkix_CertificateList(h CGoHandle) *pkix.CertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pkix.CertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.CertificateList{})).(*pkix.CertificateList)
}
func handleFromPtr_Ptr_pkix_CertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pkix.CertificateList", p))
}

// Converters for pointer handles for type: *pkix.RDNSequence
func ptrFromHandle_Ptr_pkix_RDNSequence(h CGoHandle) *pkix.RDNSequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pkix.RDNSequence")
	if p == nil {
		return nil
	}
	return p.(*pkix.RDNSequence)
}
func handleFromPtr_Ptr_pkix_RDNSequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pkix.RDNSequence", p))
}

// Converters for pointer handles for type: *v1.ApplyOptions
func ptrFromHandle_Ptr_v1_ApplyOptions(h CGoHandle) *v1.ApplyOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.ApplyOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.ApplyOptions{})).(*v1.ApplyOptions)
}
func handleFromPtr_Ptr_v1_ApplyOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.ApplyOptions", p))
}

// Converters for pointer handles for type: *v1.CreateOptions
func ptrFromHandle_Ptr_v1_CreateOptions(h CGoHandle) *v1.CreateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.CreateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.CreateOptions{})).(*v1.CreateOptions)
}
func handleFromPtr_Ptr_v1_CreateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.CreateOptions", p))
}

// Converters for pointer handles for type: *v1.DeleteOptions
func ptrFromHandle_Ptr_v1_DeleteOptions(h CGoHandle) *v1.DeleteOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.DeleteOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.DeleteOptions{})).(*v1.DeleteOptions)
}
func handleFromPtr_Ptr_v1_DeleteOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.DeleteOptions", p))
}

// Converters for pointer handles for type: *v1.DeletionPropagation
func ptrFromHandle_Ptr_v1_DeletionPropagation(h CGoHandle) *v1.DeletionPropagation {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.DeletionPropagation")
	if p == nil {
		return nil
	}
	return p.(*v1.DeletionPropagation)
}
func handleFromPtr_Ptr_v1_DeletionPropagation(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.DeletionPropagation", p))
}

// Converters for pointer handles for type: *v1.FieldsV1
func ptrFromHandle_Ptr_v1_FieldsV1(h CGoHandle) *v1.FieldsV1 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.FieldsV1")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.FieldsV1{})).(*v1.FieldsV1)
}
func handleFromPtr_Ptr_v1_FieldsV1(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.FieldsV1", p))
}

// Converters for pointer handles for type: *v1.GetOptions
func ptrFromHandle_Ptr_v1_GetOptions(h CGoHandle) *v1.GetOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.GetOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.GetOptions{})).(*v1.GetOptions)
}
func handleFromPtr_Ptr_v1_GetOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.GetOptions", p))
}

// Converters for pointer handles for type: *v1.ListOptions
func ptrFromHandle_Ptr_v1_ListOptions(h CGoHandle) *v1.ListOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.ListOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.ListOptions{})).(*v1.ListOptions)
}
func handleFromPtr_Ptr_v1_ListOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.ListOptions", p))
}

// Converters for pointer handles for type: *v1.ManagedFieldsEntry
func ptrFromHandle_Ptr_v1_ManagedFieldsEntry(h CGoHandle) *v1.ManagedFieldsEntry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.ManagedFieldsEntry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.ManagedFieldsEntry{})).(*v1.ManagedFieldsEntry)
}
func handleFromPtr_Ptr_v1_ManagedFieldsEntry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.ManagedFieldsEntry", p))
}

// Converters for pointer handles for type: *v1.OwnerReference
func ptrFromHandle_Ptr_v1_OwnerReference(h CGoHandle) *v1.OwnerReference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.OwnerReference")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.OwnerReference{})).(*v1.OwnerReference)
}
func handleFromPtr_Ptr_v1_OwnerReference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.OwnerReference", p))
}

// Converters for pointer handles for type: *v1.PatchOptions
func ptrFromHandle_Ptr_v1_PatchOptions(h CGoHandle) *v1.PatchOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.PatchOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.PatchOptions{})).(*v1.PatchOptions)
}
func handleFromPtr_Ptr_v1_PatchOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.PatchOptions", p))
}

// Converters for pointer handles for type: *v1.Preconditions
func ptrFromHandle_Ptr_v1_Preconditions(h CGoHandle) *v1.Preconditions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.Preconditions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Preconditions{})).(*v1.Preconditions)
}
func handleFromPtr_Ptr_v1_Preconditions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.Preconditions", p))
}

// Converters for pointer handles for type: *v1.Time
func ptrFromHandle_Ptr_v1_Time(h CGoHandle) *v1.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Time{})).(*v1.Time)
}
func handleFromPtr_Ptr_v1_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.Time", p))
}

// Converters for pointer handles for type: *v1.Timestamp
func ptrFromHandle_Ptr_v1_Timestamp(h CGoHandle) *v1.Timestamp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.Timestamp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Timestamp{})).(*v1.Timestamp)
}
func handleFromPtr_Ptr_v1_Timestamp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.Timestamp", p))
}

// Converters for pointer handles for type: *v1.UpdateOptions
func ptrFromHandle_Ptr_v1_UpdateOptions(h CGoHandle) *v1.UpdateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.UpdateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.UpdateOptions{})).(*v1.UpdateOptions)
}
func handleFromPtr_Ptr_v1_UpdateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.UpdateOptions", p))
}

// Converters for pointer handles for type: *unstructured.Unstructured
func ptrFromHandle_Ptr_unstructured_Unstructured(h CGoHandle) *unstructured.Unstructured {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*unstructured.Unstructured")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(unstructured.Unstructured{})).(*unstructured.Unstructured)
}
func handleFromPtr_Ptr_unstructured_Unstructured(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*unstructured.Unstructured", p))
}

// Converters for pointer handles for type: *unstructured.UnstructuredList
func ptrFromHandle_Ptr_unstructured_UnstructuredList(h CGoHandle) *unstructured.UnstructuredList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*unstructured.UnstructuredList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(unstructured.UnstructuredList{})).(*unstructured.UnstructuredList)
}
func handleFromPtr_Ptr_unstructured_UnstructuredList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*unstructured.UnstructuredList", p))
}

// Converters for pointer handles for type: *conversion.Converter
func ptrFromHandle_Ptr_conversion_Converter(h CGoHandle) *conversion.Converter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*conversion.Converter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Converter{})).(*conversion.Converter)
}
func handleFromPtr_Ptr_conversion_Converter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*conversion.Converter", p))
}

// Converters for pointer handles for type: *conversion.Meta
func ptrFromHandle_Ptr_conversion_Meta(h CGoHandle) *conversion.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*conversion.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Meta{})).(*conversion.Meta)
}
func handleFromPtr_Ptr_conversion_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*conversion.Meta", p))
}

// Converters for pointer handles for type: *runtime.Scheme
func ptrFromHandle_Ptr_runtime_Scheme(h CGoHandle) *runtime.Scheme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*runtime.Scheme")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.Scheme{})).(*runtime.Scheme)
}
func handleFromPtr_Ptr_runtime_Scheme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*runtime.Scheme", p))
}

// Converters for pointer handles for type: *types.UID
func ptrFromHandle_Ptr_types_UID(h CGoHandle) *types.UID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*types.UID")
	if p == nil {
		return nil
	}
	return p.(*types.UID)
}
func handleFromPtr_Ptr_types_UID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*types.UID", p))
}

// Converters for pointer handles for type: *rest.Config
func ptrFromHandle_Ptr_rest_Config(h CGoHandle) *rest.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.Config{})).(*rest.Config)
}
func handleFromPtr_Ptr_rest_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.Config", p))
}

// Converters for pointer handles for type: *api.AuthProviderConfig
func ptrFromHandle_Ptr_api_AuthProviderConfig(h CGoHandle) *api.AuthProviderConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.AuthProviderConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.AuthProviderConfig{})).(*api.AuthProviderConfig)
}
func handleFromPtr_Ptr_api_AuthProviderConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.AuthProviderConfig", p))
}

// Converters for pointer handles for type: *api.ExecConfig
func ptrFromHandle_Ptr_api_ExecConfig(h CGoHandle) *api.ExecConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.ExecConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecConfig{})).(*api.ExecConfig)
}
func handleFromPtr_Ptr_api_ExecConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.ExecConfig", p))
}

// Converters for pointer handles for type: *api.ExecEnvVar
func ptrFromHandle_Ptr_api_ExecEnvVar(h CGoHandle) *api.ExecEnvVar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.ExecEnvVar")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecEnvVar{})).(*api.ExecEnvVar)
}
func handleFromPtr_Ptr_api_ExecEnvVar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.ExecEnvVar", p))
}

// Converters for pointer handles for type: *transport.Config
func ptrFromHandle_Ptr_transport_Config(h CGoHandle) *transport.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*transport.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.Config{})).(*transport.Config)
}
func handleFromPtr_Ptr_transport_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*transport.Config", p))
}

// Converters for pointer handles for type: *transport.DialHolder
func ptrFromHandle_Ptr_transport_DialHolder(h CGoHandle) *transport.DialHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*transport.DialHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.DialHolder{})).(*transport.DialHolder)
}
func handleFromPtr_Ptr_transport_DialHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*transport.DialHolder", p))
}

// Converters for pointer handles for type: *transport.GetCertHolder
func ptrFromHandle_Ptr_transport_GetCertHolder(h CGoHandle) *transport.GetCertHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*transport.GetCertHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.GetCertHolder{})).(*transport.GetCertHolder)
}
func handleFromPtr_Ptr_transport_GetCertHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*transport.GetCertHolder", p))
}

// Converters for pointer handles for type: *big.Int
func ptrFromHandle_Ptr_big_Int(h CGoHandle) *big.Int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*big.Int")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(big.Int{})).(*big.Int)
}
func handleFromPtr_Ptr_big_Int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*big.Int", p))
}

// Converters for pointer handles for type: *rand.Rand
func ptrFromHandle_Ptr_rand_Rand(h CGoHandle) *rand.Rand {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rand.Rand")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rand.Rand{})).(*rand.Rand)
}
func handleFromPtr_Ptr_rand_Rand(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rand.Rand", p))
}

// Converters for pointer handles for type: *multipart.FileHeader
func ptrFromHandle_Ptr_multipart_FileHeader(h CGoHandle) *multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.FileHeader{})).(*multipart.FileHeader)
}
func handleFromPtr_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.FileHeader", p))
}

// Converters for pointer handles for type: *multipart.Form
func ptrFromHandle_Ptr_multipart_Form(h CGoHandle) *multipart.Form {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Form")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Form{})).(*multipart.Form)
}
func handleFromPtr_Ptr_multipart_Form(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Form", p))
}

// Converters for pointer handles for type: *multipart.Part
func ptrFromHandle_Ptr_multipart_Part(h CGoHandle) *multipart.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Part{})).(*multipart.Part)
}
func handleFromPtr_Ptr_multipart_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Part", p))
}

// Converters for pointer handles for type: *multipart.Reader
func ptrFromHandle_Ptr_multipart_Reader(h CGoHandle) *multipart.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Reader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Reader{})).(*multipart.Reader)
}
func handleFromPtr_Ptr_multipart_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Reader", p))
}

// Converters for pointer handles for type: *net.IPNet
func ptrFromHandle_Ptr_net_IPNet(h CGoHandle) *net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*net.IPNet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.IPNet{})).(*net.IPNet)
}
func handleFromPtr_Ptr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*net.IPNet", p))
}

// Converters for pointer handles for type: *http.Client
func ptrFromHandle_Ptr_http_Client(h CGoHandle) *http.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Client{})).(*http.Client)
}
func handleFromPtr_Ptr_http_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Client", p))
}

// Converters for pointer handles for type: *http.Cookie
func ptrFromHandle_Ptr_http_Cookie(h CGoHandle) *http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Cookie")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Cookie{})).(*http.Cookie)
}
func handleFromPtr_Ptr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Cookie", p))
}

// Converters for pointer handles for type: *http.Request
func ptrFromHandle_Ptr_http_Request(h CGoHandle) *http.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Request{})).(*http.Request)
}
func handleFromPtr_Ptr_http_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Request", p))
}

// Converters for pointer handles for type: *http.Response
func ptrFromHandle_Ptr_http_Response(h CGoHandle) *http.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Response{})).(*http.Response)
}
func handleFromPtr_Ptr_http_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Response", p))
}

// Converters for pointer handles for type: *url.URL
func ptrFromHandle_Ptr_url_URL(h CGoHandle) *url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*url.URL")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.URL{})).(*url.URL)
}
func handleFromPtr_Ptr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*url.URL", p))
}

// Converters for pointer handles for type: *url.Userinfo
func ptrFromHandle_Ptr_url_Userinfo(h CGoHandle) *url.Userinfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*url.Userinfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.Userinfo{})).(*url.Userinfo)
}
func handleFromPtr_Ptr_url_Userinfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*url.Userinfo", p))
}

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for pointer handles for type: context.Context
func ptrFromHandle_context_Context(h CGoHandle) context.Context {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "context.Context")
	if p == nil {
		return nil
	}
	return p.(context.Context)
}
func handleFromPtr_context_Context(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("context.Context", p))
}

// Converters for non-pointer handles for type: tls.ConnectionState
func ptrFromHandle_tls_ConnectionState(h CGoHandle) *tls.ConnectionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tls.ConnectionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.ConnectionState{})).(*tls.ConnectionState)
}
func handleFromPtr_tls_ConnectionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tls.ConnectionState", p))
}

// Converters for non-pointer handles for type: x509.CertPool
func ptrFromHandle_x509_CertPool(h CGoHandle) *x509.CertPool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.CertPool")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.CertPool{})).(*x509.CertPool)
}
func handleFromPtr_x509_CertPool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.CertPool", p))
}

// Converters for non-pointer handles for type: x509.Certificate
func ptrFromHandle_x509_Certificate(h CGoHandle) *x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.Certificate{})).(*x509.Certificate)
}
func handleFromPtr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.Certificate", p))
}

// Converters for non-pointer handles for type: x509.OID
func ptrFromHandle_x509_OID(h CGoHandle) *x509.OID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.OID")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.OID{})).(*x509.OID)
}
func handleFromPtr_x509_OID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.OID", p))
}

// Converters for non-pointer handles for type: x509.VerifyOptions
func ptrFromHandle_x509_VerifyOptions(h CGoHandle) *x509.VerifyOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.VerifyOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.VerifyOptions{})).(*x509.VerifyOptions)
}
func handleFromPtr_x509_VerifyOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.VerifyOptions", p))
}

// Converters for non-pointer handles for type: pkix.AlgorithmIdentifier
func ptrFromHandle_pkix_AlgorithmIdentifier(h CGoHandle) *pkix.AlgorithmIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.AlgorithmIdentifier")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.AlgorithmIdentifier{})).(*pkix.AlgorithmIdentifier)
}
func handleFromPtr_pkix_AlgorithmIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.AlgorithmIdentifier", p))
}

// Converters for non-pointer handles for type: pkix.AttributeTypeAndValue
func ptrFromHandle_pkix_AttributeTypeAndValue(h CGoHandle) *pkix.AttributeTypeAndValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.AttributeTypeAndValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.AttributeTypeAndValue{})).(*pkix.AttributeTypeAndValue)
}
func handleFromPtr_pkix_AttributeTypeAndValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.AttributeTypeAndValue", p))
}

// Converters for non-pointer handles for type: pkix.CertificateList
func ptrFromHandle_pkix_CertificateList(h CGoHandle) *pkix.CertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.CertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.CertificateList{})).(*pkix.CertificateList)
}
func handleFromPtr_pkix_CertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.CertificateList", p))
}

// Converters for non-pointer handles for type: pkix.Extension
func ptrFromHandle_pkix_Extension(h CGoHandle) *pkix.Extension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.Extension")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.Extension{})).(*pkix.Extension)
}
func handleFromPtr_pkix_Extension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.Extension", p))
}

// Converters for non-pointer handles for type: pkix.Name
func ptrFromHandle_pkix_Name(h CGoHandle) *pkix.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.Name")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.Name{})).(*pkix.Name)
}
func handleFromPtr_pkix_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.Name", p))
}

// Converters for implicit pointer handles for type: pkix.RDNSequence
func ptrFromHandle_pkix_RDNSequence(h CGoHandle) *pkix.RDNSequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RDNSequence")
	if p == nil {
		return nil
	}
	return p.(*pkix.RDNSequence)
}
func deptrFromHandle_pkix_RDNSequence(h CGoHandle) pkix.RDNSequence {
	p := ptrFromHandle_pkix_RDNSequence(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_pkix_RDNSequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RDNSequence", p))
}

// Converters for implicit pointer handles for type: pkix.RelativeDistinguishedNameSET
func ptrFromHandle_pkix_RelativeDistinguishedNameSET(h CGoHandle) *pkix.RelativeDistinguishedNameSET {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RelativeDistinguishedNameSET")
	if p == nil {
		return nil
	}
	return p.(*pkix.RelativeDistinguishedNameSET)
}
func deptrFromHandle_pkix_RelativeDistinguishedNameSET(h CGoHandle) pkix.RelativeDistinguishedNameSET {
	p := ptrFromHandle_pkix_RelativeDistinguishedNameSET(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_pkix_RelativeDistinguishedNameSET(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RelativeDistinguishedNameSET", p))
}

// --- wrapping slice: pkix.RelativeDistinguishedNameSET ---
//
//export pkix_RelativeDistinguishedNameSET_CTor
func pkix_RelativeDistinguishedNameSET_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pkix_RelativeDistinguishedNameSET(&pkix.RelativeDistinguishedNameSET{}))
}

//export pkix_RelativeDistinguishedNameSET_len
func pkix_RelativeDistinguishedNameSET_len(handle CGoHandle) int {
	return len(deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle))
}

//export pkix_RelativeDistinguishedNameSET_elem
func pkix_RelativeDistinguishedNameSET_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	return handleFromPtr_pkix_AttributeTypeAndValue(&(s[_idx]))
}

//export pkix_RelativeDistinguishedNameSET_subslice
func pkix_RelativeDistinguishedNameSET_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_pkix_RelativeDistinguishedNameSET(&ss))
}

//export pkix_RelativeDistinguishedNameSET_set
func pkix_RelativeDistinguishedNameSET_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	s[_idx] = *ptrFromHandle_pkix_AttributeTypeAndValue(_vl)
}

//export pkix_RelativeDistinguishedNameSET_append
func pkix_RelativeDistinguishedNameSET_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	*s = append(*s, *ptrFromHandle_pkix_AttributeTypeAndValue(_vl))
}

// Converters for non-pointer handles for type: pkix.RevokedCertificate
func ptrFromHandle_pkix_RevokedCertificate(h CGoHandle) *pkix.RevokedCertificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RevokedCertificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.RevokedCertificate{})).(*pkix.RevokedCertificate)
}
func handleFromPtr_pkix_RevokedCertificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RevokedCertificate", p))
}

// Converters for non-pointer handles for type: pkix.TBSCertificateList
func ptrFromHandle_pkix_TBSCertificateList(h CGoHandle) *pkix.TBSCertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.TBSCertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.TBSCertificateList{})).(*pkix.TBSCertificateList)
}
func handleFromPtr_pkix_TBSCertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.TBSCertificateList", p))
}

// Converters for non-pointer handles for type: asn1.BitString
func ptrFromHandle_asn1_BitString(h CGoHandle) *asn1.BitString {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.BitString")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(asn1.BitString{})).(*asn1.BitString)
}
func handleFromPtr_asn1_BitString(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.BitString", p))
}

// Converters for implicit pointer handles for type: asn1.ObjectIdentifier
func ptrFromHandle_asn1_ObjectIdentifier(h CGoHandle) *asn1.ObjectIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.ObjectIdentifier")
	if p == nil {
		return nil
	}
	return p.(*asn1.ObjectIdentifier)
}
func deptrFromHandle_asn1_ObjectIdentifier(h CGoHandle) asn1.ObjectIdentifier {
	p := ptrFromHandle_asn1_ObjectIdentifier(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_asn1_ObjectIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.ObjectIdentifier", p))
}

// --- wrapping slice: asn1.ObjectIdentifier ---
//
//export asn1_ObjectIdentifier_CTor
func asn1_ObjectIdentifier_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_asn1_ObjectIdentifier(&asn1.ObjectIdentifier{}))
}

//export asn1_ObjectIdentifier_len
func asn1_ObjectIdentifier_len(handle CGoHandle) int {
	return len(deptrFromHandle_asn1_ObjectIdentifier(handle))
}

//export asn1_ObjectIdentifier_elem
func asn1_ObjectIdentifier_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	return C.longlong(s[_idx])
}

//export asn1_ObjectIdentifier_subslice
func asn1_ObjectIdentifier_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_asn1_ObjectIdentifier(&ss))
}

//export asn1_ObjectIdentifier_set
func asn1_ObjectIdentifier_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	s[_idx] = int(_vl)
}

//export asn1_ObjectIdentifier_append
func asn1_ObjectIdentifier_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_asn1_ObjectIdentifier(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: asn1.RawContent
func ptrFromHandle_asn1_RawContent(h CGoHandle) *asn1.RawContent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.RawContent")
	if p == nil {
		return nil
	}
	return p.(*asn1.RawContent)
}
func deptrFromHandle_asn1_RawContent(h CGoHandle) asn1.RawContent {
	p := ptrFromHandle_asn1_RawContent(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_asn1_RawContent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.RawContent", p))
}

// --- wrapping slice: asn1.RawContent ---
//
//export asn1_RawContent_CTor
func asn1_RawContent_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_asn1_RawContent(&asn1.RawContent{}))
}

//export asn1_RawContent_len
func asn1_RawContent_len(handle CGoHandle) int {
	return len(deptrFromHandle_asn1_RawContent(handle))
}

//export asn1_RawContent_elem
func asn1_RawContent_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_asn1_RawContent(handle)
	return C.char(s[_idx])
}

//export asn1_RawContent_subslice
func asn1_RawContent_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_asn1_RawContent(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_asn1_RawContent(&ss))
}

//export asn1_RawContent_set
func asn1_RawContent_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_asn1_RawContent(handle)
	s[_idx] = byte(_vl)
}

//export asn1_RawContent_append
func asn1_RawContent_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_asn1_RawContent(handle)
	*s = append(*s, byte(_vl))
}

// Converters for non-pointer handles for type: asn1.RawValue
func ptrFromHandle_asn1_RawValue(h CGoHandle) *asn1.RawValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.RawValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(asn1.RawValue{})).(*asn1.RawValue)
}
func handleFromPtr_asn1_RawValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.RawValue", p))
}

// Converters for pointer handles for type: fmt.ScanState
func ptrFromHandle_fmt_ScanState(h CGoHandle) fmt.ScanState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fmt.ScanState")
	if p == nil {
		return nil
	}
	return p.(fmt.ScanState)
}
func handleFromPtr_fmt_ScanState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fmt.ScanState", p))
}

// Converters for pointer handles for type: fmt.State
func ptrFromHandle_fmt_State(h CGoHandle) fmt.State {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fmt.State")
	if p == nil {
		return nil
	}
	return p.(fmt.State)
}
func handleFromPtr_fmt_State(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fmt.State", p))
}

// Converters for pointer handles for type: proto.Message
func ptrFromHandle_proto_Message(h CGoHandle) proto.Message {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "proto.Message")
	if p == nil {
		return nil
	}
	return p.(proto.Message)
}
func handleFromPtr_proto_Message(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("proto.Message", p))
}

// Converters for non-pointer handles for type: fuzz.Continue
func ptrFromHandle_fuzz_Continue(h CGoHandle) *fuzz.Continue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fuzz.Continue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fuzz.Continue{})).(*fuzz.Continue)
}
func handleFromPtr_fuzz_Continue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fuzz.Continue", p))
}

// Converters for pointer handles for type: io.ReadCloser
func ptrFromHandle_io_ReadCloser(h CGoHandle) io.ReadCloser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.ReadCloser")
	if p == nil {
		return nil
	}
	return p.(io.ReadCloser)
}
func handleFromPtr_io_ReadCloser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.ReadCloser", p))
}

// Converters for pointer handles for type: io.Reader
func ptrFromHandle_io_Reader(h CGoHandle) io.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Reader")
	if p == nil {
		return nil
	}
	return p.(io.Reader)
}
func handleFromPtr_io_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Reader", p))
}

// Converters for pointer handles for type: io.Writer
func ptrFromHandle_io_Writer(h CGoHandle) io.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Writer")
	if p == nil {
		return nil
	}
	return p.(io.Writer)
}
func handleFromPtr_io_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Writer", p))
}

// Converters for non-pointer handles for type: v1.ApplyOptions
func ptrFromHandle_v1_ApplyOptions(h CGoHandle) *v1.ApplyOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.ApplyOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.ApplyOptions{})).(*v1.ApplyOptions)
}
func handleFromPtr_v1_ApplyOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.ApplyOptions", p))
}

// Converters for non-pointer handles for type: v1.CreateOptions
func ptrFromHandle_v1_CreateOptions(h CGoHandle) *v1.CreateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.CreateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.CreateOptions{})).(*v1.CreateOptions)
}
func handleFromPtr_v1_CreateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.CreateOptions", p))
}

// Converters for non-pointer handles for type: v1.DeleteOptions
func ptrFromHandle_v1_DeleteOptions(h CGoHandle) *v1.DeleteOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.DeleteOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.DeleteOptions{})).(*v1.DeleteOptions)
}
func handleFromPtr_v1_DeleteOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.DeleteOptions", p))
}

// Converters for non-pointer handles for type: v1.FieldsV1
func ptrFromHandle_v1_FieldsV1(h CGoHandle) *v1.FieldsV1 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.FieldsV1")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.FieldsV1{})).(*v1.FieldsV1)
}
func handleFromPtr_v1_FieldsV1(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.FieldsV1", p))
}

// Converters for non-pointer handles for type: v1.GetOptions
func ptrFromHandle_v1_GetOptions(h CGoHandle) *v1.GetOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.GetOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.GetOptions{})).(*v1.GetOptions)
}
func handleFromPtr_v1_GetOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.GetOptions", p))
}

// Converters for non-pointer handles for type: v1.ListOptions
func ptrFromHandle_v1_ListOptions(h CGoHandle) *v1.ListOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.ListOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.ListOptions{})).(*v1.ListOptions)
}
func handleFromPtr_v1_ListOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.ListOptions", p))
}

// Converters for non-pointer handles for type: v1.ManagedFieldsEntry
func ptrFromHandle_v1_ManagedFieldsEntry(h CGoHandle) *v1.ManagedFieldsEntry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.ManagedFieldsEntry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.ManagedFieldsEntry{})).(*v1.ManagedFieldsEntry)
}
func handleFromPtr_v1_ManagedFieldsEntry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.ManagedFieldsEntry", p))
}

// Converters for non-pointer handles for type: v1.OwnerReference
func ptrFromHandle_v1_OwnerReference(h CGoHandle) *v1.OwnerReference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.OwnerReference")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.OwnerReference{})).(*v1.OwnerReference)
}
func handleFromPtr_v1_OwnerReference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.OwnerReference", p))
}

// Converters for non-pointer handles for type: v1.PatchOptions
func ptrFromHandle_v1_PatchOptions(h CGoHandle) *v1.PatchOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.PatchOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.PatchOptions{})).(*v1.PatchOptions)
}
func handleFromPtr_v1_PatchOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.PatchOptions", p))
}

// Converters for non-pointer handles for type: v1.Preconditions
func ptrFromHandle_v1_Preconditions(h CGoHandle) *v1.Preconditions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.Preconditions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Preconditions{})).(*v1.Preconditions)
}
func handleFromPtr_v1_Preconditions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.Preconditions", p))
}

// Converters for non-pointer handles for type: v1.Time
func ptrFromHandle_v1_Time(h CGoHandle) *v1.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Time{})).(*v1.Time)
}
func handleFromPtr_v1_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.Time", p))
}

// Converters for non-pointer handles for type: v1.Timestamp
func ptrFromHandle_v1_Timestamp(h CGoHandle) *v1.Timestamp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.Timestamp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Timestamp{})).(*v1.Timestamp)
}
func handleFromPtr_v1_Timestamp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.Timestamp", p))
}

// Converters for non-pointer handles for type: v1.UpdateOptions
func ptrFromHandle_v1_UpdateOptions(h CGoHandle) *v1.UpdateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.UpdateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.UpdateOptions{})).(*v1.UpdateOptions)
}
func handleFromPtr_v1_UpdateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.UpdateOptions", p))
}

// Converters for non-pointer handles for type: unstructured.Unstructured
func ptrFromHandle_unstructured_Unstructured(h CGoHandle) *unstructured.Unstructured {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "unstructured.Unstructured")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(unstructured.Unstructured{})).(*unstructured.Unstructured)
}
func handleFromPtr_unstructured_Unstructured(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("unstructured.Unstructured", p))
}

// Converters for non-pointer handles for type: unstructured.UnstructuredList
func ptrFromHandle_unstructured_UnstructuredList(h CGoHandle) *unstructured.UnstructuredList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "unstructured.UnstructuredList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(unstructured.UnstructuredList{})).(*unstructured.UnstructuredList)
}
func handleFromPtr_unstructured_UnstructuredList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("unstructured.UnstructuredList", p))
}

// Converters for non-pointer handles for type: conversion.ConversionFuncs
func ptrFromHandle_conversion_ConversionFuncs(h CGoHandle) *conversion.ConversionFuncs {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "conversion.ConversionFuncs")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.ConversionFuncs{})).(*conversion.ConversionFuncs)
}
func handleFromPtr_conversion_ConversionFuncs(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("conversion.ConversionFuncs", p))
}

// Converters for non-pointer handles for type: conversion.Converter
func ptrFromHandle_conversion_Converter(h CGoHandle) *conversion.Converter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "conversion.Converter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Converter{})).(*conversion.Converter)
}
func handleFromPtr_conversion_Converter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("conversion.Converter", p))
}

// Converters for non-pointer handles for type: conversion.Meta
func ptrFromHandle_conversion_Meta(h CGoHandle) *conversion.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "conversion.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Meta{})).(*conversion.Meta)
}
func handleFromPtr_conversion_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("conversion.Meta", p))
}

// Converters for pointer handles for type: labels.Selector
func ptrFromHandle_labels_Selector(h CGoHandle) labels.Selector {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "labels.Selector")
	if p == nil {
		return nil
	}
	return p.(labels.Selector)
}
func handleFromPtr_labels_Selector(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("labels.Selector", p))
}

// Converters for pointer handles for type: runtime.GroupVersioner
func ptrFromHandle_runtime_GroupVersioner(h CGoHandle) runtime.GroupVersioner {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.GroupVersioner")
	if p == nil {
		return nil
	}
	return p.(runtime.GroupVersioner)
}
func handleFromPtr_runtime_GroupVersioner(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.GroupVersioner", p))
}

// Converters for pointer handles for type: runtime.Object
func ptrFromHandle_runtime_Object(h CGoHandle) runtime.Object {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Object")
	if p == nil {
		return nil
	}
	return p.(runtime.Object)
}
func handleFromPtr_runtime_Object(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Object", p))
}

// Converters for non-pointer handles for type: runtime.Scheme
func ptrFromHandle_runtime_Scheme(h CGoHandle) *runtime.Scheme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Scheme")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.Scheme{})).(*runtime.Scheme)
}
func handleFromPtr_runtime_Scheme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Scheme", p))
}

// Converters for pointer handles for type: runtime.Unstructured
func ptrFromHandle_runtime_Unstructured(h CGoHandle) runtime.Unstructured {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Unstructured")
	if p == nil {
		return nil
	}
	return p.(runtime.Unstructured)
}
func handleFromPtr_runtime_Unstructured(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Unstructured", p))
}

// Converters for non-pointer handles for type: schema.GroupKind
func ptrFromHandle_schema_GroupKind(h CGoHandle) *schema.GroupKind {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupKind")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupKind{})).(*schema.GroupKind)
}
func handleFromPtr_schema_GroupKind(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupKind", p))
}

// Converters for non-pointer handles for type: schema.GroupResource
func ptrFromHandle_schema_GroupResource(h CGoHandle) *schema.GroupResource {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupResource")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupResource{})).(*schema.GroupResource)
}
func handleFromPtr_schema_GroupResource(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupResource", p))
}

// Converters for non-pointer handles for type: schema.GroupVersion
func ptrFromHandle_schema_GroupVersion(h CGoHandle) *schema.GroupVersion {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupVersion")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupVersion{})).(*schema.GroupVersion)
}
func handleFromPtr_schema_GroupVersion(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupVersion", p))
}

// Converters for non-pointer handles for type: schema.GroupVersionKind
func ptrFromHandle_schema_GroupVersionKind(h CGoHandle) *schema.GroupVersionKind {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupVersionKind")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupVersionKind{})).(*schema.GroupVersionKind)
}
func handleFromPtr_schema_GroupVersionKind(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupVersionKind", p))
}

// Converters for non-pointer handles for type: schema.GroupVersionResource
func ptrFromHandle_schema_GroupVersionResource(h CGoHandle) *schema.GroupVersionResource {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupVersionResource")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupVersionResource{})).(*schema.GroupVersionResource)
}
func handleFromPtr_schema_GroupVersionResource(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupVersionResource", p))
}

// Converters for pointer handles for type: schema.ObjectKind
func ptrFromHandle_schema_ObjectKind(h CGoHandle) schema.ObjectKind {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.ObjectKind")
	if p == nil {
		return nil
	}
	return p.(schema.ObjectKind)
}
func handleFromPtr_schema_ObjectKind(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.ObjectKind", p))
}

// Converters for pointer handles for type: watch.Interface
func ptrFromHandle_watch_Interface(h CGoHandle) watch.Interface {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "watch.Interface")
	if p == nil {
		return nil
	}
	return p.(watch.Interface)
}
func handleFromPtr_watch_Interface(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("watch.Interface", p))
}

// Converters for pointer handles for type: informers.GenericInformer
func ptrFromHandle_informers_GenericInformer(h CGoHandle) informers.GenericInformer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "informers.GenericInformer")
	if p == nil {
		return nil
	}
	return p.(informers.GenericInformer)
}
func handleFromPtr_informers_GenericInformer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("informers.GenericInformer", p))
}

// Converters for pointer handles for type: rest.AuthProviderConfigPersister
func ptrFromHandle_rest_AuthProviderConfigPersister(h CGoHandle) rest.AuthProviderConfigPersister {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.AuthProviderConfigPersister")
	if p == nil {
		return nil
	}
	return p.(rest.AuthProviderConfigPersister)
}
func handleFromPtr_rest_AuthProviderConfigPersister(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.AuthProviderConfigPersister", p))
}

// Converters for non-pointer handles for type: rest.Config
func ptrFromHandle_rest_Config(h CGoHandle) *rest.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.Config{})).(*rest.Config)
}
func handleFromPtr_rest_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.Config", p))
}

// Converters for non-pointer handles for type: rest.ImpersonationConfig
func ptrFromHandle_rest_ImpersonationConfig(h CGoHandle) *rest.ImpersonationConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.ImpersonationConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.ImpersonationConfig{})).(*rest.ImpersonationConfig)
}
func handleFromPtr_rest_ImpersonationConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.ImpersonationConfig", p))
}

// Converters for pointer handles for type: rest.Interface
func ptrFromHandle_rest_Interface(h CGoHandle) rest.Interface {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.Interface")
	if p == nil {
		return nil
	}
	return p.(rest.Interface)
}
func handleFromPtr_rest_Interface(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.Interface", p))
}

// Converters for pointer handles for type: rest.WarningHandler
func ptrFromHandle_rest_WarningHandler(h CGoHandle) rest.WarningHandler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.WarningHandler")
	if p == nil {
		return nil
	}
	return p.(rest.WarningHandler)
}
func handleFromPtr_rest_WarningHandler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.WarningHandler", p))
}

// Converters for pointer handles for type: testing.ObjectTracker
func ptrFromHandle_testing_ObjectTracker(h CGoHandle) testing.ObjectTracker {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "testing.ObjectTracker")
	if p == nil {
		return nil
	}
	return p.(testing.ObjectTracker)
}
func handleFromPtr_testing_ObjectTracker(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("testing.ObjectTracker", p))
}

// Converters for pointer handles for type: cache.GenericLister
func ptrFromHandle_cache_GenericLister(h CGoHandle) cache.GenericLister {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "cache.GenericLister")
	if p == nil {
		return nil
	}
	return p.(cache.GenericLister)
}
func handleFromPtr_cache_GenericLister(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("cache.GenericLister", p))
}

// Converters for pointer handles for type: cache.Indexer
func ptrFromHandle_cache_Indexer(h CGoHandle) cache.Indexer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "cache.Indexer")
	if p == nil {
		return nil
	}
	return p.(cache.Indexer)
}
func handleFromPtr_cache_Indexer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("cache.Indexer", p))
}

// Converters for non-pointer handles for type: api.AuthProviderConfig
func ptrFromHandle_api_AuthProviderConfig(h CGoHandle) *api.AuthProviderConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.AuthProviderConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.AuthProviderConfig{})).(*api.AuthProviderConfig)
}
func handleFromPtr_api_AuthProviderConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.AuthProviderConfig", p))
}

// Converters for non-pointer handles for type: api.ExecConfig
func ptrFromHandle_api_ExecConfig(h CGoHandle) *api.ExecConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.ExecConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecConfig{})).(*api.ExecConfig)
}
func handleFromPtr_api_ExecConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.ExecConfig", p))
}

// Converters for non-pointer handles for type: api.ExecEnvVar
func ptrFromHandle_api_ExecEnvVar(h CGoHandle) *api.ExecEnvVar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.ExecEnvVar")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecEnvVar{})).(*api.ExecEnvVar)
}
func handleFromPtr_api_ExecEnvVar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.ExecEnvVar", p))
}

// Converters for non-pointer handles for type: transport.Config
func ptrFromHandle_transport_Config(h CGoHandle) *transport.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.Config{})).(*transport.Config)
}
func handleFromPtr_transport_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.Config", p))
}

// Converters for non-pointer handles for type: transport.DialHolder
func ptrFromHandle_transport_DialHolder(h CGoHandle) *transport.DialHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.DialHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.DialHolder{})).(*transport.DialHolder)
}
func handleFromPtr_transport_DialHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.DialHolder", p))
}

// Converters for non-pointer handles for type: transport.GetCertHolder
func ptrFromHandle_transport_GetCertHolder(h CGoHandle) *transport.GetCertHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.GetCertHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.GetCertHolder{})).(*transport.GetCertHolder)
}
func handleFromPtr_transport_GetCertHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.GetCertHolder", p))
}

// Converters for non-pointer handles for type: transport.ImpersonationConfig
func ptrFromHandle_transport_ImpersonationConfig(h CGoHandle) *transport.ImpersonationConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.ImpersonationConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.ImpersonationConfig{})).(*transport.ImpersonationConfig)
}
func handleFromPtr_transport_ImpersonationConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.ImpersonationConfig", p))
}

// Converters for non-pointer handles for type: transport.TLSConfig
func ptrFromHandle_transport_TLSConfig(h CGoHandle) *transport.TLSConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.TLSConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.TLSConfig{})).(*transport.TLSConfig)
}
func handleFromPtr_transport_TLSConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.TLSConfig", p))
}

// Converters for pointer handles for type: flowcontrol.RateLimiter
func ptrFromHandle_flowcontrol_RateLimiter(h CGoHandle) flowcontrol.RateLimiter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "flowcontrol.RateLimiter")
	if p == nil {
		return nil
	}
	return p.(flowcontrol.RateLimiter)
}
func handleFromPtr_flowcontrol_RateLimiter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("flowcontrol.RateLimiter", p))
}

// Converters for non-pointer handles for type: big.Int
func ptrFromHandle_big_Int(h CGoHandle) *big.Int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "big.Int")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(big.Int{})).(*big.Int)
}
func handleFromPtr_big_Int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("big.Int", p))
}

// Converters for non-pointer handles for type: rand.Rand
func ptrFromHandle_rand_Rand(h CGoHandle) *rand.Rand {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rand.Rand")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rand.Rand{})).(*rand.Rand)
}
func handleFromPtr_rand_Rand(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rand.Rand", p))
}

// Converters for pointer handles for type: multipart.File
func ptrFromHandle_multipart_File(h CGoHandle) multipart.File {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.File")
	if p == nil {
		return nil
	}
	return p.(multipart.File)
}
func handleFromPtr_multipart_File(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.File", p))
}

// Converters for non-pointer handles for type: multipart.FileHeader
func ptrFromHandle_multipart_FileHeader(h CGoHandle) *multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.FileHeader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.FileHeader{})).(*multipart.FileHeader)
}
func handleFromPtr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.FileHeader", p))
}

// Converters for non-pointer handles for type: multipart.Form
func ptrFromHandle_multipart_Form(h CGoHandle) *multipart.Form {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Form")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Form{})).(*multipart.Form)
}
func handleFromPtr_multipart_Form(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Form", p))
}

// Converters for non-pointer handles for type: multipart.Part
func ptrFromHandle_multipart_Part(h CGoHandle) *multipart.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Part{})).(*multipart.Part)
}
func handleFromPtr_multipart_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Part", p))
}

// Converters for non-pointer handles for type: multipart.Reader
func ptrFromHandle_multipart_Reader(h CGoHandle) *multipart.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Reader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Reader{})).(*multipart.Reader)
}
func handleFromPtr_multipart_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Reader", p))
}

// Converters for implicit pointer handles for type: net.IP
func ptrFromHandle_net_IP(h CGoHandle) *net.IP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IP")
	if p == nil {
		return nil
	}
	return p.(*net.IP)
}
func deptrFromHandle_net_IP(h CGoHandle) net.IP {
	p := ptrFromHandle_net_IP(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IP", p))
}

// --- wrapping slice: net.IP ---
//
//export net_IP_CTor
func net_IP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IP(&net.IP{}))
}

//export net_IP_len
func net_IP_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IP(handle))
}

//export net_IP_elem
func net_IP_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IP(handle)
	return C.char(s[_idx])
}

//export net_IP_subslice
func net_IP_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IP(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IP(&ss))
}

//export net_IP_set
func net_IP_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IP(handle)
	s[_idx] = byte(_vl)
}

//export net_IP_append
func net_IP_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IP(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: net.IPMask
func ptrFromHandle_net_IPMask(h CGoHandle) *net.IPMask {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IPMask")
	if p == nil {
		return nil
	}
	return p.(*net.IPMask)
}
func deptrFromHandle_net_IPMask(h CGoHandle) net.IPMask {
	p := ptrFromHandle_net_IPMask(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IPMask(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IPMask", p))
}

// --- wrapping slice: net.IPMask ---
//
//export net_IPMask_CTor
func net_IPMask_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IPMask(&net.IPMask{}))
}

//export net_IPMask_len
func net_IPMask_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IPMask(handle))
}

//export net_IPMask_elem
func net_IPMask_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IPMask(handle)
	return C.char(s[_idx])
}

//export net_IPMask_subslice
func net_IPMask_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IPMask(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IPMask(&ss))
}

//export net_IPMask_set
func net_IPMask_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IPMask(handle)
	s[_idx] = byte(_vl)
}

//export net_IPMask_append
func net_IPMask_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IPMask(handle)
	*s = append(*s, byte(_vl))
}

// Converters for non-pointer handles for type: net.IPNet
func ptrFromHandle_net_IPNet(h CGoHandle) *net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IPNet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.IPNet{})).(*net.IPNet)
}
func handleFromPtr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IPNet", p))
}

// Converters for non-pointer handles for type: http.Client
func ptrFromHandle_http_Client(h CGoHandle) *http.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Client{})).(*http.Client)
}
func handleFromPtr_http_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Client", p))
}

// Converters for non-pointer handles for type: http.Cookie
func ptrFromHandle_http_Cookie(h CGoHandle) *http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Cookie")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Cookie{})).(*http.Cookie)
}
func handleFromPtr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Cookie", p))
}

// Converters for pointer handles for type: http.CookieJar
func ptrFromHandle_http_CookieJar(h CGoHandle) http.CookieJar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.CookieJar")
	if p == nil {
		return nil
	}
	return p.(http.CookieJar)
}
func handleFromPtr_http_CookieJar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.CookieJar", p))
}

// Converters for implicit pointer handles for type: http.Header
func ptrFromHandle_http_Header(h CGoHandle) *http.Header {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Header")
	if p == nil {
		return nil
	}
	return p.(*http.Header)
}
func deptrFromHandle_http_Header(h CGoHandle) http.Header {
	p := ptrFromHandle_http_Header(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_http_Header(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Header", p))
}

// --- wrapping map: http.Header ---
//
//export http_Header_CTor
func http_Header_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_http_Header(&http.Header{}))
}

//export http_Header_len
func http_Header_len(handle CGoHandle) int {
	return len(deptrFromHandle_http_Header(handle))
}

//export http_Header_elem
func http_Header_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_http_Header(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export http_Header_contains
func http_Header_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_http_Header(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export http_Header_set
func http_Header_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_http_Header(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export http_Header_delete
func http_Header_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_http_Header(handle)
	delete(s, C.GoString(_ky))
}

//export http_Header_keys
func http_Header_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_http_Header(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: http.Request
func ptrFromHandle_http_Request(h CGoHandle) *http.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Request{})).(*http.Request)
}
func handleFromPtr_http_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Request", p))
}

// Converters for non-pointer handles for type: http.Response
func ptrFromHandle_http_Response(h CGoHandle) *http.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Response{})).(*http.Response)
}
func handleFromPtr_http_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Response", p))
}

// Converters for pointer handles for type: http.RoundTripper
func ptrFromHandle_http_RoundTripper(h CGoHandle) http.RoundTripper {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.RoundTripper")
	if p == nil {
		return nil
	}
	return p.(http.RoundTripper)
}
func handleFromPtr_http_RoundTripper(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.RoundTripper", p))
}

// Converters for implicit pointer handles for type: textproto.MIMEHeader
func ptrFromHandle_textproto_MIMEHeader(h CGoHandle) *textproto.MIMEHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "textproto.MIMEHeader")
	if p == nil {
		return nil
	}
	return p.(*textproto.MIMEHeader)
}
func deptrFromHandle_textproto_MIMEHeader(h CGoHandle) textproto.MIMEHeader {
	p := ptrFromHandle_textproto_MIMEHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_textproto_MIMEHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("textproto.MIMEHeader", p))
}

// --- wrapping map: textproto.MIMEHeader ---
//
//export textproto_MIMEHeader_CTor
func textproto_MIMEHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_textproto_MIMEHeader(&textproto.MIMEHeader{}))
}

//export textproto_MIMEHeader_len
func textproto_MIMEHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_textproto_MIMEHeader(handle))
}

//export textproto_MIMEHeader_elem
func textproto_MIMEHeader_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export textproto_MIMEHeader_contains
func textproto_MIMEHeader_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export textproto_MIMEHeader_set
func textproto_MIMEHeader_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export textproto_MIMEHeader_delete
func textproto_MIMEHeader_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	delete(s, C.GoString(_ky))
}

//export textproto_MIMEHeader_keys
func textproto_MIMEHeader_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: url.URL
func ptrFromHandle_url_URL(h CGoHandle) *url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.URL")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.URL{})).(*url.URL)
}
func handleFromPtr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.URL", p))
}

// Converters for non-pointer handles for type: url.Userinfo
func ptrFromHandle_url_Userinfo(h CGoHandle) *url.Userinfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.Userinfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.Userinfo{})).(*url.Userinfo)
}
func handleFromPtr_url_Userinfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.Userinfo", p))
}

// Converters for implicit pointer handles for type: url.Values
func ptrFromHandle_url_Values(h CGoHandle) *url.Values {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.Values")
	if p == nil {
		return nil
	}
	return p.(*url.Values)
}
func deptrFromHandle_url_Values(h CGoHandle) url.Values {
	p := ptrFromHandle_url_Values(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_url_Values(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.Values", p))
}

// --- wrapping map: url.Values ---
//
//export url_Values_CTor
func url_Values_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_url_Values(&url.Values{}))
}

//export url_Values_len
func url_Values_len(handle CGoHandle) int {
	return len(deptrFromHandle_url_Values(handle))
}

//export url_Values_elem
func url_Values_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_url_Values(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export url_Values_contains
func url_Values_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_url_Values(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export url_Values_set
func url_Values_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_url_Values(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export url_Values_delete
func url_Values_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_url_Values(handle)
	delete(s, C.GoString(_ky))
}

//export url_Values_keys
func url_Values_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_url_Values(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for pointer handles for type: reflect.Type
func ptrFromHandle_reflect_Type(h CGoHandle) reflect.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "reflect.Type")
	if p == nil {
		return nil
	}
	return p.(reflect.Type)
}
func handleFromPtr_reflect_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("reflect.Type", p))
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: dynamic ---

// ---- Types ---

// Converters for pointer handles for type: *dynamic.DynamicClient
func ptrFromHandle_Ptr_dynamic_DynamicClient(h CGoHandle) *dynamic.DynamicClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*dynamic.DynamicClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(dynamic.DynamicClient{})).(*dynamic.DynamicClient)
}
func handleFromPtr_Ptr_dynamic_DynamicClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*dynamic.DynamicClient", p))
}

// Converters for implicit pointer handles for type: []*x509.Certificate
func ptrFromHandle_Slice_Ptr_x509_Certificate(h CGoHandle) *[]*x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*x509.Certificate")
	if p == nil {
		return nil
	}
	return p.(*[]*x509.Certificate)
}
func deptrFromHandle_Slice_Ptr_x509_Certificate(h CGoHandle) []*x509.Certificate {
	p := ptrFromHandle_Slice_Ptr_x509_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*x509.Certificate", p))
}

// --- wrapping slice: []*x509.Certificate ---
//
//export Slice_Ptr_x509_Certificate_CTor
func Slice_Ptr_x509_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_x509_Certificate(&[]*x509.Certificate{}))
}

//export Slice_Ptr_x509_Certificate_len
func Slice_Ptr_x509_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_x509_Certificate(handle))
}

//export Slice_Ptr_x509_Certificate_elem
func Slice_Ptr_x509_Certificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	return handleFromPtr_Ptr_x509_Certificate(&(s[_idx]))
}

//export Slice_Ptr_x509_Certificate_subslice
func Slice_Ptr_x509_Certificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_x509_Certificate(&ss))
}

//export Slice_Ptr_x509_Certificate_set
func Slice_Ptr_x509_Certificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	s[_idx] = ptrFromHandle_Ptr_x509_Certificate(_vl)
}

//export Slice_Ptr_x509_Certificate_append
func Slice_Ptr_x509_Certificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	*s = append(*s, ptrFromHandle_Ptr_x509_Certificate(_vl))
}

// Converters for implicit pointer handles for type: []*multipart.FileHeader
func ptrFromHandle_Slice_Ptr_multipart_FileHeader(h CGoHandle) *[]*multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return p.(*[]*multipart.FileHeader)
}
func deptrFromHandle_Slice_Ptr_multipart_FileHeader(h CGoHandle) []*multipart.FileHeader {
	p := ptrFromHandle_Slice_Ptr_multipart_FileHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*multipart.FileHeader", p))
}

// --- wrapping slice: []*multipart.FileHeader ---
//
//export Slice_Ptr_multipart_FileHeader_CTor
func Slice_Ptr_multipart_FileHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_multipart_FileHeader(&[]*multipart.FileHeader{}))
}

//export Slice_Ptr_multipart_FileHeader_len
func Slice_Ptr_multipart_FileHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle))
}

//export Slice_Ptr_multipart_FileHeader_elem
func Slice_Ptr_multipart_FileHeader_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	return handleFromPtr_Ptr_multipart_FileHeader(&(s[_idx]))
}

//export Slice_Ptr_multipart_FileHeader_subslice
func Slice_Ptr_multipart_FileHeader_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_multipart_FileHeader(&ss))
}

//export Slice_Ptr_multipart_FileHeader_set
func Slice_Ptr_multipart_FileHeader_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	s[_idx] = ptrFromHandle_Ptr_multipart_FileHeader(_vl)
}

//export Slice_Ptr_multipart_FileHeader_append
func Slice_Ptr_multipart_FileHeader_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	*s = append(*s, ptrFromHandle_Ptr_multipart_FileHeader(_vl))
}

// Converters for implicit pointer handles for type: []*net.IPNet
func ptrFromHandle_Slice_Ptr_net_IPNet(h CGoHandle) *[]*net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*net.IPNet")
	if p == nil {
		return nil
	}
	return p.(*[]*net.IPNet)
}
func deptrFromHandle_Slice_Ptr_net_IPNet(h CGoHandle) []*net.IPNet {
	p := ptrFromHandle_Slice_Ptr_net_IPNet(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*net.IPNet", p))
}

// --- wrapping slice: []*net.IPNet ---
//
//export Slice_Ptr_net_IPNet_CTor
func Slice_Ptr_net_IPNet_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_net_IPNet(&[]*net.IPNet{}))
}

//export Slice_Ptr_net_IPNet_len
func Slice_Ptr_net_IPNet_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_net_IPNet(handle))
}

//export Slice_Ptr_net_IPNet_elem
func Slice_Ptr_net_IPNet_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	return handleFromPtr_Ptr_net_IPNet(&(s[_idx]))
}

//export Slice_Ptr_net_IPNet_subslice
func Slice_Ptr_net_IPNet_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_net_IPNet(&ss))
}

//export Slice_Ptr_net_IPNet_set
func Slice_Ptr_net_IPNet_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	s[_idx] = ptrFromHandle_Ptr_net_IPNet(_vl)
}

//export Slice_Ptr_net_IPNet_append
func Slice_Ptr_net_IPNet_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_net_IPNet(handle)
	*s = append(*s, ptrFromHandle_Ptr_net_IPNet(_vl))
}

// Converters for implicit pointer handles for type: []*http.Cookie
func ptrFromHandle_Slice_Ptr_http_Cookie(h CGoHandle) *[]*http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*http.Cookie")
	if p == nil {
		return nil
	}
	return p.(*[]*http.Cookie)
}
func deptrFromHandle_Slice_Ptr_http_Cookie(h CGoHandle) []*http.Cookie {
	p := ptrFromHandle_Slice_Ptr_http_Cookie(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*http.Cookie", p))
}

// --- wrapping slice: []*http.Cookie ---
//
//export Slice_Ptr_http_Cookie_CTor
func Slice_Ptr_http_Cookie_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_http_Cookie(&[]*http.Cookie{}))
}

//export Slice_Ptr_http_Cookie_len
func Slice_Ptr_http_Cookie_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_http_Cookie(handle))
}

//export Slice_Ptr_http_Cookie_elem
func Slice_Ptr_http_Cookie_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	return handleFromPtr_Ptr_http_Cookie(&(s[_idx]))
}

//export Slice_Ptr_http_Cookie_subslice
func Slice_Ptr_http_Cookie_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_http_Cookie(&ss))
}

//export Slice_Ptr_http_Cookie_set
func Slice_Ptr_http_Cookie_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	s[_idx] = ptrFromHandle_Ptr_http_Cookie(_vl)
}

//export Slice_Ptr_http_Cookie_append
func Slice_Ptr_http_Cookie_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_http_Cookie(handle)
	*s = append(*s, ptrFromHandle_Ptr_http_Cookie(_vl))
}

// Converters for implicit pointer handles for type: []*url.URL
func ptrFromHandle_Slice_Ptr_url_URL(h CGoHandle) *[]*url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*url.URL")
	if p == nil {
		return nil
	}
	return p.(*[]*url.URL)
}
func deptrFromHandle_Slice_Ptr_url_URL(h CGoHandle) []*url.URL {
	p := ptrFromHandle_Slice_Ptr_url_URL(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*url.URL", p))
}

// --- wrapping slice: []*url.URL ---
//
//export Slice_Ptr_url_URL_CTor
func Slice_Ptr_url_URL_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_url_URL(&[]*url.URL{}))
}

//export Slice_Ptr_url_URL_len
func Slice_Ptr_url_URL_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_url_URL(handle))
}

//export Slice_Ptr_url_URL_elem
func Slice_Ptr_url_URL_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	return handleFromPtr_Ptr_url_URL(&(s[_idx]))
}

//export Slice_Ptr_url_URL_subslice
func Slice_Ptr_url_URL_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_url_URL(&ss))
}

//export Slice_Ptr_url_URL_set
func Slice_Ptr_url_URL_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	s[_idx] = ptrFromHandle_Ptr_url_URL(_vl)
}

//export Slice_Ptr_url_URL_append
func Slice_Ptr_url_URL_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_url_URL(handle)
	*s = append(*s, ptrFromHandle_Ptr_url_URL(_vl))
}

// Converters for implicit pointer handles for type: [][]*x509.Certificate
func ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h CGoHandle) *[][]*x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]*x509.Certificate")
	if p == nil {
		return nil
	}
	return p.(*[][]*x509.Certificate)
}
func deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h CGoHandle) [][]*x509.Certificate {
	p := ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]*x509.Certificate", p))
}

// --- wrapping slice: [][]*x509.Certificate ---
//
//export Slice_Slice_Ptr_x509_Certificate_CTor
func Slice_Slice_Ptr_x509_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_Ptr_x509_Certificate(&[][]*x509.Certificate{}))
}

//export Slice_Slice_Ptr_x509_Certificate_len
func Slice_Slice_Ptr_x509_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle))
}

//export Slice_Slice_Ptr_x509_Certificate_elem
func Slice_Slice_Ptr_x509_Certificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	return handleFromPtr_Slice_Ptr_x509_Certificate(&(s[_idx]))
}

//export Slice_Slice_Ptr_x509_Certificate_subslice
func Slice_Slice_Ptr_x509_Certificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_Ptr_x509_Certificate(&ss))
}

//export Slice_Slice_Ptr_x509_Certificate_set
func Slice_Slice_Ptr_x509_Certificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	s[_idx] = deptrFromHandle_Slice_Ptr_x509_Certificate(_vl)
}

//export Slice_Slice_Ptr_x509_Certificate_append
func Slice_Slice_Ptr_x509_Certificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	*s = append(*s, deptrFromHandle_Slice_Ptr_x509_Certificate(_vl))
}

// Converters for implicit pointer handles for type: [][]byte
func ptrFromHandle_Slice_Slice_byte(h CGoHandle) *[][]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]byte")
	if p == nil {
		return nil
	}
	return p.(*[][]byte)
}
func deptrFromHandle_Slice_Slice_byte(h CGoHandle) [][]byte {
	p := ptrFromHandle_Slice_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]byte", p))
}

// --- wrapping slice: [][]byte ---
//
//export Slice_Slice_byte_CTor
func Slice_Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&[][]byte{}))
}

//export Slice_Slice_byte_len
func Slice_Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_byte(handle))
}

//export Slice_Slice_byte_elem
func Slice_Slice_byte_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	return handleFromPtr_Slice_byte(&(s[_idx]))
}

//export Slice_Slice_byte_subslice
func Slice_Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&ss))
}

//export Slice_Slice_byte_set
func Slice_Slice_byte_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	s[_idx] = deptrFromHandle_Slice_byte(_vl)
}

//export Slice_Slice_byte_append
func Slice_Slice_byte_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_byte(handle)
	*s = append(*s, deptrFromHandle_Slice_byte(_vl))
}

// Converters for implicit pointer handles for type: []x509.ExtKeyUsage
func ptrFromHandle_Slice_x509_ExtKeyUsage(h CGoHandle) *[]x509.ExtKeyUsage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]x509.ExtKeyUsage")
	if p == nil {
		return nil
	}
	return p.(*[]x509.ExtKeyUsage)
}
func deptrFromHandle_Slice_x509_ExtKeyUsage(h CGoHandle) []x509.ExtKeyUsage {
	p := ptrFromHandle_Slice_x509_ExtKeyUsage(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_x509_ExtKeyUsage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]x509.ExtKeyUsage", p))
}

// --- wrapping slice: []x509.ExtKeyUsage ---
//
//export Slice_x509_ExtKeyUsage_CTor
func Slice_x509_ExtKeyUsage_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_x509_ExtKeyUsage(&[]x509.ExtKeyUsage{}))
}

//export Slice_x509_ExtKeyUsage_len
func Slice_x509_ExtKeyUsage_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_x509_ExtKeyUsage(handle))
}

//export Slice_x509_ExtKeyUsage_elem
func Slice_x509_ExtKeyUsage_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	return C.longlong(int(s[_idx]))
}

//export Slice_x509_ExtKeyUsage_subslice
func Slice_x509_ExtKeyUsage_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_x509_ExtKeyUsage(&ss))
}

//export Slice_x509_ExtKeyUsage_set
func Slice_x509_ExtKeyUsage_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	s[_idx] = x509.ExtKeyUsage(int(_vl))
}

//export Slice_x509_ExtKeyUsage_append
func Slice_x509_ExtKeyUsage_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	*s = append(*s, x509.ExtKeyUsage(int(_vl)))
}

// Converters for implicit pointer handles for type: []x509.OID
func ptrFromHandle_Slice_x509_OID(h CGoHandle) *[]x509.OID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]x509.OID")
	if p == nil {
		return nil
	}
	return p.(*[]x509.OID)
}
func deptrFromHandle_Slice_x509_OID(h CGoHandle) []x509.OID {
	p := ptrFromHandle_Slice_x509_OID(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_x509_OID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]x509.OID", p))
}

// --- wrapping slice: []x509.OID ---
//
//export Slice_x509_OID_CTor
func Slice_x509_OID_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_x509_OID(&[]x509.OID{}))
}

//export Slice_x509_OID_len
func Slice_x509_OID_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_x509_OID(handle))
}

//export Slice_x509_OID_elem
func Slice_x509_OID_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_x509_OID(handle)
	return handleFromPtr_x509_OID(&(s[_idx]))
}

//export Slice_x509_OID_subslice
func Slice_x509_OID_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_x509_OID(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_x509_OID(&ss))
}

//export Slice_x509_OID_set
func Slice_x509_OID_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_x509_OID(handle)
	s[_idx] = *ptrFromHandle_x509_OID(_vl)
}

//export Slice_x509_OID_append
func Slice_x509_OID_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_x509_OID(handle)
	*s = append(*s, *ptrFromHandle_x509_OID(_vl))
}

// Converters for implicit pointer handles for type: []pkix.AttributeTypeAndValue
func ptrFromHandle_Slice_pkix_AttributeTypeAndValue(h CGoHandle) *[]pkix.AttributeTypeAndValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.AttributeTypeAndValue")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.AttributeTypeAndValue)
}
func deptrFromHandle_Slice_pkix_AttributeTypeAndValue(h CGoHandle) []pkix.AttributeTypeAndValue {
	p := ptrFromHandle_Slice_pkix_AttributeTypeAndValue(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_AttributeTypeAndValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.AttributeTypeAndValue", p))
}

// --- wrapping slice: []pkix.AttributeTypeAndValue ---
//
//export Slice_pkix_AttributeTypeAndValue_CTor
func Slice_pkix_AttributeTypeAndValue_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_AttributeTypeAndValue(&[]pkix.AttributeTypeAndValue{}))
}

//export Slice_pkix_AttributeTypeAndValue_len
func Slice_pkix_AttributeTypeAndValue_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle))
}

//export Slice_pkix_AttributeTypeAndValue_elem
func Slice_pkix_AttributeTypeAndValue_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	return handleFromPtr_pkix_AttributeTypeAndValue(&(s[_idx]))
}

//export Slice_pkix_AttributeTypeAndValue_subslice
func Slice_pkix_AttributeTypeAndValue_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_AttributeTypeAndValue(&ss))
}

//export Slice_pkix_AttributeTypeAndValue_set
func Slice_pkix_AttributeTypeAndValue_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	s[_idx] = *ptrFromHandle_pkix_AttributeTypeAndValue(_vl)
}

//export Slice_pkix_AttributeTypeAndValue_append
func Slice_pkix_AttributeTypeAndValue_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	*s = append(*s, *ptrFromHandle_pkix_AttributeTypeAndValue(_vl))
}

// Converters for implicit pointer handles for type: []pkix.Extension
func ptrFromHandle_Slice_pkix_Extension(h CGoHandle) *[]pkix.Extension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.Extension")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.Extension)
}
func deptrFromHandle_Slice_pkix_Extension(h CGoHandle) []pkix.Extension {
	p := ptrFromHandle_Slice_pkix_Extension(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_Extension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.Extension", p))
}

// --- wrapping slice: []pkix.Extension ---
//
//export Slice_pkix_Extension_CTor
func Slice_pkix_Extension_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_Extension(&[]pkix.Extension{}))
}

//export Slice_pkix_Extension_len
func Slice_pkix_Extension_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_Extension(handle))
}

//export Slice_pkix_Extension_elem
func Slice_pkix_Extension_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	return handleFromPtr_pkix_Extension(&(s[_idx]))
}

//export Slice_pkix_Extension_subslice
func Slice_pkix_Extension_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_Extension(&ss))
}

//export Slice_pkix_Extension_set
func Slice_pkix_Extension_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	s[_idx] = *ptrFromHandle_pkix_Extension(_vl)
}

//export Slice_pkix_Extension_append
func Slice_pkix_Extension_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_Extension(handle)
	*s = append(*s, *ptrFromHandle_pkix_Extension(_vl))
}

// Converters for implicit pointer handles for type: []pkix.RevokedCertificate
func ptrFromHandle_Slice_pkix_RevokedCertificate(h CGoHandle) *[]pkix.RevokedCertificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.RevokedCertificate")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.RevokedCertificate)
}
func deptrFromHandle_Slice_pkix_RevokedCertificate(h CGoHandle) []pkix.RevokedCertificate {
	p := ptrFromHandle_Slice_pkix_RevokedCertificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_RevokedCertificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.RevokedCertificate", p))
}

// --- wrapping slice: []pkix.RevokedCertificate ---
//
//export Slice_pkix_RevokedCertificate_CTor
func Slice_pkix_RevokedCertificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_RevokedCertificate(&[]pkix.RevokedCertificate{}))
}

//export Slice_pkix_RevokedCertificate_len
func Slice_pkix_RevokedCertificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_RevokedCertificate(handle))
}

//export Slice_pkix_RevokedCertificate_elem
func Slice_pkix_RevokedCertificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	return handleFromPtr_pkix_RevokedCertificate(&(s[_idx]))
}

//export Slice_pkix_RevokedCertificate_subslice
func Slice_pkix_RevokedCertificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_RevokedCertificate(&ss))
}

//export Slice_pkix_RevokedCertificate_set
func Slice_pkix_RevokedCertificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	s[_idx] = *ptrFromHandle_pkix_RevokedCertificate(_vl)
}

//export Slice_pkix_RevokedCertificate_append
func Slice_pkix_RevokedCertificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	*s = append(*s, *ptrFromHandle_pkix_RevokedCertificate(_vl))
}

// Converters for implicit pointer handles for type: []asn1.ObjectIdentifier
func ptrFromHandle_Slice_asn1_ObjectIdentifier(h CGoHandle) *[]asn1.ObjectIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]asn1.ObjectIdentifier")
	if p == nil {
		return nil
	}
	return p.(*[]asn1.ObjectIdentifier)
}
func deptrFromHandle_Slice_asn1_ObjectIdentifier(h CGoHandle) []asn1.ObjectIdentifier {
	p := ptrFromHandle_Slice_asn1_ObjectIdentifier(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_asn1_ObjectIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]asn1.ObjectIdentifier", p))
}

// --- wrapping slice: []asn1.ObjectIdentifier ---
//
//export Slice_asn1_ObjectIdentifier_CTor
func Slice_asn1_ObjectIdentifier_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_asn1_ObjectIdentifier(&[]asn1.ObjectIdentifier{}))
}

//export Slice_asn1_ObjectIdentifier_len
func Slice_asn1_ObjectIdentifier_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_asn1_ObjectIdentifier(handle))
}

//export Slice_asn1_ObjectIdentifier_elem
func Slice_asn1_ObjectIdentifier_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	return handleFromPtr_asn1_ObjectIdentifier(&(s[_idx]))
}

//export Slice_asn1_ObjectIdentifier_subslice
func Slice_asn1_ObjectIdentifier_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_asn1_ObjectIdentifier(&ss))
}

//export Slice_asn1_ObjectIdentifier_set
func Slice_asn1_ObjectIdentifier_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	s[_idx] = deptrFromHandle_asn1_ObjectIdentifier(_vl)
}

//export Slice_asn1_ObjectIdentifier_append
func Slice_asn1_ObjectIdentifier_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	*s = append(*s, deptrFromHandle_asn1_ObjectIdentifier(_vl))
}

// Converters for implicit pointer handles for type: []v1.ManagedFieldsEntry
func ptrFromHandle_Slice_v1_ManagedFieldsEntry(h CGoHandle) *[]v1.ManagedFieldsEntry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]v1.ManagedFieldsEntry")
	if p == nil {
		return nil
	}
	return p.(*[]v1.ManagedFieldsEntry)
}
func deptrFromHandle_Slice_v1_ManagedFieldsEntry(h CGoHandle) []v1.ManagedFieldsEntry {
	p := ptrFromHandle_Slice_v1_ManagedFieldsEntry(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_v1_ManagedFieldsEntry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]v1.ManagedFieldsEntry", p))
}

// --- wrapping slice: []v1.ManagedFieldsEntry ---
//
//export Slice_v1_ManagedFieldsEntry_CTor
func Slice_v1_ManagedFieldsEntry_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_v1_ManagedFieldsEntry(&[]v1.ManagedFieldsEntry{}))
}

//export Slice_v1_ManagedFieldsEntry_len
func Slice_v1_ManagedFieldsEntry_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_v1_ManagedFieldsEntry(handle))
}

//export Slice_v1_ManagedFieldsEntry_elem
func Slice_v1_ManagedFieldsEntry_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_v1_ManagedFieldsEntry(handle)
	return handleFromPtr_v1_ManagedFieldsEntry(&(s[_idx]))
}

//export Slice_v1_ManagedFieldsEntry_subslice
func Slice_v1_ManagedFieldsEntry_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_v1_ManagedFieldsEntry(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_v1_ManagedFieldsEntry(&ss))
}

//export Slice_v1_ManagedFieldsEntry_set
func Slice_v1_ManagedFieldsEntry_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_v1_ManagedFieldsEntry(handle)
	s[_idx] = *ptrFromHandle_v1_ManagedFieldsEntry(_vl)
}

//export Slice_v1_ManagedFieldsEntry_append
func Slice_v1_ManagedFieldsEntry_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_v1_ManagedFieldsEntry(handle)
	*s = append(*s, *ptrFromHandle_v1_ManagedFieldsEntry(_vl))
}

// Converters for implicit pointer handles for type: []v1.OwnerReference
func ptrFromHandle_Slice_v1_OwnerReference(h CGoHandle) *[]v1.OwnerReference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]v1.OwnerReference")
	if p == nil {
		return nil
	}
	return p.(*[]v1.OwnerReference)
}
func deptrFromHandle_Slice_v1_OwnerReference(h CGoHandle) []v1.OwnerReference {
	p := ptrFromHandle_Slice_v1_OwnerReference(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_v1_OwnerReference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]v1.OwnerReference", p))
}

// --- wrapping slice: []v1.OwnerReference ---
//
//export Slice_v1_OwnerReference_CTor
func Slice_v1_OwnerReference_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_v1_OwnerReference(&[]v1.OwnerReference{}))
}

//export Slice_v1_OwnerReference_len
func Slice_v1_OwnerReference_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_v1_OwnerReference(handle))
}

//export Slice_v1_OwnerReference_elem
func Slice_v1_OwnerReference_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_v1_OwnerReference(handle)
	return handleFromPtr_v1_OwnerReference(&(s[_idx]))
}

//export Slice_v1_OwnerReference_subslice
func Slice_v1_OwnerReference_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_v1_OwnerReference(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_v1_OwnerReference(&ss))
}

//export Slice_v1_OwnerReference_set
func Slice_v1_OwnerReference_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_v1_OwnerReference(handle)
	s[_idx] = *ptrFromHandle_v1_OwnerReference(_vl)
}

//export Slice_v1_OwnerReference_append
func Slice_v1_OwnerReference_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_v1_OwnerReference(handle)
	*s = append(*s, *ptrFromHandle_v1_OwnerReference(_vl))
}

// Converters for implicit pointer handles for type: []unstructured.Unstructured
func ptrFromHandle_Slice_unstructured_Unstructured(h CGoHandle) *[]unstructured.Unstructured {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]unstructured.Unstructured")
	if p == nil {
		return nil
	}
	return p.(*[]unstructured.Unstructured)
}
func deptrFromHandle_Slice_unstructured_Unstructured(h CGoHandle) []unstructured.Unstructured {
	p := ptrFromHandle_Slice_unstructured_Unstructured(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_unstructured_Unstructured(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]unstructured.Unstructured", p))
}

// --- wrapping slice: []unstructured.Unstructured ---
//
//export Slice_unstructured_Unstructured_CTor
func Slice_unstructured_Unstructured_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_unstructured_Unstructured(&[]unstructured.Unstructured{}))
}

//export Slice_unstructured_Unstructured_len
func Slice_unstructured_Unstructured_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_unstructured_Unstructured(handle))
}

//export Slice_unstructured_Unstructured_elem
func Slice_unstructured_Unstructured_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_unstructured_Unstructured(handle)
	return handleFromPtr_unstructured_Unstructured(&(s[_idx]))
}

//export Slice_unstructured_Unstructured_subslice
func Slice_unstructured_Unstructured_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_unstructured_Unstructured(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_unstructured_Unstructured(&ss))
}

//export Slice_unstructured_Unstructured_set
func Slice_unstructured_Unstructured_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_unstructured_Unstructured(handle)
	s[_idx] = *ptrFromHandle_unstructured_Unstructured(_vl)
}

//export Slice_unstructured_Unstructured_append
func Slice_unstructured_Unstructured_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_unstructured_Unstructured(handle)
	*s = append(*s, *ptrFromHandle_unstructured_Unstructured(_vl))
}

// Converters for implicit pointer handles for type: []api.ExecEnvVar
func ptrFromHandle_Slice_api_ExecEnvVar(h CGoHandle) *[]api.ExecEnvVar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]api.ExecEnvVar")
	if p == nil {
		return nil
	}
	return p.(*[]api.ExecEnvVar)
}
func deptrFromHandle_Slice_api_ExecEnvVar(h CGoHandle) []api.ExecEnvVar {
	p := ptrFromHandle_Slice_api_ExecEnvVar(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_api_ExecEnvVar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]api.ExecEnvVar", p))
}

// --- wrapping slice: []api.ExecEnvVar ---
//
//export Slice_api_ExecEnvVar_CTor
func Slice_api_ExecEnvVar_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_api_ExecEnvVar(&[]api.ExecEnvVar{}))
}

//export Slice_api_ExecEnvVar_len
func Slice_api_ExecEnvVar_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_api_ExecEnvVar(handle))
}

//export Slice_api_ExecEnvVar_elem
func Slice_api_ExecEnvVar_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_api_ExecEnvVar(handle)
	return handleFromPtr_api_ExecEnvVar(&(s[_idx]))
}

//export Slice_api_ExecEnvVar_subslice
func Slice_api_ExecEnvVar_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_api_ExecEnvVar(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_api_ExecEnvVar(&ss))
}

//export Slice_api_ExecEnvVar_set
func Slice_api_ExecEnvVar_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_api_ExecEnvVar(handle)
	s[_idx] = *ptrFromHandle_api_ExecEnvVar(_vl)
}

//export Slice_api_ExecEnvVar_append
func Slice_api_ExecEnvVar_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_api_ExecEnvVar(handle)
	*s = append(*s, *ptrFromHandle_api_ExecEnvVar(_vl))
}

// Converters for implicit pointer handles for type: []big.Word
func ptrFromHandle_Slice_big_Word(h CGoHandle) *[]big.Word {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]big.Word")
	if p == nil {
		return nil
	}
	return p.(*[]big.Word)
}
func deptrFromHandle_Slice_big_Word(h CGoHandle) []big.Word {
	p := ptrFromHandle_Slice_big_Word(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_big_Word(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]big.Word", p))
}

// --- wrapping slice: []big.Word ---
//
//export Slice_big_Word_CTor
func Slice_big_Word_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_big_Word(&[]big.Word{}))
}

//export Slice_big_Word_len
func Slice_big_Word_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_big_Word(handle))
}

//export Slice_big_Word_elem
func Slice_big_Word_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_big_Word(handle)
	return C.ulonglong(uint(s[_idx]))
}

//export Slice_big_Word_subslice
func Slice_big_Word_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_big_Word(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_big_Word(&ss))
}

//export Slice_big_Word_set
func Slice_big_Word_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_big_Word(handle)
	s[_idx] = big.Word(uint(_vl))
}

//export Slice_big_Word_append
func Slice_big_Word_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_big_Word(handle)
	*s = append(*s, big.Word(uint(_vl)))
}

// Converters for implicit pointer handles for type: []net.IP
func ptrFromHandle_Slice_net_IP(h CGoHandle) *[]net.IP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]net.IP")
	if p == nil {
		return nil
	}
	return p.(*[]net.IP)
}
func deptrFromHandle_Slice_net_IP(h CGoHandle) []net.IP {
	p := ptrFromHandle_Slice_net_IP(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_net_IP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]net.IP", p))
}

// --- wrapping slice: []net.IP ---
//
//export Slice_net_IP_CTor
func Slice_net_IP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_net_IP(&[]net.IP{}))
}

//export Slice_net_IP_len
func Slice_net_IP_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_net_IP(handle))
}

//export Slice_net_IP_elem
func Slice_net_IP_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_net_IP(handle)
	return handleFromPtr_net_IP(&(s[_idx]))
}

//export Slice_net_IP_subslice
func Slice_net_IP_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_net_IP(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_net_IP(&ss))
}

//export Slice_net_IP_set
func Slice_net_IP_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_net_IP(handle)
	s[_idx] = deptrFromHandle_net_IP(_vl)
}

//export Slice_net_IP_append
func Slice_net_IP_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_net_IP(handle)
	*s = append(*s, deptrFromHandle_net_IP(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for non-pointer handles for type: dynamic.DynamicClient
func ptrFromHandle_dynamic_DynamicClient(h CGoHandle) *dynamic.DynamicClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "dynamic.DynamicClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(dynamic.DynamicClient{})).(*dynamic.DynamicClient)
}
func handleFromPtr_dynamic_DynamicClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("dynamic.DynamicClient", p))
}

// Converters for pointer handles for type: dynamic.Interface
func ptrFromHandle_dynamic_Interface(h CGoHandle) dynamic.Interface {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "dynamic.Interface")
	if p == nil {
		return nil
	}
	return p.(dynamic.Interface)
}
func handleFromPtr_dynamic_Interface(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("dynamic.Interface", p))
}

// Converters for pointer handles for type: dynamic.NamespaceableResourceInterface
func ptrFromHandle_dynamic_NamespaceableResourceInterface(h CGoHandle) dynamic.NamespaceableResourceInterface {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "dynamic.NamespaceableResourceInterface")
	if p == nil {
		return nil
	}
	return p.(dynamic.NamespaceableResourceInterface)
}
func handleFromPtr_dynamic_NamespaceableResourceInterface(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("dynamic.NamespaceableResourceInterface", p))
}

// Converters for pointer handles for type: dynamic.ResourceInterface
func ptrFromHandle_dynamic_ResourceInterface(h CGoHandle) dynamic.ResourceInterface {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "dynamic.ResourceInterface")
	if p == nil {
		return nil
	}
	return p.(dynamic.ResourceInterface)
}
func handleFromPtr_dynamic_ResourceInterface(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("dynamic.ResourceInterface", p))
}

// Converters for implicit pointer handles for type: map[string][]*multipart.FileHeader
func ptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h CGoHandle) *map[string][]*multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return p.(*map[string][]*multipart.FileHeader)
}
func deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h CGoHandle) map[string][]*multipart.FileHeader {
	p := ptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]*multipart.FileHeader", p))
}

// --- wrapping map: map[string][]*multipart.FileHeader ---
//
//export Map_string_Slice_Ptr_multipart_FileHeader_CTor
func Map_string_Slice_Ptr_multipart_FileHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_Ptr_multipart_FileHeader(&map[string][]*multipart.FileHeader{}))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_len
func Map_string_Slice_Ptr_multipart_FileHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_elem
func Map_string_Slice_Ptr_multipart_FileHeader_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_Ptr_multipart_FileHeader(&v)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_contains
func Map_string_Slice_Ptr_multipart_FileHeader_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_set
func Map_string_Slice_Ptr_multipart_FileHeader_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_Ptr_multipart_FileHeader(_vl)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_delete
func Map_string_Slice_Ptr_multipart_FileHeader_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_keys
func Map_string_Slice_Ptr_multipart_FileHeader_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string][]string
func ptrFromHandle_Map_string_Slice_string(h CGoHandle) *map[string][]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]string")
	if p == nil {
		return nil
	}
	return p.(*map[string][]string)
}
func deptrFromHandle_Map_string_Slice_string(h CGoHandle) map[string][]string {
	p := ptrFromHandle_Map_string_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]string", p))
}

// --- wrapping map: map[string][]string ---
//
//export Map_string_Slice_string_CTor
func Map_string_Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_string(&map[string][]string{}))
}

//export Map_string_Slice_string_len
func Map_string_Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_string(handle))
}

//export Map_string_Slice_string_elem
func Map_string_Slice_string_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export Map_string_Slice_string_contains
func Map_string_Slice_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_string_set
func Map_string_Slice_string_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export Map_string_Slice_string_delete
func Map_string_Slice_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_string_keys
func Map_string_Slice_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]bool
func ptrFromHandle_Map_string_bool(h CGoHandle) *map[string]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]bool")
	if p == nil {
		return nil
	}
	return p.(*map[string]bool)
}
func deptrFromHandle_Map_string_bool(h CGoHandle) map[string]bool {
	p := ptrFromHandle_Map_string_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]bool", p))
}

// --- wrapping map: map[string]bool ---
//
//export Map_string_bool_CTor
func Map_string_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_bool(&map[string]bool{}))
}

//export Map_string_bool_len
func Map_string_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_bool(handle))
}

//export Map_string_bool_elem
func Map_string_bool_elem(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_bool(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return boolGoToPy(v)
}

//export Map_string_bool_contains
func Map_string_bool_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_bool(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_bool_set
func Map_string_bool_set(handle CGoHandle, _ky *C.char, _vl C.char) {
	s := deptrFromHandle_Map_string_bool(handle)
	s[C.GoString(_ky)] = boolPyToGo(_vl)
}

//export Map_string_bool_delete
func Map_string_bool_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_bool(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_bool_keys
func Map_string_bool_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_bool(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]interface{}
func ptrFromHandle_Map_string_interface_(h CGoHandle) *map[string]interface{} {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]interface{}")
	if p == nil {
		return nil
	}
	return p.(*map[string]interface{})
}
func deptrFromHandle_Map_string_interface_(h CGoHandle) map[string]interface{} {
	p := ptrFromHandle_Map_string_interface_(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_interface_(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]interface{}", p))
}

// --- wrapping map: map[string]interface{} ---
//
//export Map_string_interface__CTor
func Map_string_interface__CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_interface_(&map[string]interface{}{}))
}

//export Map_string_interface__len
func Map_string_interface__len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_interface_(handle))
}

//export Map_string_interface__elem
func Map_string_interface__elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_Map_string_interface_(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(fmt.Sprintf("%s", (v)))
}

//export Map_string_interface__contains
func Map_string_interface__contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_interface_(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_interface__set
func Map_string_interface__set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_Map_string_interface_(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export Map_string_interface__delete
func Map_string_interface__delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_interface_(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_interface__keys
func Map_string_interface__keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_interface_(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]string
func ptrFromHandle_Map_string_string(h CGoHandle) *map[string]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]string")
	if p == nil {
		return nil
	}
	return p.(*map[string]string)
}
func deptrFromHandle_Map_string_string(h CGoHandle) map[string]string {
	p := ptrFromHandle_Map_string_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]string", p))
}

// --- wrapping map: map[string]string ---
//
//export Map_string_string_CTor
func Map_string_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_string(&map[string]string{}))
}

//export Map_string_string_len
func Map_string_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_string(handle))
}

//export Map_string_string_elem
func Map_string_string_elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_Map_string_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(v)
}

//export Map_string_string_contains
func Map_string_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_string_set
func Map_string_string_set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export Map_string_string_delete
func Map_string_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_string_keys
func Map_string_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export dynamic_Interface_Resource
func dynamic_Interface_Resource(_handle CGoHandle, resource CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.Interface")
	if __err != nil {
		return handleFromPtr_dynamic_NamespaceableResourceInterface(nil)
	}
	return handleFromPtr_dynamic_NamespaceableResourceInterface(vifc.(dynamic.Interface).Resource(*ptrFromHandle_schema_GroupVersionResource(resource)))

}

//export dynamic_NamespaceableResourceInterface_Apply
func dynamic_NamespaceableResourceInterface_Apply(_handle CGoHandle, ctx CGoHandle, name *C.char, obj CGoHandle, options CGoHandle, subresources CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.NamespaceableResourceInterface).Apply(ptrFromHandle_context_Context(ctx), C.GoString(name), ptrFromHandle_Ptr_unstructured_Unstructured(obj), *ptrFromHandle_v1_ApplyOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_NamespaceableResourceInterface_ApplyStatus
func dynamic_NamespaceableResourceInterface_ApplyStatus(_handle CGoHandle, ctx CGoHandle, name *C.char, obj CGoHandle, options CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.NamespaceableResourceInterface).ApplyStatus(ptrFromHandle_context_Context(ctx), C.GoString(name), ptrFromHandle_Ptr_unstructured_Unstructured(obj), *ptrFromHandle_v1_ApplyOptions(options))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_NamespaceableResourceInterface_Create
func dynamic_NamespaceableResourceInterface_Create(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, options CGoHandle, subresources CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.NamespaceableResourceInterface).Create(ptrFromHandle_context_Context(ctx), ptrFromHandle_Ptr_unstructured_Unstructured(obj), *ptrFromHandle_v1_CreateOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_NamespaceableResourceInterface_Delete
func dynamic_NamespaceableResourceInterface_Delete(_handle CGoHandle, ctx CGoHandle, name *C.char, options CGoHandle, subresources CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(dynamic.NamespaceableResourceInterface).Delete(ptrFromHandle_context_Context(ctx), C.GoString(name), *ptrFromHandle_v1_DeleteOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export dynamic_NamespaceableResourceInterface_DeleteCollection
func dynamic_NamespaceableResourceInterface_DeleteCollection(_handle CGoHandle, ctx CGoHandle, options CGoHandle, listOptions CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(dynamic.NamespaceableResourceInterface).DeleteCollection(ptrFromHandle_context_Context(ctx), *ptrFromHandle_v1_DeleteOptions(options), *ptrFromHandle_v1_ListOptions(listOptions))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export dynamic_NamespaceableResourceInterface_Get
func dynamic_NamespaceableResourceInterface_Get(_handle CGoHandle, ctx CGoHandle, name *C.char, options CGoHandle, subresources CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.NamespaceableResourceInterface).Get(ptrFromHandle_context_Context(ctx), C.GoString(name), *ptrFromHandle_v1_GetOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_NamespaceableResourceInterface_List
func dynamic_NamespaceableResourceInterface_List(_handle CGoHandle, ctx CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_UnstructuredList(nil)
	}
	cret, __err := vifc.(dynamic.NamespaceableResourceInterface).List(ptrFromHandle_context_Context(ctx), *ptrFromHandle_v1_ListOptions(opts))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_UnstructuredList(nil)
	}
	return handleFromPtr_Ptr_unstructured_UnstructuredList(cret)
}

//export dynamic_NamespaceableResourceInterface_Namespace
func dynamic_NamespaceableResourceInterface_Namespace(_handle CGoHandle, arg_0 *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return handleFromPtr_dynamic_ResourceInterface(nil)
	}
	return handleFromPtr_dynamic_ResourceInterface(vifc.(dynamic.NamespaceableResourceInterface).Namespace(C.GoString(arg_0)))

}

//export dynamic_NamespaceableResourceInterface_Patch
func dynamic_NamespaceableResourceInterface_Patch(_handle CGoHandle, ctx CGoHandle, name *C.char, pt *C.char, data CGoHandle, options CGoHandle, subresources CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.NamespaceableResourceInterface).Patch(ptrFromHandle_context_Context(ctx), C.GoString(name), types.PatchType(C.GoString(pt)), deptrFromHandle_Slice_byte(data), *ptrFromHandle_v1_PatchOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_NamespaceableResourceInterface_Update
func dynamic_NamespaceableResourceInterface_Update(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, options CGoHandle, subresources CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.NamespaceableResourceInterface).Update(ptrFromHandle_context_Context(ctx), ptrFromHandle_Ptr_unstructured_Unstructured(obj), *ptrFromHandle_v1_UpdateOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_NamespaceableResourceInterface_UpdateStatus
func dynamic_NamespaceableResourceInterface_UpdateStatus(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, options CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.NamespaceableResourceInterface).UpdateStatus(ptrFromHandle_context_Context(ctx), ptrFromHandle_Ptr_unstructured_Unstructured(obj), *ptrFromHandle_v1_UpdateOptions(options))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_NamespaceableResourceInterface_Watch
func dynamic_NamespaceableResourceInterface_Watch(_handle CGoHandle, ctx CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.NamespaceableResourceInterface")
	if __err != nil {
		return handleFromPtr_watch_Interface(nil)
	}
	cret, __err := vifc.(dynamic.NamespaceableResourceInterface).Watch(ptrFromHandle_context_Context(ctx), *ptrFromHandle_v1_ListOptions(opts))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_watch_Interface(nil)
	}
	return handleFromPtr_watch_Interface(cret)
}

//export dynamic_ResourceInterface_Apply
func dynamic_ResourceInterface_Apply(_handle CGoHandle, ctx CGoHandle, name *C.char, obj CGoHandle, options CGoHandle, subresources CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.ResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.ResourceInterface).Apply(ptrFromHandle_context_Context(ctx), C.GoString(name), ptrFromHandle_Ptr_unstructured_Unstructured(obj), *ptrFromHandle_v1_ApplyOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_ResourceInterface_ApplyStatus
func dynamic_ResourceInterface_ApplyStatus(_handle CGoHandle, ctx CGoHandle, name *C.char, obj CGoHandle, options CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.ResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.ResourceInterface).ApplyStatus(ptrFromHandle_context_Context(ctx), C.GoString(name), ptrFromHandle_Ptr_unstructured_Unstructured(obj), *ptrFromHandle_v1_ApplyOptions(options))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_ResourceInterface_Create
func dynamic_ResourceInterface_Create(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, options CGoHandle, subresources CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.ResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.ResourceInterface).Create(ptrFromHandle_context_Context(ctx), ptrFromHandle_Ptr_unstructured_Unstructured(obj), *ptrFromHandle_v1_CreateOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_ResourceInterface_Delete
func dynamic_ResourceInterface_Delete(_handle CGoHandle, ctx CGoHandle, name *C.char, options CGoHandle, subresources CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.ResourceInterface")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(dynamic.ResourceInterface).Delete(ptrFromHandle_context_Context(ctx), C.GoString(name), *ptrFromHandle_v1_DeleteOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export dynamic_ResourceInterface_DeleteCollection
func dynamic_ResourceInterface_DeleteCollection(_handle CGoHandle, ctx CGoHandle, options CGoHandle, listOptions CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.ResourceInterface")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(dynamic.ResourceInterface).DeleteCollection(ptrFromHandle_context_Context(ctx), *ptrFromHandle_v1_DeleteOptions(options), *ptrFromHandle_v1_ListOptions(listOptions))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export dynamic_ResourceInterface_Get
func dynamic_ResourceInterface_Get(_handle CGoHandle, ctx CGoHandle, name *C.char, options CGoHandle, subresources CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.ResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.ResourceInterface).Get(ptrFromHandle_context_Context(ctx), C.GoString(name), *ptrFromHandle_v1_GetOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_ResourceInterface_List
func dynamic_ResourceInterface_List(_handle CGoHandle, ctx CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.ResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_UnstructuredList(nil)
	}
	cret, __err := vifc.(dynamic.ResourceInterface).List(ptrFromHandle_context_Context(ctx), *ptrFromHandle_v1_ListOptions(opts))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_UnstructuredList(nil)
	}
	return handleFromPtr_Ptr_unstructured_UnstructuredList(cret)
}

//export dynamic_ResourceInterface_Patch
func dynamic_ResourceInterface_Patch(_handle CGoHandle, ctx CGoHandle, name *C.char, pt *C.char, data CGoHandle, options CGoHandle, subresources CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.ResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.ResourceInterface).Patch(ptrFromHandle_context_Context(ctx), C.GoString(name), types.PatchType(C.GoString(pt)), deptrFromHandle_Slice_byte(data), *ptrFromHandle_v1_PatchOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_ResourceInterface_Update
func dynamic_ResourceInterface_Update(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, options CGoHandle, subresources CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.ResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.ResourceInterface).Update(ptrFromHandle_context_Context(ctx), ptrFromHandle_Ptr_unstructured_Unstructured(obj), *ptrFromHandle_v1_UpdateOptions(options), deptrFromHandle_Slice_string(subresources)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_ResourceInterface_UpdateStatus
func dynamic_ResourceInterface_UpdateStatus(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, options CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.ResourceInterface")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamic.ResourceInterface).UpdateStatus(ptrFromHandle_context_Context(ctx), ptrFromHandle_Ptr_unstructured_Unstructured(obj), *ptrFromHandle_v1_UpdateOptions(options))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamic_ResourceInterface_Watch
func dynamic_ResourceInterface_Watch(_handle CGoHandle, ctx CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamic.ResourceInterface")
	if __err != nil {
		return handleFromPtr_watch_Interface(nil)
	}
	cret, __err := vifc.(dynamic.ResourceInterface).Watch(ptrFromHandle_context_Context(ctx), *ptrFromHandle_v1_ListOptions(opts))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_watch_Interface(nil)
	}
	return handleFromPtr_watch_Interface(cret)
}

// ---- Structs ---

// --- wrapping struct: dynamic.DynamicClient ---
//
//export dynamic_DynamicClient_CTor
func dynamic_DynamicClient_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_dynamic_DynamicClient(&dynamic.DynamicClient{}))
}

//export dynamic_DynamicClient_Resource
func dynamic_DynamicClient_Resource(_handle CGoHandle, resource CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*dynamic.DynamicClient")
	if __err != nil {
		return handleFromPtr_dynamic_NamespaceableResourceInterface(nil)
	}
	return handleFromPtr_dynamic_NamespaceableResourceInterface(gopyh.Embed(vifc, reflect.TypeOf(dynamic.DynamicClient{})).(*dynamic.DynamicClient).Resource(*ptrFromHandle_schema_GroupVersionResource(resource)))

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export dynamic_New
func dynamic_New(c CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_dynamic_DynamicClient(dynamic.New(ptrFromHandle_rest_Interface(c)))

}

//export dynamic_NewForConfig
func dynamic_NewForConfig(inConfig CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := dynamic.NewForConfig(ptrFromHandle_Ptr_rest_Config(inConfig))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_dynamic_DynamicClient(nil)
	}
	return handleFromPtr_Ptr_dynamic_DynamicClient(cret)
}

//export dynamic_NewForConfigAndClient
func dynamic_NewForConfigAndClient(inConfig CGoHandle, h CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := dynamic.NewForConfigAndClient(ptrFromHandle_Ptr_rest_Config(inConfig), ptrFromHandle_Ptr_http_Client(h))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_dynamic_DynamicClient(nil)
	}
	return handleFromPtr_Ptr_dynamic_DynamicClient(cret)
}

//export dynamic_NewForConfigOrDie
func dynamic_NewForConfigOrDie(c CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_dynamic_DynamicClient(dynamic.NewForConfigOrDie(ptrFromHandle_Ptr_rest_Config(c)))

}

// ---- Functions ---

//export dynamic_ConfigFor
func dynamic_ConfigFor(inConfig CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_rest_Config(dynamic.ConfigFor(ptrFromHandle_Ptr_rest_Config(inConfig)))

}

//export dynamic_LegacyAPIPathResolverFunc
func dynamic_LegacyAPIPathResolverFunc(kind CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(dynamic.LegacyAPIPathResolverFunc(*ptrFromHandle_schema_GroupVersionKind(kind)))

}

// ---- Package: dynamicinformer ---

// ---- Types ---

// Converters for pointer handles for type: dynamicinformer.DynamicSharedInformerFactory
func ptrFromHandle_dynamicinformer_DynamicSharedInformerFactory(h CGoHandle) dynamicinformer.DynamicSharedInformerFactory {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "dynamicinformer.DynamicSharedInformerFactory")
	if p == nil {
		return nil
	}
	return p.(dynamicinformer.DynamicSharedInformerFactory)
}
func handleFromPtr_dynamicinformer_DynamicSharedInformerFactory(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("dynamicinformer.DynamicSharedInformerFactory", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export dynamicinformer_DynamicSharedInformerFactory_ForResource
func dynamicinformer_DynamicSharedInformerFactory_ForResource(_handle CGoHandle, gvr CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamicinformer.DynamicSharedInformerFactory")
	if __err != nil {
		return handleFromPtr_informers_GenericInformer(nil)
	}
	return handleFromPtr_informers_GenericInformer(vifc.(dynamicinformer.DynamicSharedInformerFactory).ForResource(*ptrFromHandle_schema_GroupVersionResource(gvr)))

}

//export dynamicinformer_DynamicSharedInformerFactory_Shutdown
func dynamicinformer_DynamicSharedInformerFactory_Shutdown(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamicinformer.DynamicSharedInformerFactory")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(dynamicinformer.DynamicSharedInformerFactory).Shutdown()
	} else {
		vifc.(dynamicinformer.DynamicSharedInformerFactory).Shutdown()
	}
}

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export dynamicinformer_NewDynamicSharedInformerFactory
func dynamicinformer_NewDynamicSharedInformerFactory(client CGoHandle, defaultResync C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_dynamicinformer_DynamicSharedInformerFactory(dynamicinformer.NewDynamicSharedInformerFactory(ptrFromHandle_dynamic_Interface(client), time.Duration(int64(defaultResync))))

}

//export dynamicinformer_NewFilteredDynamicSharedInformerFactory
func dynamicinformer_NewFilteredDynamicSharedInformerFactory(client CGoHandle, defaultResync C.longlong, namespace *C.char, tweakListOptions *C.PyObject) CGoHandle {
	_fun_arg := tweakListOptions
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_dynamicinformer_DynamicSharedInformerFactory(dynamicinformer.NewFilteredDynamicSharedInformerFactory(ptrFromHandle_dynamic_Interface(client), time.Duration(int64(defaultResync)), C.GoString(namespace), func(arg_0 *v1.ListOptions) {
		if C.PyCallable_Check(_fun_arg) == 0 {
			return
		}
		_gstate := C.PyGILState_Ensure()
		_fcargs := C.PyTuple_New(1)
		C.PyTuple_SetItem(_fcargs, 0, C.gopy_build_int64(C.int64_t(handleFromPtr_Ptr_v1_ListOptions(arg_0))))
		C.PyObject_CallObject(_fun_arg, _fcargs)
		C.gopy_decref(_fcargs)
		C.gopy_err_handle()
		C.PyGILState_Release(_gstate)
	}))

}

// ---- Package: dynamiclister ---

// ---- Types ---

// Converters for implicit pointer handles for type: []*unstructured.Unstructured
func ptrFromHandle_Slice_Ptr_unstructured_Unstructured(h CGoHandle) *[]*unstructured.Unstructured {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*unstructured.Unstructured")
	if p == nil {
		return nil
	}
	return p.(*[]*unstructured.Unstructured)
}
func deptrFromHandle_Slice_Ptr_unstructured_Unstructured(h CGoHandle) []*unstructured.Unstructured {
	p := ptrFromHandle_Slice_Ptr_unstructured_Unstructured(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_unstructured_Unstructured(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*unstructured.Unstructured", p))
}

// --- wrapping slice: []*unstructured.Unstructured ---
//
//export Slice_Ptr_unstructured_Unstructured_CTor
func Slice_Ptr_unstructured_Unstructured_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_unstructured_Unstructured(&[]*unstructured.Unstructured{}))
}

//export Slice_Ptr_unstructured_Unstructured_len
func Slice_Ptr_unstructured_Unstructured_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_unstructured_Unstructured(handle))
}

//export Slice_Ptr_unstructured_Unstructured_elem
func Slice_Ptr_unstructured_Unstructured_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_unstructured_Unstructured(handle)
	return handleFromPtr_Ptr_unstructured_Unstructured(&(s[_idx]))
}

//export Slice_Ptr_unstructured_Unstructured_subslice
func Slice_Ptr_unstructured_Unstructured_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_unstructured_Unstructured(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_unstructured_Unstructured(&ss))
}

//export Slice_Ptr_unstructured_Unstructured_set
func Slice_Ptr_unstructured_Unstructured_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_unstructured_Unstructured(handle)
	s[_idx] = ptrFromHandle_Ptr_unstructured_Unstructured(_vl)
}

//export Slice_Ptr_unstructured_Unstructured_append
func Slice_Ptr_unstructured_Unstructured_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_unstructured_Unstructured(handle)
	*s = append(*s, ptrFromHandle_Ptr_unstructured_Unstructured(_vl))
}

// Converters for pointer handles for type: dynamiclister.Lister
func ptrFromHandle_dynamiclister_Lister(h CGoHandle) dynamiclister.Lister {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "dynamiclister.Lister")
	if p == nil {
		return nil
	}
	return p.(dynamiclister.Lister)
}
func handleFromPtr_dynamiclister_Lister(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("dynamiclister.Lister", p))
}

// Converters for pointer handles for type: dynamiclister.NamespaceLister
func ptrFromHandle_dynamiclister_NamespaceLister(h CGoHandle) dynamiclister.NamespaceLister {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "dynamiclister.NamespaceLister")
	if p == nil {
		return nil
	}
	return p.(dynamiclister.NamespaceLister)
}
func handleFromPtr_dynamiclister_NamespaceLister(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("dynamiclister.NamespaceLister", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export dynamiclister_NamespaceLister_Get
func dynamiclister_NamespaceLister_Get(_handle CGoHandle, name *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamiclister.NamespaceLister")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamiclister.NamespaceLister).Get(C.GoString(name))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamiclister_NamespaceLister_List
func dynamiclister_NamespaceLister_List(_handle CGoHandle, selector CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamiclister.NamespaceLister")
	if __err != nil {
		return handleFromPtr_Slice_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamiclister.NamespaceLister).List(ptrFromHandle_labels_Selector(selector))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Slice_Ptr_unstructured_Unstructured(&cret)
}

//export dynamiclister_Lister_Get
func dynamiclister_Lister_Get(_handle CGoHandle, name *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamiclister.Lister")
	if __err != nil {
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamiclister.Lister).Get(C.GoString(name))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Ptr_unstructured_Unstructured(cret)
}

//export dynamiclister_Lister_List
func dynamiclister_Lister_List(_handle CGoHandle, selector CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamiclister.Lister")
	if __err != nil {
		return handleFromPtr_Slice_Ptr_unstructured_Unstructured(nil)
	}
	cret, __err := vifc.(dynamiclister.Lister).List(ptrFromHandle_labels_Selector(selector))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Ptr_unstructured_Unstructured(nil)
	}
	return handleFromPtr_Slice_Ptr_unstructured_Unstructured(&cret)
}

//export dynamiclister_Lister_Namespace
func dynamiclister_Lister_Namespace(_handle CGoHandle, namespace *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "dynamiclister.Lister")
	if __err != nil {
		return handleFromPtr_dynamiclister_NamespaceLister(nil)
	}
	return handleFromPtr_dynamiclister_NamespaceLister(vifc.(dynamiclister.Lister).Namespace(C.GoString(namespace)))

}

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export dynamiclister_New
func dynamiclister_New(indexer CGoHandle, gvr CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_dynamiclister_Lister(dynamiclister.New(ptrFromHandle_cache_Indexer(indexer), *ptrFromHandle_schema_GroupVersionResource(gvr)))

}

//export dynamiclister_NewRuntimeObjectShim
func dynamiclister_NewRuntimeObjectShim(lister CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_cache_GenericLister(dynamiclister.NewRuntimeObjectShim(ptrFromHandle_dynamiclister_Lister(lister)))

}

// ---- Package: fake ---

// ---- Types ---

// Converters for pointer handles for type: *fake.FakeDynamicClient
func ptrFromHandle_Ptr_fake_FakeDynamicClient(h CGoHandle) *fake.FakeDynamicClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*fake.FakeDynamicClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fake.FakeDynamicClient{})).(*fake.FakeDynamicClient)
}
func handleFromPtr_Ptr_fake_FakeDynamicClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*fake.FakeDynamicClient", p))
}

// Converters for implicit pointer handles for type: []runtime.Object
func ptrFromHandle_Slice_runtime_Object(h CGoHandle) *[]runtime.Object {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]runtime.Object")
	if p == nil {
		return nil
	}
	return p.(*[]runtime.Object)
}
func deptrFromHandle_Slice_runtime_Object(h CGoHandle) []runtime.Object {
	p := ptrFromHandle_Slice_runtime_Object(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_runtime_Object(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]runtime.Object", p))
}

// --- wrapping slice: []runtime.Object ---
//
//export Slice_runtime_Object_CTor
func Slice_runtime_Object_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_runtime_Object(&[]runtime.Object{}))
}

//export Slice_runtime_Object_len
func Slice_runtime_Object_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_runtime_Object(handle))
}

//export Slice_runtime_Object_elem
func Slice_runtime_Object_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_runtime_Object(handle)
	return handleFromPtr_runtime_Object(&(s[_idx]))
}

//export Slice_runtime_Object_subslice
func Slice_runtime_Object_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_runtime_Object(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_runtime_Object(&ss))
}

//export Slice_runtime_Object_set
func Slice_runtime_Object_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_runtime_Object(handle)
	s[_idx] = ptrFromHandle_runtime_Object(_vl)
}

//export Slice_runtime_Object_append
func Slice_runtime_Object_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_runtime_Object(handle)
	*s = append(*s, ptrFromHandle_runtime_Object(_vl))
}

// Converters for implicit pointer handles for type: []schema.GroupVersion
func ptrFromHandle_Slice_schema_GroupVersion(h CGoHandle) *[]schema.GroupVersion {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]schema.GroupVersion")
	if p == nil {
		return nil
	}
	return p.(*[]schema.GroupVersion)
}
func deptrFromHandle_Slice_schema_GroupVersion(h CGoHandle) []schema.GroupVersion {
	p := ptrFromHandle_Slice_schema_GroupVersion(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_schema_GroupVersion(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]schema.GroupVersion", p))
}

// --- wrapping slice: []schema.GroupVersion ---
//
//export Slice_schema_GroupVersion_CTor
func Slice_schema_GroupVersion_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersion(&[]schema.GroupVersion{}))
}

//export Slice_schema_GroupVersion_len
func Slice_schema_GroupVersion_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_schema_GroupVersion(handle))
}

//export Slice_schema_GroupVersion_elem
func Slice_schema_GroupVersion_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersion(handle)
	return handleFromPtr_schema_GroupVersion(&(s[_idx]))
}

//export Slice_schema_GroupVersion_subslice
func Slice_schema_GroupVersion_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersion(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersion(&ss))
}

//export Slice_schema_GroupVersion_set
func Slice_schema_GroupVersion_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_schema_GroupVersion(handle)
	s[_idx] = *ptrFromHandle_schema_GroupVersion(_vl)
}

//export Slice_schema_GroupVersion_append
func Slice_schema_GroupVersion_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_schema_GroupVersion(handle)
	*s = append(*s, *ptrFromHandle_schema_GroupVersion(_vl))
}

// Converters for implicit pointer handles for type: []schema.GroupVersionKind
func ptrFromHandle_Slice_schema_GroupVersionKind(h CGoHandle) *[]schema.GroupVersionKind {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]schema.GroupVersionKind")
	if p == nil {
		return nil
	}
	return p.(*[]schema.GroupVersionKind)
}
func deptrFromHandle_Slice_schema_GroupVersionKind(h CGoHandle) []schema.GroupVersionKind {
	p := ptrFromHandle_Slice_schema_GroupVersionKind(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_schema_GroupVersionKind(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]schema.GroupVersionKind", p))
}

// --- wrapping slice: []schema.GroupVersionKind ---
//
//export Slice_schema_GroupVersionKind_CTor
func Slice_schema_GroupVersionKind_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersionKind(&[]schema.GroupVersionKind{}))
}

//export Slice_schema_GroupVersionKind_len
func Slice_schema_GroupVersionKind_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_schema_GroupVersionKind(handle))
}

//export Slice_schema_GroupVersionKind_elem
func Slice_schema_GroupVersionKind_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersionKind(handle)
	return handleFromPtr_schema_GroupVersionKind(&(s[_idx]))
}

//export Slice_schema_GroupVersionKind_subslice
func Slice_schema_GroupVersionKind_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersionKind(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersionKind(&ss))
}

//export Slice_schema_GroupVersionKind_set
func Slice_schema_GroupVersionKind_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_schema_GroupVersionKind(handle)
	s[_idx] = *ptrFromHandle_schema_GroupVersionKind(_vl)
}

//export Slice_schema_GroupVersionKind_append
func Slice_schema_GroupVersionKind_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_schema_GroupVersionKind(handle)
	*s = append(*s, *ptrFromHandle_schema_GroupVersionKind(_vl))
}

// Converters for implicit pointer handles for type: []schema.GroupVersionResource
func ptrFromHandle_Slice_schema_GroupVersionResource(h CGoHandle) *[]schema.GroupVersionResource {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]schema.GroupVersionResource")
	if p == nil {
		return nil
	}
	return p.(*[]schema.GroupVersionResource)
}
func deptrFromHandle_Slice_schema_GroupVersionResource(h CGoHandle) []schema.GroupVersionResource {
	p := ptrFromHandle_Slice_schema_GroupVersionResource(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_schema_GroupVersionResource(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]schema.GroupVersionResource", p))
}

// --- wrapping slice: []schema.GroupVersionResource ---
//
//export Slice_schema_GroupVersionResource_CTor
func Slice_schema_GroupVersionResource_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersionResource(&[]schema.GroupVersionResource{}))
}

//export Slice_schema_GroupVersionResource_len
func Slice_schema_GroupVersionResource_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_schema_GroupVersionResource(handle))
}

//export Slice_schema_GroupVersionResource_elem
func Slice_schema_GroupVersionResource_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersionResource(handle)
	return handleFromPtr_schema_GroupVersionResource(&(s[_idx]))
}

//export Slice_schema_GroupVersionResource_subslice
func Slice_schema_GroupVersionResource_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersionResource(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersionResource(&ss))
}

//export Slice_schema_GroupVersionResource_set
func Slice_schema_GroupVersionResource_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_schema_GroupVersionResource(handle)
	s[_idx] = *ptrFromHandle_schema_GroupVersionResource(_vl)
}

//export Slice_schema_GroupVersionResource_append
func Slice_schema_GroupVersionResource_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_schema_GroupVersionResource(handle)
	*s = append(*s, *ptrFromHandle_schema_GroupVersionResource(_vl))
}

// Converters for non-pointer handles for type: fake.FakeDynamicClient
func ptrFromHandle_fake_FakeDynamicClient(h CGoHandle) *fake.FakeDynamicClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fake.FakeDynamicClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fake.FakeDynamicClient{})).(*fake.FakeDynamicClient)
}
func handleFromPtr_fake_FakeDynamicClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fake.FakeDynamicClient", p))
}

// Converters for implicit pointer handles for type: map[schema.GroupVersionKind]reflect.Type
func ptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(h CGoHandle) *map[schema.GroupVersionKind]reflect.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[schema.GroupVersionKind]reflect.Type")
	if p == nil {
		return nil
	}
	return p.(*map[schema.GroupVersionKind]reflect.Type)
}
func deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(h CGoHandle) map[schema.GroupVersionKind]reflect.Type {
	p := ptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_schema_GroupVersionKind_reflect_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[schema.GroupVersionKind]reflect.Type", p))
}

// --- wrapping map: map[schema.GroupVersionKind]reflect.Type ---
//
//export Map_schema_GroupVersionKind_reflect_Type_CTor
func Map_schema_GroupVersionKind_reflect_Type_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_schema_GroupVersionKind_reflect_Type(&map[schema.GroupVersionKind]reflect.Type{}))
}

//export Map_schema_GroupVersionKind_reflect_Type_len
func Map_schema_GroupVersionKind_reflect_Type_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle))
}

//export Map_schema_GroupVersionKind_reflect_Type_elem
func Map_schema_GroupVersionKind_reflect_Type_elem(handle CGoHandle, _ky CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	v, ok := s[*ptrFromHandle_schema_GroupVersionKind(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_reflect_Type(&v)
}

//export Map_schema_GroupVersionKind_reflect_Type_contains
func Map_schema_GroupVersionKind_reflect_Type_contains(handle CGoHandle, _ky CGoHandle) C.char {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	_, ok := s[*ptrFromHandle_schema_GroupVersionKind(_ky)]
	return boolGoToPy(ok)
}

//export Map_schema_GroupVersionKind_reflect_Type_set
func Map_schema_GroupVersionKind_reflect_Type_set(handle CGoHandle, _ky CGoHandle, _vl CGoHandle) {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	s[*ptrFromHandle_schema_GroupVersionKind(_ky)] = ptrFromHandle_reflect_Type(_vl)
}

//export Map_schema_GroupVersionKind_reflect_Type_delete
func Map_schema_GroupVersionKind_reflect_Type_delete(handle CGoHandle, _ky CGoHandle) {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	delete(s, *ptrFromHandle_schema_GroupVersionKind(_ky))
}

//export Map_schema_GroupVersionKind_reflect_Type_keys
func Map_schema_GroupVersionKind_reflect_Type_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	kys := make([]schema.GroupVersionKind, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_schema_GroupVersionKind(&kys)
}

// Converters for implicit pointer handles for type: map[schema.GroupVersionResource]string
func ptrFromHandle_Map_schema_GroupVersionResource_string(h CGoHandle) *map[schema.GroupVersionResource]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[schema.GroupVersionResource]string")
	if p == nil {
		return nil
	}
	return p.(*map[schema.GroupVersionResource]string)
}
func deptrFromHandle_Map_schema_GroupVersionResource_string(h CGoHandle) map[schema.GroupVersionResource]string {
	p := ptrFromHandle_Map_schema_GroupVersionResource_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_schema_GroupVersionResource_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[schema.GroupVersionResource]string", p))
}

// --- wrapping map: map[schema.GroupVersionResource]string ---
//
//export Map_schema_GroupVersionResource_string_CTor
func Map_schema_GroupVersionResource_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_schema_GroupVersionResource_string(&map[schema.GroupVersionResource]string{}))
}

//export Map_schema_GroupVersionResource_string_len
func Map_schema_GroupVersionResource_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_schema_GroupVersionResource_string(handle))
}

//export Map_schema_GroupVersionResource_string_elem
func Map_schema_GroupVersionResource_string_elem(handle CGoHandle, _ky CGoHandle) *C.char {
	s := deptrFromHandle_Map_schema_GroupVersionResource_string(handle)
	v, ok := s[*ptrFromHandle_schema_GroupVersionResource(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(v)
}

//export Map_schema_GroupVersionResource_string_contains
func Map_schema_GroupVersionResource_string_contains(handle CGoHandle, _ky CGoHandle) C.char {
	s := deptrFromHandle_Map_schema_GroupVersionResource_string(handle)
	_, ok := s[*ptrFromHandle_schema_GroupVersionResource(_ky)]
	return boolGoToPy(ok)
}

//export Map_schema_GroupVersionResource_string_set
func Map_schema_GroupVersionResource_string_set(handle CGoHandle, _ky CGoHandle, _vl *C.char) {
	s := deptrFromHandle_Map_schema_GroupVersionResource_string(handle)
	s[*ptrFromHandle_schema_GroupVersionResource(_ky)] = C.GoString(_vl)
}

//export Map_schema_GroupVersionResource_string_delete
func Map_schema_GroupVersionResource_string_delete(handle CGoHandle, _ky CGoHandle) {
	s := deptrFromHandle_Map_schema_GroupVersionResource_string(handle)
	delete(s, *ptrFromHandle_schema_GroupVersionResource(_ky))
}

//export Map_schema_GroupVersionResource_string_keys
func Map_schema_GroupVersionResource_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_schema_GroupVersionResource_string(handle)
	kys := make([]schema.GroupVersionResource, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_schema_GroupVersionResource(&kys)
}

// Converters for implicit pointer handles for type: map[string]reflect.Type
func ptrFromHandle_Map_string_reflect_Type(h CGoHandle) *map[string]reflect.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]reflect.Type")
	if p == nil {
		return nil
	}
	return p.(*map[string]reflect.Type)
}
func deptrFromHandle_Map_string_reflect_Type(h CGoHandle) map[string]reflect.Type {
	p := ptrFromHandle_Map_string_reflect_Type(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_reflect_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]reflect.Type", p))
}

// --- wrapping map: map[string]reflect.Type ---
//
//export Map_string_reflect_Type_CTor
func Map_string_reflect_Type_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_reflect_Type(&map[string]reflect.Type{}))
}

//export Map_string_reflect_Type_len
func Map_string_reflect_Type_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_reflect_Type(handle))
}

//export Map_string_reflect_Type_elem
func Map_string_reflect_Type_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_reflect_Type(&v)
}

//export Map_string_reflect_Type_contains
func Map_string_reflect_Type_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_reflect_Type_set
func Map_string_reflect_Type_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	s[C.GoString(_ky)] = ptrFromHandle_reflect_Type(_vl)
}

//export Map_string_reflect_Type_delete
func Map_string_reflect_Type_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_reflect_Type_keys
func Map_string_reflect_Type_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: fake.FakeDynamicClient ---
//
//export fake_FakeDynamicClient_CTor
func fake_FakeDynamicClient_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_fake_FakeDynamicClient(&fake.FakeDynamicClient{}))
}

//export fake_FakeDynamicClient_Tracker
func fake_FakeDynamicClient_Tracker(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.FakeDynamicClient")
	if __err != nil {
		return handleFromPtr_testing_ObjectTracker(nil)
	}
	return handleFromPtr_testing_ObjectTracker(gopyh.Embed(vifc, reflect.TypeOf(fake.FakeDynamicClient{})).(*fake.FakeDynamicClient).Tracker())

}

//export fake_FakeDynamicClient_Resource
func fake_FakeDynamicClient_Resource(_handle CGoHandle, resource CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.FakeDynamicClient")
	if __err != nil {
		return handleFromPtr_dynamic_NamespaceableResourceInterface(nil)
	}
	return handleFromPtr_dynamic_NamespaceableResourceInterface(gopyh.Embed(vifc, reflect.TypeOf(fake.FakeDynamicClient{})).(*fake.FakeDynamicClient).Resource(*ptrFromHandle_schema_GroupVersionResource(resource)))

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export fake_NewSimpleDynamicClient
func fake_NewSimpleDynamicClient(scheme CGoHandle, objects CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_fake_FakeDynamicClient(fake.NewSimpleDynamicClient(ptrFromHandle_Ptr_runtime_Scheme(scheme), deptrFromHandle_Slice_runtime_Object(objects)...))

}

//export fake_NewSimpleDynamicClientWithCustomListKinds
func fake_NewSimpleDynamicClientWithCustomListKinds(scheme CGoHandle, gvrToListKind CGoHandle, objects CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_fake_FakeDynamicClient(fake.NewSimpleDynamicClientWithCustomListKinds(ptrFromHandle_Ptr_runtime_Scheme(scheme), deptrFromHandle_Map_schema_GroupVersionResource_string(gvrToListKind), deptrFromHandle_Slice_runtime_Object(objects)...))

}

// ---- Functions ---
