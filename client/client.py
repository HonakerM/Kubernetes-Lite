"""
Package client contains functionality for interacting with Kubernetes API
servers.

# Clients

Clients are split into two interfaces -- Readers and Writers.   Readers
get and list, while writers create, update, and delete.

The New function can be used to create a new client that talks directly
to the API server.

It is a common pattern in Kubernetes to read from a cache and write to the API
server.  This pattern is covered by the creating the Client with a Cache.

# Options

Many client operations in Kubernetes support options.  These options are
represented as variadic arguments at the end of a given method call.
For instance, to use a label selector on list, you can call

	err := someReader.List(context.Background(), &podList, client.MatchingLabels{"somelabel": "someval"})

# Indexing

Indexes may be added to caches using a FieldIndexer.  This allows you to easily
and efficiently look up objects with certain properties.  You can then make
use of the index by specifying a field selector on calls to List on the Reader
corresponding to the given Cache.

For instance, a Secret controller might have an index on the
`.spec.volumes.secret.secretName` field in Pod objects, so that it could
easily look up all pods that reference a given secret.

"""
# python wrapper for package sigs.k8s.io/controller-runtime/pkg/client within overall package client
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg sigs.k8s.io/controller-runtime/pkg/client

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _client
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from client import client
# and then refer to everything using client. prefix
# packages imported by this package listed below:

from . import apiutil



# ---- Types ---

# Python type for slice []*x509.Certificate
class Slice_Ptr_x509_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_Ptr_x509_Certificate_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_x509_Certificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_Ptr_x509_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_Ptr_x509_Certificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_Ptr_x509_Certificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_Ptr_x509_Certificate_len(self.handle)
				return Slice_Ptr_x509_Certificate(handle=_client.Slice_Ptr_x509_Certificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_x509_Certificate(handle=_client.Slice_Ptr_x509_Certificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_Ptr_x509_Certificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_x509_Certificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_x509_Certificate(handle=_client.Slice_Ptr_x509_Certificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_Ptr_x509_Certificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*multipart.FileHeader
class Slice_Ptr_multipart_FileHeader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_Ptr_multipart_FileHeader_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_multipart_FileHeader.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_Ptr_multipart_FileHeader len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_Ptr_multipart_FileHeader([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_Ptr_multipart_FileHeader_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_Ptr_multipart_FileHeader_len(self.handle)
				return Slice_Ptr_multipart_FileHeader(handle=_client.Slice_Ptr_multipart_FileHeader_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_multipart_FileHeader(handle=_client.Slice_Ptr_multipart_FileHeader_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_Ptr_multipart_FileHeader_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_multipart_FileHeader.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_multipart_FileHeader(handle=_client.Slice_Ptr_multipart_FileHeader_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_Ptr_multipart_FileHeader_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*net.IPNet
class Slice_Ptr_net_IPNet(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_Ptr_net_IPNet_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_net_IPNet.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_Ptr_net_IPNet len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_Ptr_net_IPNet([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_Ptr_net_IPNet_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_Ptr_net_IPNet_len(self.handle)
				return Slice_Ptr_net_IPNet(handle=_client.Slice_Ptr_net_IPNet_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_net_IPNet(handle=_client.Slice_Ptr_net_IPNet_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_Ptr_net_IPNet_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_net_IPNet.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_net_IPNet(handle=_client.Slice_Ptr_net_IPNet_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_Ptr_net_IPNet_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*http.Cookie
class Slice_Ptr_http_Cookie(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_Ptr_http_Cookie_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_http_Cookie.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_Ptr_http_Cookie len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_Ptr_http_Cookie([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_Ptr_http_Cookie_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_Ptr_http_Cookie_len(self.handle)
				return Slice_Ptr_http_Cookie(handle=_client.Slice_Ptr_http_Cookie_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_http_Cookie(handle=_client.Slice_Ptr_http_Cookie_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_Ptr_http_Cookie_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_http_Cookie.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_http_Cookie(handle=_client.Slice_Ptr_http_Cookie_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_Ptr_http_Cookie_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*url.URL
class Slice_Ptr_url_URL(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_Ptr_url_URL_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_url_URL.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_Ptr_url_URL len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_Ptr_url_URL([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_Ptr_url_URL_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_Ptr_url_URL_len(self.handle)
				return Slice_Ptr_url_URL(handle=_client.Slice_Ptr_url_URL_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_url_URL(handle=_client.Slice_Ptr_url_URL_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_Ptr_url_URL_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_url_URL.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_url_URL(handle=_client.Slice_Ptr_url_URL_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_Ptr_url_URL_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]*x509.Certificate
class Slice_Slice_Ptr_x509_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_Slice_Ptr_x509_Certificate_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_Ptr_x509_Certificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_Slice_Ptr_x509_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_Slice_Ptr_x509_Certificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_Slice_Ptr_x509_Certificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_Slice_Ptr_x509_Certificate_len(self.handle)
				return Slice_Slice_Ptr_x509_Certificate(handle=_client.Slice_Slice_Ptr_x509_Certificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Slice_Ptr_x509_Certificate(handle=_client.Slice_Slice_Ptr_x509_Certificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_Slice_Ptr_x509_Certificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_Ptr_x509_Certificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Slice_Ptr_x509_Certificate(handle=_client.Slice_Slice_Ptr_x509_Certificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_Slice_Ptr_x509_Certificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]byte
class Slice_Slice_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_Slice_byte_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_byte.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_Slice_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_Slice_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_Slice_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_Slice_byte_len(self.handle)
				return Slice_Slice_byte(handle=_client.Slice_Slice_byte_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_byte(handle=_client.Slice_Slice_byte_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_Slice_byte_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_byte.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_byte(handle=_client.Slice_Slice_byte_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_Slice_byte_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []x509.ExtKeyUsage
class Slice_x509_ExtKeyUsage(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_x509_ExtKeyUsage_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_x509_ExtKeyUsage.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_x509_ExtKeyUsage len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_x509_ExtKeyUsage([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_x509_ExtKeyUsage_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_x509_ExtKeyUsage_len(self.handle)
				return Slice_x509_ExtKeyUsage(handle=_client.Slice_x509_ExtKeyUsage_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _client.Slice_x509_ExtKeyUsage_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_x509_ExtKeyUsage_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_x509_ExtKeyUsage.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _client.Slice_x509_ExtKeyUsage_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_x509_ExtKeyUsage_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []x509.OID
class Slice_x509_OID(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_x509_OID_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_x509_OID.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_x509_OID len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_x509_OID([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_x509_OID_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_x509_OID_len(self.handle)
				return Slice_x509_OID(handle=_client.Slice_x509_OID_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.x509_OID(handle=_client.Slice_x509_OID_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_x509_OID_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_x509_OID.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.x509_OID(handle=_client.Slice_x509_OID_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_x509_OID_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.AttributeTypeAndValue
class Slice_pkix_AttributeTypeAndValue(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_pkix_AttributeTypeAndValue_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_AttributeTypeAndValue.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_pkix_AttributeTypeAndValue len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_pkix_AttributeTypeAndValue([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_pkix_AttributeTypeAndValue_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_pkix_AttributeTypeAndValue_len(self.handle)
				return Slice_pkix_AttributeTypeAndValue(handle=_client.Slice_pkix_AttributeTypeAndValue_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_AttributeTypeAndValue(handle=_client.Slice_pkix_AttributeTypeAndValue_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_pkix_AttributeTypeAndValue_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_AttributeTypeAndValue.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_AttributeTypeAndValue(handle=_client.Slice_pkix_AttributeTypeAndValue_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_pkix_AttributeTypeAndValue_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.Extension
class Slice_pkix_Extension(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_pkix_Extension_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_Extension.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_pkix_Extension len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_pkix_Extension([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_pkix_Extension_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_pkix_Extension_len(self.handle)
				return Slice_pkix_Extension(handle=_client.Slice_pkix_Extension_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_Extension(handle=_client.Slice_pkix_Extension_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_pkix_Extension_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_Extension.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_Extension(handle=_client.Slice_pkix_Extension_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_pkix_Extension_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.RevokedCertificate
class Slice_pkix_RevokedCertificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_pkix_RevokedCertificate_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_RevokedCertificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_pkix_RevokedCertificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_pkix_RevokedCertificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_pkix_RevokedCertificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_pkix_RevokedCertificate_len(self.handle)
				return Slice_pkix_RevokedCertificate(handle=_client.Slice_pkix_RevokedCertificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_RevokedCertificate(handle=_client.Slice_pkix_RevokedCertificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_pkix_RevokedCertificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_RevokedCertificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_RevokedCertificate(handle=_client.Slice_pkix_RevokedCertificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_pkix_RevokedCertificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []asn1.ObjectIdentifier
class Slice_asn1_ObjectIdentifier(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_asn1_ObjectIdentifier_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_asn1_ObjectIdentifier.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_asn1_ObjectIdentifier len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_asn1_ObjectIdentifier([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_asn1_ObjectIdentifier_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_asn1_ObjectIdentifier_len(self.handle)
				return Slice_asn1_ObjectIdentifier(handle=_client.Slice_asn1_ObjectIdentifier_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.asn1_ObjectIdentifier(handle=_client.Slice_asn1_ObjectIdentifier_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_asn1_ObjectIdentifier_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_asn1_ObjectIdentifier.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.asn1_ObjectIdentifier(handle=_client.Slice_asn1_ObjectIdentifier_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_asn1_ObjectIdentifier_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []v1.ManagedFieldsEntry
class Slice_v1_ManagedFieldsEntry(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_v1_ManagedFieldsEntry_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_v1_ManagedFieldsEntry.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_v1_ManagedFieldsEntry len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_v1_ManagedFieldsEntry([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_v1_ManagedFieldsEntry_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_v1_ManagedFieldsEntry_len(self.handle)
				return Slice_v1_ManagedFieldsEntry(handle=_client.Slice_v1_ManagedFieldsEntry_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.v1_ManagedFieldsEntry(handle=_client.Slice_v1_ManagedFieldsEntry_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_v1_ManagedFieldsEntry_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_v1_ManagedFieldsEntry.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.v1_ManagedFieldsEntry(handle=_client.Slice_v1_ManagedFieldsEntry_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_v1_ManagedFieldsEntry_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []v1.OwnerReference
class Slice_v1_OwnerReference(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_v1_OwnerReference_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_v1_OwnerReference.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_v1_OwnerReference len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_v1_OwnerReference([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_v1_OwnerReference_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_v1_OwnerReference_len(self.handle)
				return Slice_v1_OwnerReference(handle=_client.Slice_v1_OwnerReference_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.v1_OwnerReference(handle=_client.Slice_v1_OwnerReference_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_v1_OwnerReference_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_v1_OwnerReference.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.v1_OwnerReference(handle=_client.Slice_v1_OwnerReference_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_v1_OwnerReference_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []runtime.Object
class Slice_runtime_Object(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_runtime_Object_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_runtime_Object.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_runtime_Object len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_runtime_Object([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_runtime_Object_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_runtime_Object_len(self.handle)
				return Slice_runtime_Object(handle=_client.Slice_runtime_Object_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.runtime_Object(handle=_client.Slice_runtime_Object_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_runtime_Object_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_runtime_Object.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.runtime_Object(handle=_client.Slice_runtime_Object_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_runtime_Object_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []schema.GroupVersion
class Slice_schema_GroupVersion(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_schema_GroupVersion_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_schema_GroupVersion.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_schema_GroupVersion len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_schema_GroupVersion([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_schema_GroupVersion_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_schema_GroupVersion_len(self.handle)
				return Slice_schema_GroupVersion(handle=_client.Slice_schema_GroupVersion_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.schema_GroupVersion(handle=_client.Slice_schema_GroupVersion_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_schema_GroupVersion_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_schema_GroupVersion.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.schema_GroupVersion(handle=_client.Slice_schema_GroupVersion_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_schema_GroupVersion_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []schema.GroupVersionKind
class Slice_schema_GroupVersionKind(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_schema_GroupVersionKind_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_schema_GroupVersionKind.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_schema_GroupVersionKind len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_schema_GroupVersionKind([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_schema_GroupVersionKind_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_schema_GroupVersionKind_len(self.handle)
				return Slice_schema_GroupVersionKind(handle=_client.Slice_schema_GroupVersionKind_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.schema_GroupVersionKind(handle=_client.Slice_schema_GroupVersionKind_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_schema_GroupVersionKind_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_schema_GroupVersionKind.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.schema_GroupVersionKind(handle=_client.Slice_schema_GroupVersionKind_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_schema_GroupVersionKind_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []api.ExecEnvVar
class Slice_api_ExecEnvVar(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_api_ExecEnvVar_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_api_ExecEnvVar.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_api_ExecEnvVar len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_api_ExecEnvVar([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_api_ExecEnvVar_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_api_ExecEnvVar_len(self.handle)
				return Slice_api_ExecEnvVar(handle=_client.Slice_api_ExecEnvVar_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.api_ExecEnvVar(handle=_client.Slice_api_ExecEnvVar_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_api_ExecEnvVar_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_api_ExecEnvVar.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.api_ExecEnvVar(handle=_client.Slice_api_ExecEnvVar_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_api_ExecEnvVar_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []big.Word
class Slice_big_Word(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_big_Word_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_big_Word.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_big_Word len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_big_Word([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_big_Word_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_big_Word_len(self.handle)
				return Slice_big_Word(handle=_client.Slice_big_Word_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _client.Slice_big_Word_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_big_Word_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_big_Word.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _client.Slice_big_Word_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_big_Word_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []net.IP
class Slice_net_IP(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_net_IP_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_net_IP.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_net_IP len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_net_IP([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_net_IP_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_net_IP_len(self.handle)
				return Slice_net_IP(handle=_client.Slice_net_IP_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.net_IP(handle=_client.Slice_net_IP_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_net_IP_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_net_IP.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.net_IP(handle=_client.Slice_net_IP_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_net_IP_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.CreateOption
class Slice_client_CreateOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_CreateOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_CreateOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_CreateOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_CreateOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_CreateOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_CreateOption_len(self.handle)
				return Slice_client_CreateOption(handle=_client.Slice_client_CreateOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return CreateOption(handle=_client.Slice_client_CreateOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_CreateOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_CreateOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = CreateOption(handle=_client.Slice_client_CreateOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_CreateOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.DeleteAllOfOption
class Slice_client_DeleteAllOfOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_DeleteAllOfOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_DeleteAllOfOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_DeleteAllOfOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_DeleteAllOfOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_DeleteAllOfOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_DeleteAllOfOption_len(self.handle)
				return Slice_client_DeleteAllOfOption(handle=_client.Slice_client_DeleteAllOfOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return DeleteAllOfOption(handle=_client.Slice_client_DeleteAllOfOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_DeleteAllOfOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_DeleteAllOfOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = DeleteAllOfOption(handle=_client.Slice_client_DeleteAllOfOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_DeleteAllOfOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.DeleteOption
class Slice_client_DeleteOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_DeleteOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_DeleteOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_DeleteOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_DeleteOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_DeleteOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_DeleteOption_len(self.handle)
				return Slice_client_DeleteOption(handle=_client.Slice_client_DeleteOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return DeleteOption(handle=_client.Slice_client_DeleteOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_DeleteOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_DeleteOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = DeleteOption(handle=_client.Slice_client_DeleteOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_DeleteOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.GetOption
class Slice_client_GetOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_GetOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_GetOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_GetOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_GetOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_GetOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_GetOption_len(self.handle)
				return Slice_client_GetOption(handle=_client.Slice_client_GetOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return GetOption(handle=_client.Slice_client_GetOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_GetOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_GetOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = GetOption(handle=_client.Slice_client_GetOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_GetOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.ListOption
class Slice_client_ListOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_ListOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_ListOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_ListOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_ListOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_ListOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_ListOption_len(self.handle)
				return Slice_client_ListOption(handle=_client.Slice_client_ListOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return ListOption(handle=_client.Slice_client_ListOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_ListOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_ListOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = ListOption(handle=_client.Slice_client_ListOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_ListOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.MergeFromOption
class Slice_client_MergeFromOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_MergeFromOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_MergeFromOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_MergeFromOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_MergeFromOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_MergeFromOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_MergeFromOption_len(self.handle)
				return Slice_client_MergeFromOption(handle=_client.Slice_client_MergeFromOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return MergeFromOption(handle=_client.Slice_client_MergeFromOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_MergeFromOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_MergeFromOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = MergeFromOption(handle=_client.Slice_client_MergeFromOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_MergeFromOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.Object
class Slice_client_Object(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_Object_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_Object.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_Object len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_Object([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_Object_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_Object_len(self.handle)
				return Slice_client_Object(handle=_client.Slice_client_Object_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Object(handle=_client.Slice_client_Object_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_Object_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_Object.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Object(handle=_client.Slice_client_Object_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_Object_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.PatchOption
class Slice_client_PatchOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_PatchOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_PatchOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_PatchOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_PatchOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_PatchOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_PatchOption_len(self.handle)
				return Slice_client_PatchOption(handle=_client.Slice_client_PatchOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return PatchOption(handle=_client.Slice_client_PatchOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_PatchOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_PatchOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = PatchOption(handle=_client.Slice_client_PatchOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_PatchOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.SubResourceCreateOption
class Slice_client_SubResourceCreateOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_SubResourceCreateOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_SubResourceCreateOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_SubResourceCreateOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_SubResourceCreateOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_SubResourceCreateOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_SubResourceCreateOption_len(self.handle)
				return Slice_client_SubResourceCreateOption(handle=_client.Slice_client_SubResourceCreateOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return SubResourceCreateOption(handle=_client.Slice_client_SubResourceCreateOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_SubResourceCreateOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_SubResourceCreateOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = SubResourceCreateOption(handle=_client.Slice_client_SubResourceCreateOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_SubResourceCreateOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.SubResourceGetOption
class Slice_client_SubResourceGetOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_SubResourceGetOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_SubResourceGetOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_SubResourceGetOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_SubResourceGetOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_SubResourceGetOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_SubResourceGetOption_len(self.handle)
				return Slice_client_SubResourceGetOption(handle=_client.Slice_client_SubResourceGetOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return SubResourceGetOption(handle=_client.Slice_client_SubResourceGetOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_SubResourceGetOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_SubResourceGetOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = SubResourceGetOption(handle=_client.Slice_client_SubResourceGetOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_SubResourceGetOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.SubResourcePatchOption
class Slice_client_SubResourcePatchOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_SubResourcePatchOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_SubResourcePatchOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_SubResourcePatchOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_SubResourcePatchOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_SubResourcePatchOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_SubResourcePatchOption_len(self.handle)
				return Slice_client_SubResourcePatchOption(handle=_client.Slice_client_SubResourcePatchOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return SubResourcePatchOption(handle=_client.Slice_client_SubResourcePatchOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_SubResourcePatchOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_SubResourcePatchOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = SubResourcePatchOption(handle=_client.Slice_client_SubResourcePatchOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_SubResourcePatchOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.SubResourceUpdateOption
class Slice_client_SubResourceUpdateOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_SubResourceUpdateOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_SubResourceUpdateOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_SubResourceUpdateOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_SubResourceUpdateOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_SubResourceUpdateOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_SubResourceUpdateOption_len(self.handle)
				return Slice_client_SubResourceUpdateOption(handle=_client.Slice_client_SubResourceUpdateOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return SubResourceUpdateOption(handle=_client.Slice_client_SubResourceUpdateOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_SubResourceUpdateOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_SubResourceUpdateOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = SubResourceUpdateOption(handle=_client.Slice_client_SubResourceUpdateOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_SubResourceUpdateOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []client.UpdateOption
class Slice_client_UpdateOption(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_client_UpdateOption_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_client_UpdateOption.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Slice_client_UpdateOption len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.Slice_client_UpdateOption([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_client_UpdateOption_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_client_UpdateOption_len(self.handle)
				return Slice_client_UpdateOption(handle=_client.Slice_client_UpdateOption_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return UpdateOption(handle=_client.Slice_client_UpdateOption_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_client_UpdateOption_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_client_UpdateOption.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = UpdateOption(handle=_client.Slice_client_UpdateOption_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_client_UpdateOption_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[schema.GroupVersionKind]reflect.Type
class Map_schema_GroupVersionKind_reflect_Type(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Map_schema_GroupVersionKind_reflect_Type_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_schema_GroupVersionKind_reflect_Type.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_client.Map_schema_GroupVersionKind_reflect_Type_set(self.handle, k, v)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Map_schema_GroupVersionKind_reflect_Type len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'client.Map_schema_GroupVersionKind_reflect_Type({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _client.Map_schema_GroupVersionKind_reflect_Type_len(self.handle)
	def __getitem__(self, key):
		return go.reflect_Type(handle=_client.Map_schema_GroupVersionKind_reflect_Type_elem(self.handle, key.handle))
	def __setitem__(self, key, value):
		_client.Map_schema_GroupVersionKind_reflect_Type_set(self.handle, key.handle, value.handle)
	def __delitem__(self, key):
		return _client.Map_schema_GroupVersionKind_reflect_Type_delete(self.handle, key.handle)
	def keys(self):
		return Slice_schema_GroupVersionKind(handle=_client.Map_schema_GroupVersionKind_reflect_Type_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _client.Map_schema_GroupVersionKind_reflect_Type_contains(self.handle, key.handle)

# Python type for map map[string][]*multipart.FileHeader
class Map_string_Slice_Ptr_multipart_FileHeader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Map_string_Slice_Ptr_multipart_FileHeader_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_Ptr_multipart_FileHeader.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_client.Map_string_Slice_Ptr_multipart_FileHeader_set(self.handle, k, v)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Map_string_Slice_Ptr_multipart_FileHeader len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'client.Map_string_Slice_Ptr_multipart_FileHeader({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _client.Map_string_Slice_Ptr_multipart_FileHeader_len(self.handle)
	def __getitem__(self, key):
		return Slice_Ptr_multipart_FileHeader(handle=_client.Map_string_Slice_Ptr_multipart_FileHeader_elem(self.handle, key))
	def __setitem__(self, key, value):
		_client.Map_string_Slice_Ptr_multipart_FileHeader_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _client.Map_string_Slice_Ptr_multipart_FileHeader_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_client.Map_string_Slice_Ptr_multipart_FileHeader_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _client.Map_string_Slice_Ptr_multipart_FileHeader_contains(self.handle, key)

# Python type for map map[string][]string
class Map_string_Slice_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Map_string_Slice_string_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_client.Map_string_Slice_string_set(self.handle, k, v)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Map_string_Slice_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'client.Map_string_Slice_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _client.Map_string_Slice_string_len(self.handle)
	def __getitem__(self, key):
		return go.Slice_string(handle=_client.Map_string_Slice_string_elem(self.handle, key))
	def __setitem__(self, key, value):
		_client.Map_string_Slice_string_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _client.Map_string_Slice_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_client.Map_string_Slice_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _client.Map_string_Slice_string_contains(self.handle, key)

# Python type for map map[string]bool
class Map_string_bool(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Map_string_bool_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_bool.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_client.Map_string_bool_set(self.handle, k, v)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Map_string_bool len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'client.Map_string_bool({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _client.Map_string_bool_len(self.handle)
	def __getitem__(self, key):
		return _client.Map_string_bool_elem(self.handle, key)
	def __setitem__(self, key, value):
		_client.Map_string_bool_set(self.handle, key, value)
	def __delitem__(self, key):
		return _client.Map_string_bool_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_client.Map_string_bool_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _client.Map_string_bool_contains(self.handle, key)

# Python type for map map[string]reflect.Type
class Map_string_reflect_Type(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Map_string_reflect_Type_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_reflect_Type.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_client.Map_string_reflect_Type_set(self.handle, k, v)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Map_string_reflect_Type len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'client.Map_string_reflect_Type({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _client.Map_string_reflect_Type_len(self.handle)
	def __getitem__(self, key):
		return go.reflect_Type(handle=_client.Map_string_reflect_Type_elem(self.handle, key))
	def __setitem__(self, key, value):
		_client.Map_string_reflect_Type_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _client.Map_string_reflect_Type_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_client.Map_string_reflect_Type_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _client.Map_string_reflect_Type_contains(self.handle, key)

# Python type for map map[string]string
class Map_string_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Map_string_string_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_client.Map_string_string_set(self.handle, k, v)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.Map_string_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'client.Map_string_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _client.Map_string_string_len(self.handle)
	def __getitem__(self, key):
		return _client.Map_string_string_elem(self.handle, key)
	def __setitem__(self, key, value):
		_client.Map_string_string_set(self.handle, key, value)
	def __delitem__(self, key):
		return _client.Map_string_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_client.Map_string_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _client.Map_string_string_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---
UnsafeDisableDeepCopy = True
"""
UnsafeDisableDeepCopy indicates not to deep copy objects during list objects.

"""


# ---- Global Variables: can only use functions to access ---
def Apply():
	"""
	Apply Gets Go Variable: client.Apply
	
	"""
	return Patch(handle=_client.client_Apply())

def Set_Apply(value):
	"""
	Set_Apply Sets Go Variable: client.Apply
	
	"""
	if isinstance(value, go.GoClass):
		_client.client_Set_Apply(value.handle)
	else:
		_client.client_Set_Apply(value)

def Merge():
	"""
	Merge Gets Go Variable: client.Merge
	
	"""
	return Patch(handle=_client.client_Merge())

def Set_Merge(value):
	"""
	Set_Merge Sets Go Variable: client.Merge
	
	"""
	if isinstance(value, go.GoClass):
		_client.client_Set_Merge(value.handle)
	else:
		_client.client_Set_Merge(value)



# ---- Interfaces ---

# Python type for interface client.Reader
class Reader(go.GoClass):
	"""Reader knows how to read and list Kubernetes objects.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Get(self, ctx, key, obj, *args):
		"""Get(object ctx, object key, object obj, []object opts) str"""
		opts = Slice_client_GetOption(args)
		return _client.client_Reader_Get(self.handle, ctx.handle, key.handle, obj.handle, opts.handle)
	def List(self, ctx, list, *args):
		"""List(object ctx, object list, []object opts) str"""
		opts = Slice_client_ListOption(args)
		return _client.client_Reader_List(self.handle, ctx.handle, list.handle, opts.handle)

# Python type for interface client.StatusClient
class StatusClient(go.GoClass):
	"""StatusClient knows how to create a client which can update status subresource\nfor kubernetes objects.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Status(self):
		"""Status() object"""
		return SubResourceWriter(handle=_client.client_StatusClient_Status(self.handle))

# Python type for interface client.SubResourceUpdateAndPatchOption
class SubResourceUpdateAndPatchOption(go.GoClass):
	"""SubResourceUpdateAndPatchOption is an option that can be used for either\na subresource update or patch request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToSubResourcePatch(self, arg_0, goRun=False):
		"""ApplyToSubResourcePatch(object) """
		_client.client_SubResourceUpdateAndPatchOption_ApplyToSubResourcePatch(self.handle, arg_0.handle, goRun)
	def ApplyToSubResourceUpdate(self, arg_0, goRun=False):
		"""ApplyToSubResourceUpdate(object) """
		_client.client_SubResourceUpdateAndPatchOption_ApplyToSubResourceUpdate(self.handle, arg_0.handle, goRun)

# Python type for interface client.GetOption
class GetOption(go.GoClass):
	"""GetOption is some configuration that modifies options for a get request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToGet(self, arg_0, goRun=False):
		"""ApplyToGet(object) """
		_client.client_GetOption_ApplyToGet(self.handle, arg_0.handle, goRun)

# Python type for interface client.ObjectList
class ObjectList(go.GoClass):
	"""ObjectList is a Kubernetes object list, allows functions to work\nindistinctly with any resource that implements both runtime.Object and\nmetav1.ListInterface interfaces.\n\nSemantically, this is any object which may be serialized (ObjectMeta), and\nis a kubernetes list wrapper (has items, pagination fields, etc) -- think\nthe wrapper used in a response from a `kubectl list --output yaml` call.\n\nCode-wise, this means that any object which embedds both ListMeta (which\nprovides metav1.ListInterface) and TypeMeta (which provides half of\nruntime.Object) and has a `DeepCopyObject` implementation (the other half of\nruntime.Object) will implement this by default.\n\nFor example, nearly all the built-in XYZList types are ObjectLists, as well\nas the XYZList types for all KubeBuilder-generated CRDs (unless you do\nsomething real funky to them).\n\nBy and large, most things that are XYZList and implement runtime.Object also\nimplement ObjectList -- it's very rare to have *just* a runtime.Object\nimplementation (the cases tend to be funky built-in types like Webhook\npayloads that don't have a `metadata` field).\n\nThis is similar to Object, which is almost always implemented by the items\nin the list themselves.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def DeepCopyObject(self):
		"""DeepCopyObject() object"""
		return go.runtime_Object(handle=_client.client_ObjectList_DeepCopyObject(self.handle))
	def GetContinue(self):
		"""GetContinue() str"""
		return _client.client_ObjectList_GetContinue(self.handle)
	def GetObjectKind(self):
		"""GetObjectKind() object"""
		return go.schema_ObjectKind(handle=_client.client_ObjectList_GetObjectKind(self.handle))
	def GetResourceVersion(self):
		"""GetResourceVersion() str"""
		return _client.client_ObjectList_GetResourceVersion(self.handle)
	def GetSelfLink(self):
		"""GetSelfLink() str"""
		return _client.client_ObjectList_GetSelfLink(self.handle)
	def SetContinue(self, c, goRun=False):
		"""SetContinue(str c) """
		_client.client_ObjectList_SetContinue(self.handle, c, goRun)
	def SetResourceVersion(self, version, goRun=False):
		"""SetResourceVersion(str version) """
		_client.client_ObjectList_SetResourceVersion(self.handle, version, goRun)
	def SetSelfLink(self, selfLink, goRun=False):
		"""SetSelfLink(str selfLink) """
		_client.client_ObjectList_SetSelfLink(self.handle, selfLink, goRun)

# Python type for interface client.SubResourcePatchOption
class SubResourcePatchOption(go.GoClass):
	"""SubResourcePatchOption configures a subresource patch request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToSubResourcePatch(self, arg_0, goRun=False):
		"""ApplyToSubResourcePatch(object) """
		_client.client_SubResourcePatchOption_ApplyToSubResourcePatch(self.handle, arg_0.handle, goRun)

# Python type for interface client.CreateOption
class CreateOption(go.GoClass):
	"""CreateOption is some configuration that modifies options for a create request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToCreate(self, arg_0, goRun=False):
		"""ApplyToCreate(object) """
		_client.client_CreateOption_ApplyToCreate(self.handle, arg_0.handle, goRun)

# Python type for interface client.DeleteOption
class DeleteOption(go.GoClass):
	"""DeleteOption is some configuration that modifies options for a delete request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToDelete(self, arg_0, goRun=False):
		"""ApplyToDelete(object) """
		_client.client_DeleteOption_ApplyToDelete(self.handle, arg_0.handle, goRun)

# Python type for interface client.Object
class Object(go.GoClass):
	"""Object is a Kubernetes object, allows functions to work indistinctly with\nany resource that implements both Object interfaces.\n\nSemantically, these are objects which are both serializable (runtime.Object)\nand identifiable (metav1.Object) -- think any object which you could write\nas YAML or JSON, and then `kubectl create`.\n\nCode-wise, this means that any object which embeds both ObjectMeta (which\nprovides metav1.Object) and TypeMeta (which provides half of runtime.Object)\nand has a `DeepCopyObject` implementation (the other half of runtime.Object)\nwill implement this by default.\n\nFor example, nearly all the built-in types are Objects, as well as all\nKubeBuilder-generated CRDs (unless you do something real funky to them).\n\nBy and large, most things that implement runtime.Object also implement\nObject -- it's very rare to have *just* a runtime.Object implementation (the\ncases tend to be funky built-in types like Webhook payloads that don't have\na `metadata` field).\n\nNotice that XYZList types are distinct: they implement ObjectList instead.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def DeepCopyObject(self):
		"""DeepCopyObject() object"""
		return go.runtime_Object(handle=_client.client_Object_DeepCopyObject(self.handle))
	def GetAnnotations(self):
		"""GetAnnotations() object"""
		return Map_string_string(handle=_client.client_Object_GetAnnotations(self.handle))
	def GetCreationTimestamp(self):
		"""GetCreationTimestamp() object"""
		return go.v1_Time(handle=_client.client_Object_GetCreationTimestamp(self.handle))
	def GetDeletionTimestamp(self):
		"""GetDeletionTimestamp() object"""
		return go.Ptr_v1_Time(handle=_client.client_Object_GetDeletionTimestamp(self.handle))
	def GetFinalizers(self):
		"""GetFinalizers() []str"""
		return go.Slice_string(handle=_client.client_Object_GetFinalizers(self.handle))
	def GetGenerateName(self):
		"""GetGenerateName() str"""
		return _client.client_Object_GetGenerateName(self.handle)
	def GetGeneration(self):
		"""GetGeneration() long"""
		return _client.client_Object_GetGeneration(self.handle)
	def GetLabels(self):
		"""GetLabels() object"""
		return Map_string_string(handle=_client.client_Object_GetLabels(self.handle))
	def GetManagedFields(self):
		"""GetManagedFields() []object"""
		return Slice_v1_ManagedFieldsEntry(handle=_client.client_Object_GetManagedFields(self.handle))
	def GetName(self):
		"""GetName() str"""
		return _client.client_Object_GetName(self.handle)
	def GetNamespace(self):
		"""GetNamespace() str"""
		return _client.client_Object_GetNamespace(self.handle)
	def GetObjectKind(self):
		"""GetObjectKind() object"""
		return go.schema_ObjectKind(handle=_client.client_Object_GetObjectKind(self.handle))
	def GetOwnerReferences(self):
		"""GetOwnerReferences() []object"""
		return Slice_v1_OwnerReference(handle=_client.client_Object_GetOwnerReferences(self.handle))
	def GetResourceVersion(self):
		"""GetResourceVersion() str"""
		return _client.client_Object_GetResourceVersion(self.handle)
	def GetSelfLink(self):
		"""GetSelfLink() str"""
		return _client.client_Object_GetSelfLink(self.handle)
	def GetUID(self):
		"""GetUID() str"""
		return _client.client_Object_GetUID(self.handle)
	def SetAnnotations(self, annotations, goRun=False):
		"""SetAnnotations(object annotations) """
		_client.client_Object_SetAnnotations(self.handle, annotations.handle, goRun)
	def SetCreationTimestamp(self, timestamp, goRun=False):
		"""SetCreationTimestamp(object timestamp) """
		_client.client_Object_SetCreationTimestamp(self.handle, timestamp.handle, goRun)
	def SetDeletionTimestamp(self, timestamp, goRun=False):
		"""SetDeletionTimestamp(object timestamp) """
		_client.client_Object_SetDeletionTimestamp(self.handle, timestamp.handle, goRun)
	def SetFinalizers(self, finalizers, goRun=False):
		"""SetFinalizers([]str finalizers) """
		_client.client_Object_SetFinalizers(self.handle, finalizers.handle, goRun)
	def SetGenerateName(self, name, goRun=False):
		"""SetGenerateName(str name) """
		_client.client_Object_SetGenerateName(self.handle, name, goRun)
	def SetGeneration(self, generation, goRun=False):
		"""SetGeneration(long generation) """
		_client.client_Object_SetGeneration(self.handle, generation, goRun)
	def SetLabels(self, labels, goRun=False):
		"""SetLabels(object labels) """
		_client.client_Object_SetLabels(self.handle, labels.handle, goRun)
	def SetManagedFields(self, managedFields, goRun=False):
		"""SetManagedFields([]object managedFields) """
		_client.client_Object_SetManagedFields(self.handle, managedFields.handle, goRun)
	def SetName(self, name, goRun=False):
		"""SetName(str name) """
		_client.client_Object_SetName(self.handle, name, goRun)
	def SetNamespace(self, namespace, goRun=False):
		"""SetNamespace(str namespace) """
		_client.client_Object_SetNamespace(self.handle, namespace, goRun)
	def SetOwnerReferences(self, arg_0, goRun=False):
		"""SetOwnerReferences([]object) """
		_client.client_Object_SetOwnerReferences(self.handle, arg_0.handle, goRun)
	def SetResourceVersion(self, version, goRun=False):
		"""SetResourceVersion(str version) """
		_client.client_Object_SetResourceVersion(self.handle, version, goRun)
	def SetSelfLink(self, selfLink, goRun=False):
		"""SetSelfLink(str selfLink) """
		_client.client_Object_SetSelfLink(self.handle, selfLink, goRun)
	def SetUID(self, uid, goRun=False):
		"""SetUID(str uid) """
		_client.client_Object_SetUID(self.handle, uid, goRun)

# Python type for interface client.Writer
class Writer(go.GoClass):
	"""Writer knows how to create, delete, and update Kubernetes objects.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Create(self, ctx, obj, *args):
		"""Create(object ctx, object obj, []object opts) str"""
		opts = Slice_client_CreateOption(args)
		return _client.client_Writer_Create(self.handle, ctx.handle, obj.handle, opts.handle)
	def Delete(self, ctx, obj, *args):
		"""Delete(object ctx, object obj, []object opts) str"""
		opts = Slice_client_DeleteOption(args)
		return _client.client_Writer_Delete(self.handle, ctx.handle, obj.handle, opts.handle)
	def DeleteAllOf(self, ctx, obj, *args):
		"""DeleteAllOf(object ctx, object obj, []object opts) str"""
		opts = Slice_client_DeleteAllOfOption(args)
		return _client.client_Writer_DeleteAllOf(self.handle, ctx.handle, obj.handle, opts.handle)
	def Patch(self, ctx, obj, patch, *args):
		"""Patch(object ctx, object obj, object patch, []object opts) str"""
		opts = Slice_client_PatchOption(args)
		return _client.client_Writer_Patch(self.handle, ctx.handle, obj.handle, patch.handle, opts.handle)
	def Update(self, ctx, obj, *args):
		"""Update(object ctx, object obj, []object opts) str"""
		opts = Slice_client_UpdateOption(args)
		return _client.client_Writer_Update(self.handle, ctx.handle, obj.handle, opts.handle)

# Python type for interface client.MergeFromOption
class MergeFromOption(go.GoClass):
	"""MergeFromOption is some configuration that modifies options for a merge-from patch data.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToMergeFrom(self, arg_0, goRun=False):
		"""ApplyToMergeFrom(object) """
		_client.client_MergeFromOption_ApplyToMergeFrom(self.handle, arg_0.handle, goRun)

# Python type for interface client.PatchOption
class PatchOption(go.GoClass):
	"""PatchOption is some configuration that modifies options for a patch request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToPatch(self, arg_0, goRun=False):
		"""ApplyToPatch(object) """
		_client.client_PatchOption_ApplyToPatch(self.handle, arg_0.handle, goRun)

# Python type for interface client.SubResourceGetOption
class SubResourceGetOption(go.GoClass):
	"""SubResourceGetOption modifies options for a SubResource Get request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToSubResourceGet(self, arg_0, goRun=False):
		"""ApplyToSubResourceGet(object) """
		_client.client_SubResourceGetOption_ApplyToSubResourceGet(self.handle, arg_0.handle, goRun)

# Python type for interface client.SubResourceReader
class SubResourceReader(go.GoClass):
	"""SubResourceReader knows how to read SubResources\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Get(self, ctx, obj, subResource, *args):
		"""Get(object ctx, object obj, object subResource, []object opts) str"""
		opts = Slice_client_SubResourceGetOption(args)
		return _client.client_SubResourceReader_Get(self.handle, ctx.handle, obj.handle, subResource.handle, opts.handle)

# Python type for interface client.WithWatch
class WithWatch(go.GoClass):
	"""WithWatch supports Watch on top of the CRUD operations supported by\nthe normal Client. Its intended use-case are CLI apps that need to wait for\nevents.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Create(self, ctx, obj, *args):
		"""Create(object ctx, object obj, []object opts) str"""
		opts = Slice_client_CreateOption(args)
		return _client.client_WithWatch_Create(self.handle, ctx.handle, obj.handle, opts.handle)
	def Delete(self, ctx, obj, *args):
		"""Delete(object ctx, object obj, []object opts) str"""
		opts = Slice_client_DeleteOption(args)
		return _client.client_WithWatch_Delete(self.handle, ctx.handle, obj.handle, opts.handle)
	def DeleteAllOf(self, ctx, obj, *args):
		"""DeleteAllOf(object ctx, object obj, []object opts) str"""
		opts = Slice_client_DeleteAllOfOption(args)
		return _client.client_WithWatch_DeleteAllOf(self.handle, ctx.handle, obj.handle, opts.handle)
	def Get(self, ctx, key, obj, *args):
		"""Get(object ctx, object key, object obj, []object opts) str"""
		opts = Slice_client_GetOption(args)
		return _client.client_WithWatch_Get(self.handle, ctx.handle, key.handle, obj.handle, opts.handle)
	def GroupVersionKindFor(self, obj):
		"""GroupVersionKindFor(object obj) object, str"""
		return go.schema_GroupVersionKind(handle=_client.client_WithWatch_GroupVersionKindFor(self.handle, obj.handle))
	def IsObjectNamespaced(self, obj):
		"""IsObjectNamespaced(object obj) bool, str"""
		return _client.client_WithWatch_IsObjectNamespaced(self.handle, obj.handle)
	def List(self, ctx, list, *args):
		"""List(object ctx, object list, []object opts) str"""
		opts = Slice_client_ListOption(args)
		return _client.client_WithWatch_List(self.handle, ctx.handle, list.handle, opts.handle)
	def Patch(self, ctx, obj, patch, *args):
		"""Patch(object ctx, object obj, object patch, []object opts) str"""
		opts = Slice_client_PatchOption(args)
		return _client.client_WithWatch_Patch(self.handle, ctx.handle, obj.handle, patch.handle, opts.handle)
	def RESTMapper(self):
		"""RESTMapper() object"""
		return go.meta_RESTMapper(handle=_client.client_WithWatch_RESTMapper(self.handle))
	def Scheme(self):
		"""Scheme() object"""
		return go.Ptr_runtime_Scheme(handle=_client.client_WithWatch_Scheme(self.handle))
	def Status(self):
		"""Status() object"""
		return SubResourceWriter(handle=_client.client_WithWatch_Status(self.handle))
	def SubResource(self, subResource):
		"""SubResource(str subResource) object"""
		return SubResourceClient(handle=_client.client_WithWatch_SubResource(self.handle, subResource))
	def Update(self, ctx, obj, *args):
		"""Update(object ctx, object obj, []object opts) str"""
		opts = Slice_client_UpdateOption(args)
		return _client.client_WithWatch_Update(self.handle, ctx.handle, obj.handle, opts.handle)
	def Watch(self, ctx, obj, *args):
		"""Watch(object ctx, object obj, []object opts) object, str"""
		opts = Slice_client_ListOption(args)
		return go.watch_Interface(handle=_client.client_WithWatch_Watch(self.handle, ctx.handle, obj.handle, opts.handle))

# Python type for interface client.FieldIndexer
class FieldIndexer(go.GoClass):
	"""FieldIndexer knows how to index over a particular \"field\" such that it\ncan later be used by a field selector.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0

# Python type for interface client.SubResourceClient
class SubResourceClient(go.GoClass):
	"""SubResourceClient knows how to perform CRU operations on Kubernetes objects.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Create(self, ctx, obj, subResource, *args):
		"""Create(object ctx, object obj, object subResource, []object opts) str"""
		opts = Slice_client_SubResourceCreateOption(args)
		return _client.client_SubResourceClient_Create(self.handle, ctx.handle, obj.handle, subResource.handle, opts.handle)
	def Get(self, ctx, obj, subResource, *args):
		"""Get(object ctx, object obj, object subResource, []object opts) str"""
		opts = Slice_client_SubResourceGetOption(args)
		return _client.client_SubResourceClient_Get(self.handle, ctx.handle, obj.handle, subResource.handle, opts.handle)
	def Patch(self, ctx, obj, patch, *args):
		"""Patch(object ctx, object obj, object patch, []object opts) str"""
		opts = Slice_client_SubResourcePatchOption(args)
		return _client.client_SubResourceClient_Patch(self.handle, ctx.handle, obj.handle, patch.handle, opts.handle)
	def Update(self, ctx, obj, *args):
		"""Update(object ctx, object obj, []object opts) str"""
		opts = Slice_client_SubResourceUpdateOption(args)
		return _client.client_SubResourceClient_Update(self.handle, ctx.handle, obj.handle, opts.handle)

# Python type for interface client.SubResourceUpdateOption
class SubResourceUpdateOption(go.GoClass):
	"""SubResourceUpdateOption is some configuration that modifies options for a update request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToSubResourceUpdate(self, arg_0, goRun=False):
		"""ApplyToSubResourceUpdate(object) """
		_client.client_SubResourceUpdateOption_ApplyToSubResourceUpdate(self.handle, arg_0.handle, goRun)

# Python type for interface client.SubResourceWriter
class SubResourceWriter(go.GoClass):
	"""SubResourceWriter knows how to update subresource of a Kubernetes object.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Create(self, ctx, obj, subResource, *args):
		"""Create(object ctx, object obj, object subResource, []object opts) str"""
		opts = Slice_client_SubResourceCreateOption(args)
		return _client.client_SubResourceWriter_Create(self.handle, ctx.handle, obj.handle, subResource.handle, opts.handle)
	def Patch(self, ctx, obj, patch, *args):
		"""Patch(object ctx, object obj, object patch, []object opts) str"""
		opts = Slice_client_SubResourcePatchOption(args)
		return _client.client_SubResourceWriter_Patch(self.handle, ctx.handle, obj.handle, patch.handle, opts.handle)
	def Update(self, ctx, obj, *args):
		"""Update(object ctx, object obj, []object opts) str"""
		opts = Slice_client_SubResourceUpdateOption(args)
		return _client.client_SubResourceWriter_Update(self.handle, ctx.handle, obj.handle, opts.handle)

# Python type for interface client.Client
class Client(go.GoClass):
	"""Client knows how to perform CRUD operations on Kubernetes objects.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Create(self, ctx, obj, *args):
		"""Create(object ctx, object obj, []object opts) str"""
		opts = Slice_client_CreateOption(args)
		return _client.client_Client_Create(self.handle, ctx.handle, obj.handle, opts.handle)
	def Delete(self, ctx, obj, *args):
		"""Delete(object ctx, object obj, []object opts) str"""
		opts = Slice_client_DeleteOption(args)
		return _client.client_Client_Delete(self.handle, ctx.handle, obj.handle, opts.handle)
	def DeleteAllOf(self, ctx, obj, *args):
		"""DeleteAllOf(object ctx, object obj, []object opts) str"""
		opts = Slice_client_DeleteAllOfOption(args)
		return _client.client_Client_DeleteAllOf(self.handle, ctx.handle, obj.handle, opts.handle)
	def Get(self, ctx, key, obj, *args):
		"""Get(object ctx, object key, object obj, []object opts) str"""
		opts = Slice_client_GetOption(args)
		return _client.client_Client_Get(self.handle, ctx.handle, key.handle, obj.handle, opts.handle)
	def GroupVersionKindFor(self, obj):
		"""GroupVersionKindFor(object obj) object, str"""
		return go.schema_GroupVersionKind(handle=_client.client_Client_GroupVersionKindFor(self.handle, obj.handle))
	def IsObjectNamespaced(self, obj):
		"""IsObjectNamespaced(object obj) bool, str"""
		return _client.client_Client_IsObjectNamespaced(self.handle, obj.handle)
	def List(self, ctx, list, *args):
		"""List(object ctx, object list, []object opts) str"""
		opts = Slice_client_ListOption(args)
		return _client.client_Client_List(self.handle, ctx.handle, list.handle, opts.handle)
	def Patch(self, ctx, obj, patch, *args):
		"""Patch(object ctx, object obj, object patch, []object opts) str"""
		opts = Slice_client_PatchOption(args)
		return _client.client_Client_Patch(self.handle, ctx.handle, obj.handle, patch.handle, opts.handle)
	def RESTMapper(self):
		"""RESTMapper() object"""
		return go.meta_RESTMapper(handle=_client.client_Client_RESTMapper(self.handle))
	def Scheme(self):
		"""Scheme() object"""
		return go.Ptr_runtime_Scheme(handle=_client.client_Client_Scheme(self.handle))
	def Status(self):
		"""Status() object"""
		return SubResourceWriter(handle=_client.client_Client_Status(self.handle))
	def SubResource(self, subResource):
		"""SubResource(str subResource) object"""
		return SubResourceClient(handle=_client.client_Client_SubResource(self.handle, subResource))
	def Update(self, ctx, obj, *args):
		"""Update(object ctx, object obj, []object opts) str"""
		opts = Slice_client_UpdateOption(args)
		return _client.client_Client_Update(self.handle, ctx.handle, obj.handle, opts.handle)

# Python type for interface client.ListOption
class ListOption(go.GoClass):
	"""ListOption is some configuration that modifies options for a list request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToList(self, arg_0, goRun=False):
		"""ApplyToList(object) """
		_client.client_ListOption_ApplyToList(self.handle, arg_0.handle, goRun)

# Python type for interface client.Patch
class Patch(go.GoClass):
	"""Patch is a patch that can be applied to a Kubernetes object.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Data(self, obj):
		"""Data(object obj) []int, str"""
		return go.Slice_byte(handle=_client.client_Patch_Data(self.handle, obj.handle))
	def Type(self):
		"""Type() str"""
		return _client.client_Patch_Type(self.handle)

# Python type for interface client.SubResourceClientConstructor
class SubResourceClientConstructor(go.GoClass):
	"""SubResourceClientConstructor knows how to create a client which can update subresource\nfor kubernetes objects.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def SubResource(self, subResource):
		"""SubResource(str subResource) object"""
		return SubResourceClient(handle=_client.client_SubResourceClientConstructor_SubResource(self.handle, subResource))

# Python type for interface client.SubResourceWriter
class StatusWriter(go.GoClass):
	"""SubResourceWriter knows how to update subresource of a Kubernetes object.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def Create(self, ctx, obj, subResource, *args):
		"""Create(object ctx, object obj, object subResource, []object opts) str"""
		opts = Slice_client_SubResourceCreateOption(args)
		return _client.client_SubResourceWriter_Create(self.handle, ctx.handle, obj.handle, subResource.handle, opts.handle)
	def Patch(self, ctx, obj, patch, *args):
		"""Patch(object ctx, object obj, object patch, []object opts) str"""
		opts = Slice_client_SubResourcePatchOption(args)
		return _client.client_SubResourceWriter_Patch(self.handle, ctx.handle, obj.handle, patch.handle, opts.handle)
	def Update(self, ctx, obj, *args):
		"""Update(object ctx, object obj, []object opts) str"""
		opts = Slice_client_SubResourceUpdateOption(args)
		return _client.client_SubResourceWriter_Update(self.handle, ctx.handle, obj.handle, opts.handle)

# Python type for interface client.SubResourceCreateOption
class SubResourceCreateOption(go.GoClass):
	"""SubResourceCreateOption is some configuration that modifies options for a create request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToSubResourceCreate(self, arg_0, goRun=False):
		"""ApplyToSubResourceCreate(object) """
		_client.client_SubResourceCreateOption_ApplyToSubResourceCreate(self.handle, arg_0.handle, goRun)

# Python type for interface client.UpdateOption
class UpdateOption(go.GoClass):
	"""UpdateOption is some configuration that modifies options for a update request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToUpdate(self, arg_0, goRun=False):
		"""ApplyToUpdate(object) """
		_client.client_UpdateOption_ApplyToUpdate(self.handle, arg_0.handle, goRun)

# Python type for interface client.DeleteAllOfOption
class DeleteAllOfOption(go.GoClass):
	"""DeleteAllOfOption is some configuration that modifies options for a delete request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = 0
	def ApplyToDeleteAllOf(self, arg_0, goRun=False):
		"""ApplyToDeleteAllOf(object) """
		_client.client_DeleteAllOfOption_ApplyToDeleteAllOf(self.handle, arg_0.handle, goRun)


# ---- Structs ---

# Python type for struct client.MergeFromOptions
class MergeFromOptions(go.GoClass):
	"""MergeFromOptions contains options to generate a merge-from patch data.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_MergeFromOptions_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.OptimisticLock = args[0]
			if "OptimisticLock" in kwargs:
				self.OptimisticLock = kwargs["OptimisticLock"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.MergeFromOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.MergeFromOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def OptimisticLock(self):
		"""OptimisticLock, when true, includes `metadata.resourceVersion` into the final
		patch data. If the `resourceVersion` field doesn't match what's stored,
		the operation results in a conflict and clients will need to try again.
		"""
		return _client.client_MergeFromOptions_OptimisticLock_Get(self.handle)
	@OptimisticLock.setter
	def OptimisticLock(self, value):
		if isinstance(value, go.GoClass):
			_client.client_MergeFromOptions_OptimisticLock_Set(self.handle, value.handle)
		else:
			_client.client_MergeFromOptions_OptimisticLock_Set(self.handle, value)

# Python type for struct client.Preconditions
class Preconditions(go.GoClass):
	"""Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_Preconditions_CTor()
			_client.IncRef(self.handle)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.Preconditions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.Preconditions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def ApplyToDelete(self, opts, goRun=False):
		"""ApplyToDelete(object opts) 
		
		ApplyToDelete applies this configuration to the given delete options.
		"""
		_client.client_Preconditions_ApplyToDelete(self.handle, opts.handle, goRun)
	def ApplyToDeleteAllOf(self, opts, goRun=False):
		"""ApplyToDeleteAllOf(object opts) 
		
		ApplyToDeleteAllOf applies this configuration to the given an List options.
		"""
		_client.client_Preconditions_ApplyToDeleteAllOf(self.handle, opts.handle, goRun)

# Python type for struct client.CreateOptions
class CreateOptions(go.GoClass):
	"""CreateOptions contains options for create requests. It's generally a subset\nof metav1.CreateOptions.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_CreateOptions_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.DryRun = args[0]
			if "DryRun" in kwargs:
				self.DryRun = kwargs["DryRun"]
			if  1 < len(args):
				self.FieldManager = args[1]
			if "FieldManager" in kwargs:
				self.FieldManager = kwargs["FieldManager"]
			if  2 < len(args):
				self.FieldValidation = args[2]
			if "FieldValidation" in kwargs:
				self.FieldValidation = kwargs["FieldValidation"]
			if  3 < len(args):
				self.Raw = args[3]
			if "Raw" in kwargs:
				self.Raw = kwargs["Raw"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.CreateOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.CreateOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def DryRun(self):
		"""When present, indicates that modifications should not be
		persisted. An invalid or unrecognized dryRun directive will
		result in an error response and no further processing of the
		request. Valid values are:
		- All: all dry run stages will be processed
		"""
		return go.Slice_string(handle=_client.client_CreateOptions_DryRun_Get(self.handle))
	@DryRun.setter
	def DryRun(self, value):
		if isinstance(value, go.GoClass):
			_client.client_CreateOptions_DryRun_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def FieldManager(self):
		"""FieldManager is the name of the user or component submitting
		this request.  It must be set with server-side apply.
		"""
		return _client.client_CreateOptions_FieldManager_Get(self.handle)
	@FieldManager.setter
	def FieldManager(self, value):
		if isinstance(value, go.GoClass):
			_client.client_CreateOptions_FieldManager_Set(self.handle, value.handle)
		else:
			_client.client_CreateOptions_FieldManager_Set(self.handle, value)
	@property
	def FieldValidation(self):
		"""fieldValidation instructs the server on how to handle
		objects in the request (POST/PUT/PATCH) containing unknown
		or duplicate fields. Valid values are:
		- Ignore: This will ignore any unknown fields that are silently
		dropped from the object, and will ignore all but the last duplicate
		field that the decoder encounters. This is the default behavior
		prior to v1.23.
		- Warn: This will send a warning via the standard warning response
		header for each unknown field that is dropped from the object, and
		for each duplicate field that is encountered. The request will
		still succeed if there are no other errors, and will only persist
		the last of any duplicate fields. This is the default in v1.23+
		- Strict: This will fail the request with a BadRequest error if
		any unknown fields would be dropped from the object, or if any
		duplicate fields are present. The error returned from the server
		will contain all unknown and duplicate fields encountered.
		"""
		return _client.client_CreateOptions_FieldValidation_Get(self.handle)
	@FieldValidation.setter
	def FieldValidation(self, value):
		if isinstance(value, go.GoClass):
			_client.client_CreateOptions_FieldValidation_Set(self.handle, value.handle)
		else:
			_client.client_CreateOptions_FieldValidation_Set(self.handle, value)
	@property
	def Raw(self):
		"""Raw represents raw CreateOptions, as passed to the API server.
		"""
		return go.Ptr_v1_CreateOptions(handle=_client.client_CreateOptions_Raw_Get(self.handle))
	@Raw.setter
	def Raw(self, value):
		if isinstance(value, go.GoClass):
			_client.client_CreateOptions_Raw_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def AsCreateOptions(self):
		"""AsCreateOptions() object
		
		AsCreateOptions returns these options as a metav1.CreateOptions.
		This may mutate the Raw field.
		"""
		return go.Ptr_v1_CreateOptions(handle=_client.client_CreateOptions_AsCreateOptions(self.handle))
	def ApplyOptions(self, opts):
		"""ApplyOptions([]object opts) object
		
		ApplyOptions applies the given create options on these options,
		and then returns itself (for convenient chaining).
		"""
		return CreateOptions(handle=_client.client_CreateOptions_ApplyOptions(self.handle, opts.handle))
	def ApplyToCreate(self, co, goRun=False):
		"""ApplyToCreate(object co) 
		
		ApplyToCreate implements CreateOption.
		"""
		_client.client_CreateOptions_ApplyToCreate(self.handle, co.handle, goRun)

# Python type for struct client.CacheOptions
class CacheOptions(go.GoClass):
	"""CacheOptions are options for creating a cache-backed client.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_CacheOptions_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.Reader = args[0]
			if "Reader" in kwargs:
				self.Reader = kwargs["Reader"]
			if  1 < len(args):
				self.DisableFor = args[1]
			if "DisableFor" in kwargs:
				self.DisableFor = kwargs["DisableFor"]
			if  2 < len(args):
				self.Unstructured = args[2]
			if "Unstructured" in kwargs:
				self.Unstructured = kwargs["Unstructured"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.CacheOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.CacheOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Reader(self):
		"""Reader is a cache-backed reader that will be used to read objects from the cache.
		+required
		"""
		return Reader(handle=_client.client_CacheOptions_Reader_Get(self.handle))
	@Reader.setter
	def Reader(self, value):
		if isinstance(value, go.GoClass):
			_client.client_CacheOptions_Reader_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DisableFor(self):
		"""DisableFor is a list of objects that should never be read from the cache.
		Objects configured here always result in a live lookup.
		"""
		return Slice_client_Object(handle=_client.client_CacheOptions_DisableFor_Get(self.handle))
	@DisableFor.setter
	def DisableFor(self, value):
		if isinstance(value, go.GoClass):
			_client.client_CacheOptions_DisableFor_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Unstructured(self):
		"""Unstructured is a flag that indicates whether the cache-backed client should
		read unstructured objects or lists from the cache.
		If false, unstructured objects will always result in a live lookup.
		"""
		return _client.client_CacheOptions_Unstructured_Get(self.handle)
	@Unstructured.setter
	def Unstructured(self, value):
		if isinstance(value, go.GoClass):
			_client.client_CacheOptions_Unstructured_Set(self.handle, value.handle)
		else:
			_client.client_CacheOptions_Unstructured_Set(self.handle, value)

# Python type for struct client.GetOptions
class GetOptions(go.GoClass):
	"""GetOptions contains options for get operation.\nNow it only has a Raw field, with support for specific resourceVersion.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_GetOptions_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.Raw = args[0]
			if "Raw" in kwargs:
				self.Raw = kwargs["Raw"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.GetOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.GetOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Raw(self):
		"""Raw represents raw GetOptions, as passed to the API server.  Note
		that these may not be respected by all implementations of interface.
		"""
		return go.Ptr_v1_GetOptions(handle=_client.client_GetOptions_Raw_Get(self.handle))
	@Raw.setter
	def Raw(self, value):
		if isinstance(value, go.GoClass):
			_client.client_GetOptions_Raw_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ApplyToGet(self, lo, goRun=False):
		"""ApplyToGet(object lo) 
		
		ApplyToGet implements GetOption for GetOptions.
		"""
		_client.client_GetOptions_ApplyToGet(self.handle, lo.handle, goRun)
	def AsGetOptions(self):
		"""AsGetOptions() object
		
		AsGetOptions returns these options as a flattened metav1.GetOptions.
		This may mutate the Raw field.
		"""
		return go.Ptr_v1_GetOptions(handle=_client.client_GetOptions_AsGetOptions(self.handle))
	def ApplyOptions(self, opts):
		"""ApplyOptions([]object opts) object
		
		ApplyOptions applies the given get options on these options,
		and then returns itself (for convenient chaining).
		"""
		return GetOptions(handle=_client.client_GetOptions_ApplyOptions(self.handle, opts.handle))

# Python type for struct client.ListOptions
class ListOptions(go.GoClass):
	"""ListOptions contains options for limiting or filtering results.\nIt's generally a subset of metav1.ListOptions, with support for\npre-parsed selectors (since generally, selectors will be executed\nagainst the cache).\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_ListOptions_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.LabelSelector = args[0]
			if "LabelSelector" in kwargs:
				self.LabelSelector = kwargs["LabelSelector"]
			if  1 < len(args):
				self.FieldSelector = args[1]
			if "FieldSelector" in kwargs:
				self.FieldSelector = kwargs["FieldSelector"]
			if  2 < len(args):
				self.Namespace = args[2]
			if "Namespace" in kwargs:
				self.Namespace = kwargs["Namespace"]
			if  3 < len(args):
				self.Limit = args[3]
			if "Limit" in kwargs:
				self.Limit = kwargs["Limit"]
			if  4 < len(args):
				self.Continue = args[4]
			if "Continue" in kwargs:
				self.Continue = kwargs["Continue"]
			if  6 < len(args):
				self.Raw = args[6]
			if "Raw" in kwargs:
				self.Raw = kwargs["Raw"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.ListOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.ListOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def LabelSelector(self):
		"""LabelSelector filters results by label. Use labels.Parse() to
		set from raw string form.
		"""
		return go.labels_Selector(handle=_client.client_ListOptions_LabelSelector_Get(self.handle))
	@LabelSelector.setter
	def LabelSelector(self, value):
		if isinstance(value, go.GoClass):
			_client.client_ListOptions_LabelSelector_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def FieldSelector(self):
		"""FieldSelector filters results by a particular field.  In order
		to use this with cache-based implementations, restrict usage to
		exact match field-value pair that's been added to the indexers.
		"""
		return go.fields_Selector(handle=_client.client_ListOptions_FieldSelector_Get(self.handle))
	@FieldSelector.setter
	def FieldSelector(self, value):
		if isinstance(value, go.GoClass):
			_client.client_ListOptions_FieldSelector_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Namespace(self):
		"""Namespace represents the namespace to list for, or empty for
		non-namespaced objects, or to list across all namespaces.
		"""
		return _client.client_ListOptions_Namespace_Get(self.handle)
	@Namespace.setter
	def Namespace(self, value):
		if isinstance(value, go.GoClass):
			_client.client_ListOptions_Namespace_Set(self.handle, value.handle)
		else:
			_client.client_ListOptions_Namespace_Set(self.handle, value)
	@property
	def Limit(self):
		"""Limit specifies the maximum number of results to return from the server. The server may
		not support this field on all resource types, but if it does and more results remain it
		will set the continue field on the returned list object. This field is not supported if watch
		is true in the Raw ListOptions.
		"""
		return _client.client_ListOptions_Limit_Get(self.handle)
	@Limit.setter
	def Limit(self, value):
		if isinstance(value, go.GoClass):
			_client.client_ListOptions_Limit_Set(self.handle, value.handle)
		else:
			_client.client_ListOptions_Limit_Set(self.handle, value)
	@property
	def Continue(self):
		"""Continue is a token returned by the server that lets a client retrieve chunks of results
		from the server by specifying limit. The server may reject requests for continuation tokens
		it does not recognize and will return a 410 error if the token can no longer be used because
		it has expired. This field is not supported if watch is true in the Raw ListOptions.
		"""
		return _client.client_ListOptions_Continue_Get(self.handle)
	@Continue.setter
	def Continue(self, value):
		if isinstance(value, go.GoClass):
			_client.client_ListOptions_Continue_Set(self.handle, value.handle)
		else:
			_client.client_ListOptions_Continue_Set(self.handle, value)
	@property
	def Raw(self):
		"""Raw represents raw ListOptions, as passed to the API server.  Note
		that these may not be respected by all implementations of interface,
		and the LabelSelector, FieldSelector, Limit and Continue fields are ignored.
		"""
		return go.Ptr_v1_ListOptions(handle=_client.client_ListOptions_Raw_Get(self.handle))
	@Raw.setter
	def Raw(self, value):
		if isinstance(value, go.GoClass):
			_client.client_ListOptions_Raw_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ApplyToList(self, lo, goRun=False):
		"""ApplyToList(object lo) 
		
		ApplyToList implements ListOption for ListOptions.
		"""
		_client.client_ListOptions_ApplyToList(self.handle, lo.handle, goRun)
	def AsListOptions(self):
		"""AsListOptions() object
		
		AsListOptions returns these options as a flattened metav1.ListOptions.
		This may mutate the Raw field.
		"""
		return go.Ptr_v1_ListOptions(handle=_client.client_ListOptions_AsListOptions(self.handle))
	def ApplyOptions(self, opts):
		"""ApplyOptions([]object opts) object
		
		ApplyOptions applies the given list options on these options,
		and then returns itself (for convenient chaining).
		"""
		return ListOptions(handle=_client.client_ListOptions_ApplyOptions(self.handle, opts.handle))

# Python type for struct client.MergeFromWithOptimisticLock
class MergeFromWithOptimisticLock(go.GoClass):
	"""MergeFromWithOptimisticLock can be used if clients want to make sure a patch\nis being applied to the latest resource version of an object.\n\nThe behavior is similar to what an Update would do, without the need to send the\nwhole object. Usually this method is useful if you might have multiple clients\nacting on the same object and the same API version, but with different versions of the Go structs.\n\nFor example, an \"older\" copy of a Widget that has fields A and B, and a \"newer\" copy with A, B, and C.\nSending an update using the older struct definition results in C being dropped, whereas using a patch does not.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_MergeFromWithOptimisticLock_CTor()
			_client.IncRef(self.handle)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.MergeFromWithOptimisticLock{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.MergeFromWithOptimisticLock ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def ApplyToMergeFrom(self, myin, goRun=False):
		"""ApplyToMergeFrom(object in) 
		
		ApplyToMergeFrom applies this configuration to the given patch options.
		"""
		_client.client_MergeFromWithOptimisticLock_ApplyToMergeFrom(self.handle, myin.handle, goRun)

# Python type for struct types.NamespacedName
class ObjectKey(go.GoClass):
	"""ObjectKey identifies a Kubernetes Object.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.types_NamespacedName_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.Namespace = args[0]
			if "Namespace" in kwargs:
				self.Namespace = kwargs["Namespace"]
			if  1 < len(args):
				self.Name = args[1]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		return self.String()
	
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'types.NamespacedName ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Namespace(self):
		return _client.types_NamespacedName_Namespace_Get(self.handle)
	@Namespace.setter
	def Namespace(self, value):
		if isinstance(value, go.GoClass):
			_client.types_NamespacedName_Namespace_Set(self.handle, value.handle)
		else:
			_client.types_NamespacedName_Namespace_Set(self.handle, value)
	@property
	def Name(self):
		return _client.types_NamespacedName_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_client.types_NamespacedName_Name_Set(self.handle, value.handle)
		else:
			_client.types_NamespacedName_Name_Set(self.handle, value)
	def String(self):
		"""String() str"""
		return _client.types_NamespacedName_String(self.handle)

# Python type for struct client.PatchOptions
class PatchOptions(go.GoClass):
	"""PatchOptions contains options for patch requests.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_PatchOptions_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.DryRun = args[0]
			if "DryRun" in kwargs:
				self.DryRun = kwargs["DryRun"]
			if  2 < len(args):
				self.FieldManager = args[2]
			if "FieldManager" in kwargs:
				self.FieldManager = kwargs["FieldManager"]
			if  3 < len(args):
				self.FieldValidation = args[3]
			if "FieldValidation" in kwargs:
				self.FieldValidation = kwargs["FieldValidation"]
			if  4 < len(args):
				self.Raw = args[4]
			if "Raw" in kwargs:
				self.Raw = kwargs["Raw"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.PatchOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.PatchOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def DryRun(self):
		"""When present, indicates that modifications should not be
		persisted. An invalid or unrecognized dryRun directive will
		result in an error response and no further processing of the
		request. Valid values are:
		- All: all dry run stages will be processed
		"""
		return go.Slice_string(handle=_client.client_PatchOptions_DryRun_Get(self.handle))
	@DryRun.setter
	def DryRun(self, value):
		if isinstance(value, go.GoClass):
			_client.client_PatchOptions_DryRun_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def FieldManager(self):
		"""FieldManager is the name of the user or component submitting
		this request.  It must be set with server-side apply.
		"""
		return _client.client_PatchOptions_FieldManager_Get(self.handle)
	@FieldManager.setter
	def FieldManager(self, value):
		if isinstance(value, go.GoClass):
			_client.client_PatchOptions_FieldManager_Set(self.handle, value.handle)
		else:
			_client.client_PatchOptions_FieldManager_Set(self.handle, value)
	@property
	def FieldValidation(self):
		"""fieldValidation instructs the server on how to handle
		objects in the request (POST/PUT/PATCH) containing unknown
		or duplicate fields. Valid values are:
		- Ignore: This will ignore any unknown fields that are silently
		dropped from the object, and will ignore all but the last duplicate
		field that the decoder encounters. This is the default behavior
		prior to v1.23.
		- Warn: This will send a warning via the standard warning response
		header for each unknown field that is dropped from the object, and
		for each duplicate field that is encountered. The request will
		still succeed if there are no other errors, and will only persist
		the last of any duplicate fields. This is the default in v1.23+
		- Strict: This will fail the request with a BadRequest error if
		any unknown fields would be dropped from the object, or if any
		duplicate fields are present. The error returned from the server
		will contain all unknown and duplicate fields encountered.
		"""
		return _client.client_PatchOptions_FieldValidation_Get(self.handle)
	@FieldValidation.setter
	def FieldValidation(self, value):
		if isinstance(value, go.GoClass):
			_client.client_PatchOptions_FieldValidation_Set(self.handle, value.handle)
		else:
			_client.client_PatchOptions_FieldValidation_Set(self.handle, value)
	@property
	def Raw(self):
		"""Raw represents raw PatchOptions, as passed to the API server.
		"""
		return go.Ptr_v1_PatchOptions(handle=_client.client_PatchOptions_Raw_Get(self.handle))
	@Raw.setter
	def Raw(self, value):
		if isinstance(value, go.GoClass):
			_client.client_PatchOptions_Raw_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ApplyOptions(self, opts):
		"""ApplyOptions([]object opts) object
		
		ApplyOptions applies the given patch options on these options,
		and then returns itself (for convenient chaining).
		"""
		return PatchOptions(handle=_client.client_PatchOptions_ApplyOptions(self.handle, opts.handle))
	def AsPatchOptions(self):
		"""AsPatchOptions() object
		
		AsPatchOptions returns these options as a metav1.PatchOptions.
		This may mutate the Raw field.
		"""
		return go.Ptr_v1_PatchOptions(handle=_client.client_PatchOptions_AsPatchOptions(self.handle))
	def ApplyToPatch(self, po, goRun=False):
		"""ApplyToPatch(object po) 
		
		ApplyToPatch implements PatchOptions.
		"""
		_client.client_PatchOptions_ApplyToPatch(self.handle, po.handle, goRun)

# Python type for struct client.DeleteAllOfOptions
class DeleteAllOfOptions(ListOptions):
	"""DeleteAllOfOptions contains options for deletecollection (deleteallof) requests.\nIt's just list and delete options smooshed together.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_DeleteAllOfOptions_CTor()
			_client.IncRef(self.handle)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.DeleteAllOfOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.DeleteAllOfOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def ApplyOptions(self, opts):
		"""ApplyOptions([]object opts) object
		
		ApplyOptions applies the given deleteallof options on these options,
		and then returns itself (for convenient chaining).
		"""
		return DeleteAllOfOptions(handle=_client.client_DeleteAllOfOptions_ApplyOptions(self.handle, opts.handle))
	def ApplyToDeleteAllOf(self, do, goRun=False):
		"""ApplyToDeleteAllOf(object do) 
		
		ApplyToDeleteAllOf implements DeleteAllOfOption.
		"""
		_client.client_DeleteAllOfOptions_ApplyToDeleteAllOf(self.handle, do.handle, goRun)

# Python type for struct client.MatchingFieldsSelector
class MatchingFieldsSelector(go.fields_Selector):
	"""MatchingFieldsSelector filters the list/delete operation on the given field\nselector (or index in the case of cached lists). A struct is used because\nfields.Selector is an interface, which cannot be aliased.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_MatchingFieldsSelector_CTor()
			_client.IncRef(self.handle)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.MatchingFieldsSelector{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.MatchingFieldsSelector ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def ApplyToList(self, opts, goRun=False):
		"""ApplyToList(object opts) 
		
		ApplyToList applies this configuration to the given list options.
		"""
		_client.client_MatchingFieldsSelector_ApplyToList(self.handle, opts.handle, goRun)
	def ApplyToDeleteAllOf(self, opts, goRun=False):
		"""ApplyToDeleteAllOf(object opts) 
		
		ApplyToDeleteAllOf applies this configuration to the given an List options.
		"""
		_client.client_MatchingFieldsSelector_ApplyToDeleteAllOf(self.handle, opts.handle, goRun)

# Python type for struct client.DeleteOptions
class DeleteOptions(go.GoClass):
	"""DeleteOptions contains options for delete requests. It's generally a subset\nof metav1.DeleteOptions.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_DeleteOptions_CTor()
			_client.IncRef(self.handle)
			if  1 < len(args):
				self.Preconditions = args[1]
			if "Preconditions" in kwargs:
				self.Preconditions = kwargs["Preconditions"]
			if  3 < len(args):
				self.Raw = args[3]
			if "Raw" in kwargs:
				self.Raw = kwargs["Raw"]
			if  4 < len(args):
				self.DryRun = args[4]
			if "DryRun" in kwargs:
				self.DryRun = kwargs["DryRun"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.DeleteOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.DeleteOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Preconditions(self):
		"""Preconditions must be fulfilled before a deletion is carried out. If not
		possible, a 409 Conflict status will be returned.
		"""
		return go.Ptr_v1_Preconditions(handle=_client.client_DeleteOptions_Preconditions_Get(self.handle))
	@Preconditions.setter
	def Preconditions(self, value):
		if isinstance(value, go.GoClass):
			_client.client_DeleteOptions_Preconditions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Raw(self):
		"""Raw represents raw DeleteOptions, as passed to the API server.
		"""
		return go.Ptr_v1_DeleteOptions(handle=_client.client_DeleteOptions_Raw_Get(self.handle))
	@Raw.setter
	def Raw(self, value):
		if isinstance(value, go.GoClass):
			_client.client_DeleteOptions_Raw_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DryRun(self):
		"""When present, indicates that modifications should not be
		persisted. An invalid or unrecognized dryRun directive will
		result in an error response and no further processing of the
		request. Valid values are:
		- All: all dry run stages will be processed
		"""
		return go.Slice_string(handle=_client.client_DeleteOptions_DryRun_Get(self.handle))
	@DryRun.setter
	def DryRun(self, value):
		if isinstance(value, go.GoClass):
			_client.client_DeleteOptions_DryRun_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def AsDeleteOptions(self):
		"""AsDeleteOptions() object
		
		AsDeleteOptions returns these options as a metav1.DeleteOptions.
		This may mutate the Raw field.
		"""
		return go.Ptr_v1_DeleteOptions(handle=_client.client_DeleteOptions_AsDeleteOptions(self.handle))
	def ApplyOptions(self, opts):
		"""ApplyOptions([]object opts) object
		
		ApplyOptions applies the given delete options on these options,
		and then returns itself (for convenient chaining).
		"""
		return DeleteOptions(handle=_client.client_DeleteOptions_ApplyOptions(self.handle, opts.handle))
	def ApplyToDelete(self, do, goRun=False):
		"""ApplyToDelete(object do) 
		
		ApplyToDelete implements DeleteOption.
		"""
		_client.client_DeleteOptions_ApplyToDelete(self.handle, do.handle, goRun)

# Python type for struct client.MatchingLabelsSelector
class MatchingLabelsSelector(go.labels_Selector):
	"""MatchingLabelsSelector filters the list/delete operation on the given label\nselector (or index in the case of cached lists). A struct is used because\nlabels.Selector is an interface, which cannot be aliased.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_MatchingLabelsSelector_CTor()
			_client.IncRef(self.handle)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.MatchingLabelsSelector{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.MatchingLabelsSelector ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def ApplyToList(self, opts, goRun=False):
		"""ApplyToList(object opts) 
		
		ApplyToList applies this configuration to the given list options.
		"""
		_client.client_MatchingLabelsSelector_ApplyToList(self.handle, opts.handle, goRun)
	def ApplyToDeleteAllOf(self, opts, goRun=False):
		"""ApplyToDeleteAllOf(object opts) 
		
		ApplyToDeleteAllOf applies this configuration to the given an List options.
		"""
		_client.client_MatchingLabelsSelector_ApplyToDeleteAllOf(self.handle, opts.handle, goRun)

# Python type for struct client.Options
class Options(go.GoClass):
	"""Options are creation options for a Client.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_Options_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.HTTPClient = args[0]
			if "HTTPClient" in kwargs:
				self.HTTPClient = kwargs["HTTPClient"]
			if  1 < len(args):
				self.Scheme = args[1]
			if "Scheme" in kwargs:
				self.Scheme = kwargs["Scheme"]
			if  2 < len(args):
				self.Mapper = args[2]
			if "Mapper" in kwargs:
				self.Mapper = kwargs["Mapper"]
			if  3 < len(args):
				self.Cache = args[3]
			if "Cache" in kwargs:
				self.Cache = kwargs["Cache"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.Options{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.Options ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def HTTPClient(self):
		"""HTTPClient is the HTTP client to use for requests.
		"""
		return go.Ptr_http_Client(handle=_client.client_Options_HTTPClient_Get(self.handle))
	@HTTPClient.setter
	def HTTPClient(self, value):
		if isinstance(value, go.GoClass):
			_client.client_Options_HTTPClient_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Scheme(self):
		"""Scheme, if provided, will be used to map go structs to GroupVersionKinds
		"""
		return go.Ptr_runtime_Scheme(handle=_client.client_Options_Scheme_Get(self.handle))
	@Scheme.setter
	def Scheme(self, value):
		if isinstance(value, go.GoClass):
			_client.client_Options_Scheme_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Mapper(self):
		"""Mapper, if provided, will be used to map GroupVersionKinds to Resources
		"""
		return go.meta_RESTMapper(handle=_client.client_Options_Mapper_Get(self.handle))
	@Mapper.setter
	def Mapper(self, value):
		if isinstance(value, go.GoClass):
			_client.client_Options_Mapper_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Cache(self):
		"""Cache, if provided, is used to read objects from the cache.
		"""
		return CacheOptions(handle=_client.client_Options_Cache_Get(self.handle))
	@Cache.setter
	def Cache(self, value):
		if isinstance(value, go.GoClass):
			_client.client_Options_Cache_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct client.SubResourceGetOptions
class SubResourceGetOptions(go.GoClass):
	"""SubResourceGetOptions holds all the possible configuration\nfor a subresource Get request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_SubResourceGetOptions_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.Raw = args[0]
			if "Raw" in kwargs:
				self.Raw = kwargs["Raw"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.SubResourceGetOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.SubResourceGetOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Raw(self):
		return go.Ptr_v1_GetOptions(handle=_client.client_SubResourceGetOptions_Raw_Get(self.handle))
	@Raw.setter
	def Raw(self, value):
		if isinstance(value, go.GoClass):
			_client.client_SubResourceGetOptions_Raw_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ApplyToSubResourceGet(self, o, goRun=False):
		"""ApplyToSubResourceGet(object o) 
		
		ApplyToSubResourceGet updates the configuaration to the given get options.
		"""
		_client.client_SubResourceGetOptions_ApplyToSubResourceGet(self.handle, o.handle, goRun)
	def ApplyOptions(self, opts):
		"""ApplyOptions([]object opts) object
		
		ApplyOptions applues the given options.
		"""
		return SubResourceGetOptions(handle=_client.client_SubResourceGetOptions_ApplyOptions(self.handle, opts.handle))
	def AsGetOptions(self):
		"""AsGetOptions() object
		
		AsGetOptions returns the configured options as *metav1.GetOptions.
		"""
		return go.Ptr_v1_GetOptions(handle=_client.client_SubResourceGetOptions_AsGetOptions(self.handle))

# Python type for struct client.SubResourcePatchOptions
class SubResourcePatchOptions(PatchOptions):
	"""SubResourcePatchOptions holds all possible configurations for a subresource patch\nrequest.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_SubResourcePatchOptions_CTor()
			_client.IncRef(self.handle)
			if  1 < len(args):
				self.SubResourceBody = args[1]
			if "SubResourceBody" in kwargs:
				self.SubResourceBody = kwargs["SubResourceBody"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.SubResourcePatchOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.SubResourcePatchOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def SubResourceBody(self):
		return Object(handle=_client.client_SubResourcePatchOptions_SubResourceBody_Get(self.handle))
	@SubResourceBody.setter
	def SubResourceBody(self, value):
		if isinstance(value, go.GoClass):
			_client.client_SubResourcePatchOptions_SubResourceBody_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ApplyOptions(self, opts):
		"""ApplyOptions([]object opts) object
		
		ApplyOptions applies the given options.
		"""
		return SubResourcePatchOptions(handle=_client.client_SubResourcePatchOptions_ApplyOptions(self.handle, opts.handle))
	def ApplyToSubResourcePatch(self, o, goRun=False):
		"""ApplyToSubResourcePatch(object o) 
		
		ApplyToSubResourcePatch applies the configuration on the given patch options.
		"""
		_client.client_SubResourcePatchOptions_ApplyToSubResourcePatch(self.handle, o.handle, goRun)

# Python type for struct client.UpdateOptions
class UpdateOptions(go.GoClass):
	"""UpdateOptions contains options for create requests. It's generally a subset\nof metav1.UpdateOptions.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_UpdateOptions_CTor()
			_client.IncRef(self.handle)
			if  0 < len(args):
				self.DryRun = args[0]
			if "DryRun" in kwargs:
				self.DryRun = kwargs["DryRun"]
			if  1 < len(args):
				self.FieldManager = args[1]
			if "FieldManager" in kwargs:
				self.FieldManager = kwargs["FieldManager"]
			if  2 < len(args):
				self.FieldValidation = args[2]
			if "FieldValidation" in kwargs:
				self.FieldValidation = kwargs["FieldValidation"]
			if  3 < len(args):
				self.Raw = args[3]
			if "Raw" in kwargs:
				self.Raw = kwargs["Raw"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.UpdateOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.UpdateOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def DryRun(self):
		"""When present, indicates that modifications should not be
		persisted. An invalid or unrecognized dryRun directive will
		result in an error response and no further processing of the
		request. Valid values are:
		- All: all dry run stages will be processed
		"""
		return go.Slice_string(handle=_client.client_UpdateOptions_DryRun_Get(self.handle))
	@DryRun.setter
	def DryRun(self, value):
		if isinstance(value, go.GoClass):
			_client.client_UpdateOptions_DryRun_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def FieldManager(self):
		"""FieldManager is the name of the user or component submitting
		this request.  It must be set with server-side apply.
		"""
		return _client.client_UpdateOptions_FieldManager_Get(self.handle)
	@FieldManager.setter
	def FieldManager(self, value):
		if isinstance(value, go.GoClass):
			_client.client_UpdateOptions_FieldManager_Set(self.handle, value.handle)
		else:
			_client.client_UpdateOptions_FieldManager_Set(self.handle, value)
	@property
	def FieldValidation(self):
		"""fieldValidation instructs the server on how to handle
		objects in the request (POST/PUT/PATCH) containing unknown
		or duplicate fields. Valid values are:
		- Ignore: This will ignore any unknown fields that are silently
		dropped from the object, and will ignore all but the last duplicate
		field that the decoder encounters. This is the default behavior
		prior to v1.23.
		- Warn: This will send a warning via the standard warning response
		header for each unknown field that is dropped from the object, and
		for each duplicate field that is encountered. The request will
		still succeed if there are no other errors, and will only persist
		the last of any duplicate fields. This is the default in v1.23+
		- Strict: This will fail the request with a BadRequest error if
		any unknown fields would be dropped from the object, or if any
		duplicate fields are present. The error returned from the server
		will contain all unknown and duplicate fields encountered.
		"""
		return _client.client_UpdateOptions_FieldValidation_Get(self.handle)
	@FieldValidation.setter
	def FieldValidation(self, value):
		if isinstance(value, go.GoClass):
			_client.client_UpdateOptions_FieldValidation_Set(self.handle, value.handle)
		else:
			_client.client_UpdateOptions_FieldValidation_Set(self.handle, value)
	@property
	def Raw(self):
		"""Raw represents raw UpdateOptions, as passed to the API server.
		"""
		return go.Ptr_v1_UpdateOptions(handle=_client.client_UpdateOptions_Raw_Get(self.handle))
	@Raw.setter
	def Raw(self, value):
		if isinstance(value, go.GoClass):
			_client.client_UpdateOptions_Raw_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def AsUpdateOptions(self):
		"""AsUpdateOptions() object
		
		AsUpdateOptions returns these options as a metav1.UpdateOptions.
		This may mutate the Raw field.
		"""
		return go.Ptr_v1_UpdateOptions(handle=_client.client_UpdateOptions_AsUpdateOptions(self.handle))
	def ApplyOptions(self, opts):
		"""ApplyOptions([]object opts) object
		
		ApplyOptions applies the given update options on these options,
		and then returns itself (for convenient chaining).
		"""
		return UpdateOptions(handle=_client.client_UpdateOptions_ApplyOptions(self.handle, opts.handle))
	def ApplyToUpdate(self, uo, goRun=False):
		"""ApplyToUpdate(object uo) 
		
		ApplyToUpdate implements UpdateOption.
		"""
		_client.client_UpdateOptions_ApplyToUpdate(self.handle, uo.handle, goRun)

# Python type for struct client.SubResourceUpdateOptions
class SubResourceUpdateOptions(UpdateOptions):
	"""SubResourceUpdateOptions holds all the possible configuration\nfor a subresource update request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_SubResourceUpdateOptions_CTor()
			_client.IncRef(self.handle)
			if  1 < len(args):
				self.SubResourceBody = args[1]
			if "SubResourceBody" in kwargs:
				self.SubResourceBody = kwargs["SubResourceBody"]
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.SubResourceUpdateOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.SubResourceUpdateOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def SubResourceBody(self):
		return Object(handle=_client.client_SubResourceUpdateOptions_SubResourceBody_Get(self.handle))
	@SubResourceBody.setter
	def SubResourceBody(self, value):
		if isinstance(value, go.GoClass):
			_client.client_SubResourceUpdateOptions_SubResourceBody_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def ApplyToSubResourceUpdate(self, o, goRun=False):
		"""ApplyToSubResourceUpdate(object o) 
		
		ApplyToSubResourceUpdate updates the configuration on the given create options
		"""
		_client.client_SubResourceUpdateOptions_ApplyToSubResourceUpdate(self.handle, o.handle, goRun)
	def ApplyOptions(self, opts):
		"""ApplyOptions([]object opts) object
		
		ApplyOptions applies the given options.
		"""
		return SubResourceUpdateOptions(handle=_client.client_SubResourceUpdateOptions_ApplyOptions(self.handle, opts.handle))

# Python type for struct client.SubResourceCreateOptions
class SubResourceCreateOptions(CreateOptions):
	"""SubResourceCreateOptions are all the possible configurations for a subresource\ncreate request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_SubResourceCreateOptions_CTor()
			_client.IncRef(self.handle)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.SubResourceCreateOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'client.SubResourceCreateOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def ApplyOptions(self, opts):
		"""ApplyOptions([]object opts) object
		
		ApplyOptions applies the given options.
		"""
		return SubResourceCreateOptions(handle=_client.client_SubResourceCreateOptions_ApplyOptions(self.handle, opts.handle))
	def ApplyToSubResourceCreate(self, o, goRun=False):
		"""ApplyToSubResourceCreate(object o) 
		
		ApplyToSubResourceCreate applies the the configuration on the given create options.
		"""
		_client.client_SubResourceCreateOptions_ApplyToSubResourceCreate(self.handle, o.handle, goRun)


# ---- Slices ---

# Python type for slice client.HasLabels
class HasLabels(go.GoClass):
	"""HasLabels filters the list/delete operation checking if the set of labels exists\nwithout checking their values.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_HasLabels_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('client_HasLabels.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.client_HasLabels len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'client.client_HasLabels([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.client_HasLabels_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.client_HasLabels_len(self.handle)
				return HasLabels(handle=_client.client_HasLabels_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _client.client_HasLabels_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.client_HasLabels_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('client_HasLabels.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _client.client_HasLabels_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.client_HasLabels_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]
	def ApplyToList(self, opts, goRun=False):
		"""ApplyToList(object opts) 
		
		ApplyToList applies this configuration to the given list options.
		"""
		_client.client_HasLabels_ApplyToList(self.handle, opts.handle, goRun)
	def ApplyToDeleteAllOf(self, opts, goRun=False):
		"""ApplyToDeleteAllOf(object opts) 
		
		ApplyToDeleteAllOf applies this configuration to the given an List options.
		"""
		_client.client_HasLabels_ApplyToDeleteAllOf(self.handle, opts.handle, goRun)


# ---- Maps ---

# Python type for map client.MatchingFields
class MatchingFields(go.GoClass):
	"""MatchingFields filters the list/delete operation on the given field Set\n(or index in the case of cached lists).\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_MatchingFields_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('client_MatchingFields.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_client.client_MatchingFields_set(self.handle, k, v)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.client_MatchingFields len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'client.client_MatchingFields({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _client.client_MatchingFields_len(self.handle)
	def __getitem__(self, key):
		return _client.client_MatchingFields_elem(self.handle, key)
	def __setitem__(self, key, value):
		_client.client_MatchingFields_set(self.handle, key, value)
	def __delitem__(self, key):
		return _client.client_MatchingFields_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_client.client_MatchingFields_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _client.client_MatchingFields_contains(self.handle, key)
	def ApplyToList(self, opts, goRun=False):
		"""ApplyToList(object opts) 
		
		ApplyToList applies this configuration to the given list options.
		"""
		_client.client_MatchingFields_ApplyToList(self.handle, opts.handle, goRun)
	def ApplyToDeleteAllOf(self, opts, goRun=False):
		"""ApplyToDeleteAllOf(object opts) 
		
		ApplyToDeleteAllOf applies this configuration to the given an List options.
		"""
		_client.client_MatchingFields_ApplyToDeleteAllOf(self.handle, opts.handle, goRun)

# Python type for map client.MatchingLabels
class MatchingLabels(go.GoClass):
	"""MatchingLabels filters the list/delete operation on the given set of labels.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.client_MatchingLabels_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('client_MatchingLabels.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_client.client_MatchingLabels_set(self.handle, k, v)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.client_MatchingLabels len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'client.client_MatchingLabels({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _client.client_MatchingLabels_len(self.handle)
	def __getitem__(self, key):
		return _client.client_MatchingLabels_elem(self.handle, key)
	def __setitem__(self, key, value):
		_client.client_MatchingLabels_set(self.handle, key, value)
	def __delitem__(self, key):
		return _client.client_MatchingLabels_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_client.client_MatchingLabels_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _client.client_MatchingLabels_contains(self.handle, key)
	def ApplyToList(self, opts, goRun=False):
		"""ApplyToList(object opts) 
		
		ApplyToList applies this configuration to the given list options.
		"""
		_client.client_MatchingLabels_ApplyToList(self.handle, opts.handle, goRun)
	def ApplyToDeleteAllOf(self, opts, goRun=False):
		"""ApplyToDeleteAllOf(object opts) 
		
		ApplyToDeleteAllOf applies this configuration to the given an List options.
		"""
		_client.client_MatchingLabels_ApplyToDeleteAllOf(self.handle, opts.handle, goRun)


# ---- Constructors ---
def ObjectKeyFromObject(obj):
	"""ObjectKeyFromObject(object obj) object
	
	ObjectKeyFromObject returns the ObjectKey given a runtime.Object.
	"""
	return go.types_NamespacedName(handle=_client.client_ObjectKeyFromObject(obj.handle))


# ---- Functions ---
def NewNamespacedClient(c, ns):
	"""NewNamespacedClient(object c, str ns) object
	
	NewNamespacedClient wraps an existing client enforcing the namespace value.
	All functions using this client will have the same namespace declared here.
	"""
	return Client(handle=_client.client_NewNamespacedClient(c.handle, ns))
def NewWithWatch(config, options):
	"""NewWithWatch(object config, object options) object, str"""
	return WithWatch(handle=_client.client_NewWithWatch(config.handle, options.handle))
def IgnoreAlreadyExists(err):
	"""IgnoreAlreadyExists(str err) str
	
	IgnoreAlreadyExists returns nil on AlreadyExists errors.
	All other values that are not AlreadyExists errors or nil are returned unmodified.
	"""
	return _client.client_IgnoreAlreadyExists(err)
def MergeFrom(obj):
	"""MergeFrom(object obj) object
	
	MergeFrom creates a Patch that patches using the merge-patch strategy with the given object as base.
	The difference between MergeFrom and StrategicMergeFrom lays in the handling of modified list fields.
	When using MergeFrom, existing lists will be completely replaced by new lists.
	When using StrategicMergeFrom, the list field's `patchStrategy` is respected if specified in the API type,
	e.g. the existing list is not replaced completely but rather merged with the new one using the list's `patchMergeKey`.
	See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/ for more details on
	the difference between merge-patch and strategic-merge-patch.
	"""
	return Patch(handle=_client.client_MergeFrom(obj.handle))
def RawPatch(patchType, data):
	"""RawPatch(str patchType, []int data) object
	
	RawPatch constructs a new Patch with the given PatchType and data.
	"""
	return Patch(handle=_client.client_RawPatch(patchType, data.handle))
def StrategicMergeFrom(obj, *args):
	"""StrategicMergeFrom(object obj, []object opts) object
	
	StrategicMergeFrom creates a Patch that patches using the strategic-merge-patch strategy with the given object as base.
	The difference between MergeFrom and StrategicMergeFrom lays in the handling of modified list fields.
	When using MergeFrom, existing lists will be completely replaced by new lists.
	When using StrategicMergeFrom, the list field's `patchStrategy` is respected if specified in the API type,
	e.g. the existing list is not replaced completely but rather merged with the new one using the list's `patchMergeKey`.
	See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/ for more details on
	the difference between merge-patch and strategic-merge-patch.
	Please note, that CRDs don't support strategic-merge-patch, see
	https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#advanced-features-and-flexibility
	"""
	opts = Slice_client_MergeFromOption(args)
	return Patch(handle=_client.client_StrategicMergeFrom(obj.handle, opts.handle))
def WithFieldValidation(c, validation):
	"""WithFieldValidation(object c, str validation) object
	
	WithFieldValidation wraps a Client and configures field validation, by
	default, for all write requests from this client. Users can override field
	validation for individual write requests.
	"""
	return Client(handle=_client.client_WithFieldValidation(c.handle, validation))
def WithSubResourceBody(body):
	"""WithSubResourceBody(object body) object
	
	WithSubResourceBody returns an option that uses the given body
	for a subresource Update or Patch operation.
	"""
	return SubResourceUpdateAndPatchOption(handle=_client.client_WithSubResourceBody(body.handle))
def IgnoreNotFound(err):
	"""IgnoreNotFound(str err) str
	
	IgnoreNotFound returns nil on NotFound errors.
	All other values that are not NotFound errors or nil are returned unmodified.
	"""
	return _client.client_IgnoreNotFound(err)
def MergeFromWithOptions(obj, *args):
	"""MergeFromWithOptions(object obj, []object opts) object
	
	MergeFromWithOptions creates a Patch that patches using the merge-patch strategy with the given object as base.
	See MergeFrom for more details.
	"""
	opts = Slice_client_MergeFromOption(args)
	return Patch(handle=_client.client_MergeFromWithOptions(obj.handle, opts.handle))
def New(config, options):
	"""New(object config, object options) object c, str err"""
	return Client(handle=_client.client_New(config.handle, options.handle))
def NewDryRunClient(c):
	"""NewDryRunClient(object c) object
	
	NewDryRunClient wraps an existing client and enforces DryRun mode
	on all mutating api calls.
	"""
	return Client(handle=_client.client_NewDryRunClient(c.handle))
def WithFieldOwner(c, fieldOwner):
	"""WithFieldOwner(object c, str fieldOwner) object
	
	WithFieldOwner wraps a Client and adds the fieldOwner as the field
	manager to all write requests from this client. If additional [FieldOwner]
	options are specified on methods of this client, the value specified here
	will be overridden.
	"""
	return Client(handle=_client.client_WithFieldOwner(c.handle, fieldOwner))


