/*
cgo stubs for package client.
File is generated by gopy. Do not edit.
gopy pkg sigs.k8s.io/controller-runtime/pkg/client
*/

package main

/*

#cgo CFLAGS: "-I/usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/include/python3.11" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/lib" "-lpython3.11" -ldl  -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"context"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding"
	"encoding/asn1"
	"flag"
	"fmt"
	"io"
	"math/big"
	"math/rand"
	"mime/multipart"
	"net"
	"net/http"
	"net/textproto"
	"net/url"
	"reflect"
	"time"

	"github.com/gogo/protobuf/proto"
	fuzz "github.com/google/gofuzz"
	"k8s.io/apimachinery/pkg/api/meta"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/conversion"
	"k8s.io/apimachinery/pkg/fields"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/testing"
	"k8s.io/client-go/tools/clientcmd/api"
	"k8s.io/client-go/transport"
	"k8s.io/client-go/util/flowcontrol"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/apiutil"
	"sigs.k8s.io/controller-runtime/pkg/client/config"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
	"sigs.k8s.io/controller-runtime/pkg/client/interceptor"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: client below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *tls.ConnectionState
func ptrFromHandle_Ptr_tls_ConnectionState(h CGoHandle) *tls.ConnectionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tls.ConnectionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.ConnectionState{})).(*tls.ConnectionState)
}
func handleFromPtr_Ptr_tls_ConnectionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tls.ConnectionState", p))
}

// Converters for pointer handles for type: *x509.CertPool
func ptrFromHandle_Ptr_x509_CertPool(h CGoHandle) *x509.CertPool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*x509.CertPool")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.CertPool{})).(*x509.CertPool)
}
func handleFromPtr_Ptr_x509_CertPool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*x509.CertPool", p))
}

// Converters for pointer handles for type: *x509.Certificate
func ptrFromHandle_Ptr_x509_Certificate(h CGoHandle) *x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*x509.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.Certificate{})).(*x509.Certificate)
}
func handleFromPtr_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*x509.Certificate", p))
}

// Converters for pointer handles for type: *pkix.CertificateList
func ptrFromHandle_Ptr_pkix_CertificateList(h CGoHandle) *pkix.CertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pkix.CertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.CertificateList{})).(*pkix.CertificateList)
}
func handleFromPtr_Ptr_pkix_CertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pkix.CertificateList", p))
}

// Converters for pointer handles for type: *pkix.RDNSequence
func ptrFromHandle_Ptr_pkix_RDNSequence(h CGoHandle) *pkix.RDNSequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pkix.RDNSequence")
	if p == nil {
		return nil
	}
	return p.(*pkix.RDNSequence)
}
func handleFromPtr_Ptr_pkix_RDNSequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pkix.RDNSequence", p))
}

// Converters for pointer handles for type: *flag.Flag
func ptrFromHandle_Ptr_flag_Flag(h CGoHandle) *flag.Flag {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*flag.Flag")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(flag.Flag{})).(*flag.Flag)
}
func handleFromPtr_Ptr_flag_Flag(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*flag.Flag", p))
}

// Converters for pointer handles for type: *flag.FlagSet
func ptrFromHandle_Ptr_flag_FlagSet(h CGoHandle) *flag.FlagSet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*flag.FlagSet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(flag.FlagSet{})).(*flag.FlagSet)
}
func handleFromPtr_Ptr_flag_FlagSet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*flag.FlagSet", p))
}

// Converters for pointer handles for type: *v1.CreateOptions
func ptrFromHandle_Ptr_v1_CreateOptions(h CGoHandle) *v1.CreateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.CreateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.CreateOptions{})).(*v1.CreateOptions)
}
func handleFromPtr_Ptr_v1_CreateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.CreateOptions", p))
}

// Converters for pointer handles for type: *v1.DeleteOptions
func ptrFromHandle_Ptr_v1_DeleteOptions(h CGoHandle) *v1.DeleteOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.DeleteOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.DeleteOptions{})).(*v1.DeleteOptions)
}
func handleFromPtr_Ptr_v1_DeleteOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.DeleteOptions", p))
}

// Converters for pointer handles for type: *v1.DeletionPropagation
func ptrFromHandle_Ptr_v1_DeletionPropagation(h CGoHandle) *v1.DeletionPropagation {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.DeletionPropagation")
	if p == nil {
		return nil
	}
	return p.(*v1.DeletionPropagation)
}
func handleFromPtr_Ptr_v1_DeletionPropagation(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.DeletionPropagation", p))
}

// Converters for pointer handles for type: *v1.FieldsV1
func ptrFromHandle_Ptr_v1_FieldsV1(h CGoHandle) *v1.FieldsV1 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.FieldsV1")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.FieldsV1{})).(*v1.FieldsV1)
}
func handleFromPtr_Ptr_v1_FieldsV1(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.FieldsV1", p))
}

// Converters for pointer handles for type: *v1.GetOptions
func ptrFromHandle_Ptr_v1_GetOptions(h CGoHandle) *v1.GetOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.GetOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.GetOptions{})).(*v1.GetOptions)
}
func handleFromPtr_Ptr_v1_GetOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.GetOptions", p))
}

// Converters for pointer handles for type: *v1.ListOptions
func ptrFromHandle_Ptr_v1_ListOptions(h CGoHandle) *v1.ListOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.ListOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.ListOptions{})).(*v1.ListOptions)
}
func handleFromPtr_Ptr_v1_ListOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.ListOptions", p))
}

// Converters for pointer handles for type: *v1.ManagedFieldsEntry
func ptrFromHandle_Ptr_v1_ManagedFieldsEntry(h CGoHandle) *v1.ManagedFieldsEntry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.ManagedFieldsEntry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.ManagedFieldsEntry{})).(*v1.ManagedFieldsEntry)
}
func handleFromPtr_Ptr_v1_ManagedFieldsEntry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.ManagedFieldsEntry", p))
}

// Converters for pointer handles for type: *v1.OwnerReference
func ptrFromHandle_Ptr_v1_OwnerReference(h CGoHandle) *v1.OwnerReference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.OwnerReference")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.OwnerReference{})).(*v1.OwnerReference)
}
func handleFromPtr_Ptr_v1_OwnerReference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.OwnerReference", p))
}

// Converters for pointer handles for type: *v1.PatchOptions
func ptrFromHandle_Ptr_v1_PatchOptions(h CGoHandle) *v1.PatchOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.PatchOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.PatchOptions{})).(*v1.PatchOptions)
}
func handleFromPtr_Ptr_v1_PatchOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.PatchOptions", p))
}

// Converters for pointer handles for type: *v1.Preconditions
func ptrFromHandle_Ptr_v1_Preconditions(h CGoHandle) *v1.Preconditions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.Preconditions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Preconditions{})).(*v1.Preconditions)
}
func handleFromPtr_Ptr_v1_Preconditions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.Preconditions", p))
}

// Converters for pointer handles for type: *v1.Time
func ptrFromHandle_Ptr_v1_Time(h CGoHandle) *v1.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Time{})).(*v1.Time)
}
func handleFromPtr_Ptr_v1_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.Time", p))
}

// Converters for pointer handles for type: *v1.Timestamp
func ptrFromHandle_Ptr_v1_Timestamp(h CGoHandle) *v1.Timestamp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.Timestamp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Timestamp{})).(*v1.Timestamp)
}
func handleFromPtr_Ptr_v1_Timestamp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.Timestamp", p))
}

// Converters for pointer handles for type: *v1.UpdateOptions
func ptrFromHandle_Ptr_v1_UpdateOptions(h CGoHandle) *v1.UpdateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*v1.UpdateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.UpdateOptions{})).(*v1.UpdateOptions)
}
func handleFromPtr_Ptr_v1_UpdateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*v1.UpdateOptions", p))
}

// Converters for pointer handles for type: *conversion.Converter
func ptrFromHandle_Ptr_conversion_Converter(h CGoHandle) *conversion.Converter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*conversion.Converter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Converter{})).(*conversion.Converter)
}
func handleFromPtr_Ptr_conversion_Converter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*conversion.Converter", p))
}

// Converters for pointer handles for type: *conversion.Meta
func ptrFromHandle_Ptr_conversion_Meta(h CGoHandle) *conversion.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*conversion.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Meta{})).(*conversion.Meta)
}
func handleFromPtr_Ptr_conversion_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*conversion.Meta", p))
}

// Converters for pointer handles for type: *runtime.Scheme
func ptrFromHandle_Ptr_runtime_Scheme(h CGoHandle) *runtime.Scheme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*runtime.Scheme")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.Scheme{})).(*runtime.Scheme)
}
func handleFromPtr_Ptr_runtime_Scheme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*runtime.Scheme", p))
}

// Converters for pointer handles for type: *runtime.StreamSerializerInfo
func ptrFromHandle_Ptr_runtime_StreamSerializerInfo(h CGoHandle) *runtime.StreamSerializerInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*runtime.StreamSerializerInfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.StreamSerializerInfo{})).(*runtime.StreamSerializerInfo)
}
func handleFromPtr_Ptr_runtime_StreamSerializerInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*runtime.StreamSerializerInfo", p))
}

// Converters for pointer handles for type: *types.NamespacedName
func ptrFromHandle_Ptr_types_NamespacedName(h CGoHandle) *types.NamespacedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*types.NamespacedName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(types.NamespacedName{})).(*types.NamespacedName)
}
func handleFromPtr_Ptr_types_NamespacedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*types.NamespacedName", p))
}

// Converters for pointer handles for type: *types.UID
func ptrFromHandle_Ptr_types_UID(h CGoHandle) *types.UID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*types.UID")
	if p == nil {
		return nil
	}
	return p.(*types.UID)
}
func handleFromPtr_Ptr_types_UID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*types.UID", p))
}

// Converters for pointer handles for type: *rest.Config
func ptrFromHandle_Ptr_rest_Config(h CGoHandle) *rest.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.Config{})).(*rest.Config)
}
func handleFromPtr_Ptr_rest_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.Config", p))
}

// Converters for pointer handles for type: *api.AuthProviderConfig
func ptrFromHandle_Ptr_api_AuthProviderConfig(h CGoHandle) *api.AuthProviderConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.AuthProviderConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.AuthProviderConfig{})).(*api.AuthProviderConfig)
}
func handleFromPtr_Ptr_api_AuthProviderConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.AuthProviderConfig", p))
}

// Converters for pointer handles for type: *api.ExecConfig
func ptrFromHandle_Ptr_api_ExecConfig(h CGoHandle) *api.ExecConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.ExecConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecConfig{})).(*api.ExecConfig)
}
func handleFromPtr_Ptr_api_ExecConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.ExecConfig", p))
}

// Converters for pointer handles for type: *api.ExecEnvVar
func ptrFromHandle_Ptr_api_ExecEnvVar(h CGoHandle) *api.ExecEnvVar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.ExecEnvVar")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecEnvVar{})).(*api.ExecEnvVar)
}
func handleFromPtr_Ptr_api_ExecEnvVar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.ExecEnvVar", p))
}

// Converters for pointer handles for type: *transport.Config
func ptrFromHandle_Ptr_transport_Config(h CGoHandle) *transport.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*transport.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.Config{})).(*transport.Config)
}
func handleFromPtr_Ptr_transport_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*transport.Config", p))
}

// Converters for pointer handles for type: *transport.DialHolder
func ptrFromHandle_Ptr_transport_DialHolder(h CGoHandle) *transport.DialHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*transport.DialHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.DialHolder{})).(*transport.DialHolder)
}
func handleFromPtr_Ptr_transport_DialHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*transport.DialHolder", p))
}

// Converters for pointer handles for type: *transport.GetCertHolder
func ptrFromHandle_Ptr_transport_GetCertHolder(h CGoHandle) *transport.GetCertHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*transport.GetCertHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.GetCertHolder{})).(*transport.GetCertHolder)
}
func handleFromPtr_Ptr_transport_GetCertHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*transport.GetCertHolder", p))
}

// Converters for pointer handles for type: *big.Int
func ptrFromHandle_Ptr_big_Int(h CGoHandle) *big.Int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*big.Int")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(big.Int{})).(*big.Int)
}
func handleFromPtr_Ptr_big_Int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*big.Int", p))
}

// Converters for pointer handles for type: *rand.Rand
func ptrFromHandle_Ptr_rand_Rand(h CGoHandle) *rand.Rand {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rand.Rand")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rand.Rand{})).(*rand.Rand)
}
func handleFromPtr_Ptr_rand_Rand(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rand.Rand", p))
}

// Converters for pointer handles for type: *multipart.FileHeader
func ptrFromHandle_Ptr_multipart_FileHeader(h CGoHandle) *multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.FileHeader{})).(*multipart.FileHeader)
}
func handleFromPtr_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.FileHeader", p))
}

// Converters for pointer handles for type: *multipart.Form
func ptrFromHandle_Ptr_multipart_Form(h CGoHandle) *multipart.Form {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Form")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Form{})).(*multipart.Form)
}
func handleFromPtr_Ptr_multipart_Form(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Form", p))
}

// Converters for pointer handles for type: *multipart.Part
func ptrFromHandle_Ptr_multipart_Part(h CGoHandle) *multipart.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Part{})).(*multipart.Part)
}
func handleFromPtr_Ptr_multipart_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Part", p))
}

// Converters for pointer handles for type: *multipart.Reader
func ptrFromHandle_Ptr_multipart_Reader(h CGoHandle) *multipart.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Reader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Reader{})).(*multipart.Reader)
}
func handleFromPtr_Ptr_multipart_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Reader", p))
}

// Converters for pointer handles for type: *net.IPNet
func ptrFromHandle_Ptr_net_IPNet(h CGoHandle) *net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*net.IPNet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.IPNet{})).(*net.IPNet)
}
func handleFromPtr_Ptr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*net.IPNet", p))
}

// Converters for pointer handles for type: *http.Client
func ptrFromHandle_Ptr_http_Client(h CGoHandle) *http.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Client{})).(*http.Client)
}
func handleFromPtr_Ptr_http_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Client", p))
}

// Converters for pointer handles for type: *http.Cookie
func ptrFromHandle_Ptr_http_Cookie(h CGoHandle) *http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Cookie")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Cookie{})).(*http.Cookie)
}
func handleFromPtr_Ptr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Cookie", p))
}

// Converters for pointer handles for type: *http.Request
func ptrFromHandle_Ptr_http_Request(h CGoHandle) *http.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Request{})).(*http.Request)
}
func handleFromPtr_Ptr_http_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Request", p))
}

// Converters for pointer handles for type: *http.Response
func ptrFromHandle_Ptr_http_Response(h CGoHandle) *http.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Response{})).(*http.Response)
}
func handleFromPtr_Ptr_http_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Response", p))
}

// Converters for pointer handles for type: *url.URL
func ptrFromHandle_Ptr_url_URL(h CGoHandle) *url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*url.URL")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.URL{})).(*url.URL)
}
func handleFromPtr_Ptr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*url.URL", p))
}

// Converters for pointer handles for type: *url.Userinfo
func ptrFromHandle_Ptr_url_Userinfo(h CGoHandle) *url.Userinfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*url.Userinfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.Userinfo{})).(*url.Userinfo)
}
func handleFromPtr_Ptr_url_Userinfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*url.Userinfo", p))
}

// Converters for pointer handles for type: *time.Duration
func ptrFromHandle_Ptr_time_Duration(h CGoHandle) *time.Duration {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Duration")
	if p == nil {
		return nil
	}
	return p.(*time.Duration)
}
func handleFromPtr_Ptr_time_Duration(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Duration", p))
}

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for pointer handles for type: context.Context
func ptrFromHandle_context_Context(h CGoHandle) context.Context {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "context.Context")
	if p == nil {
		return nil
	}
	return p.(context.Context)
}
func handleFromPtr_context_Context(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("context.Context", p))
}

// Converters for non-pointer handles for type: tls.ConnectionState
func ptrFromHandle_tls_ConnectionState(h CGoHandle) *tls.ConnectionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tls.ConnectionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.ConnectionState{})).(*tls.ConnectionState)
}
func handleFromPtr_tls_ConnectionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tls.ConnectionState", p))
}

// Converters for non-pointer handles for type: x509.CertPool
func ptrFromHandle_x509_CertPool(h CGoHandle) *x509.CertPool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.CertPool")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.CertPool{})).(*x509.CertPool)
}
func handleFromPtr_x509_CertPool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.CertPool", p))
}

// Converters for non-pointer handles for type: x509.Certificate
func ptrFromHandle_x509_Certificate(h CGoHandle) *x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.Certificate{})).(*x509.Certificate)
}
func handleFromPtr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.Certificate", p))
}

// Converters for non-pointer handles for type: x509.OID
func ptrFromHandle_x509_OID(h CGoHandle) *x509.OID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.OID")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.OID{})).(*x509.OID)
}
func handleFromPtr_x509_OID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.OID", p))
}

// Converters for non-pointer handles for type: x509.VerifyOptions
func ptrFromHandle_x509_VerifyOptions(h CGoHandle) *x509.VerifyOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.VerifyOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.VerifyOptions{})).(*x509.VerifyOptions)
}
func handleFromPtr_x509_VerifyOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.VerifyOptions", p))
}

// Converters for non-pointer handles for type: pkix.AlgorithmIdentifier
func ptrFromHandle_pkix_AlgorithmIdentifier(h CGoHandle) *pkix.AlgorithmIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.AlgorithmIdentifier")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.AlgorithmIdentifier{})).(*pkix.AlgorithmIdentifier)
}
func handleFromPtr_pkix_AlgorithmIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.AlgorithmIdentifier", p))
}

// Converters for non-pointer handles for type: pkix.AttributeTypeAndValue
func ptrFromHandle_pkix_AttributeTypeAndValue(h CGoHandle) *pkix.AttributeTypeAndValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.AttributeTypeAndValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.AttributeTypeAndValue{})).(*pkix.AttributeTypeAndValue)
}
func handleFromPtr_pkix_AttributeTypeAndValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.AttributeTypeAndValue", p))
}

// Converters for non-pointer handles for type: pkix.CertificateList
func ptrFromHandle_pkix_CertificateList(h CGoHandle) *pkix.CertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.CertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.CertificateList{})).(*pkix.CertificateList)
}
func handleFromPtr_pkix_CertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.CertificateList", p))
}

// Converters for non-pointer handles for type: pkix.Extension
func ptrFromHandle_pkix_Extension(h CGoHandle) *pkix.Extension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.Extension")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.Extension{})).(*pkix.Extension)
}
func handleFromPtr_pkix_Extension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.Extension", p))
}

// Converters for non-pointer handles for type: pkix.Name
func ptrFromHandle_pkix_Name(h CGoHandle) *pkix.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.Name")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.Name{})).(*pkix.Name)
}
func handleFromPtr_pkix_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.Name", p))
}

// Converters for implicit pointer handles for type: pkix.RDNSequence
func ptrFromHandle_pkix_RDNSequence(h CGoHandle) *pkix.RDNSequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RDNSequence")
	if p == nil {
		return nil
	}
	return p.(*pkix.RDNSequence)
}
func deptrFromHandle_pkix_RDNSequence(h CGoHandle) pkix.RDNSequence {
	p := ptrFromHandle_pkix_RDNSequence(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_pkix_RDNSequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RDNSequence", p))
}

// Converters for implicit pointer handles for type: pkix.RelativeDistinguishedNameSET
func ptrFromHandle_pkix_RelativeDistinguishedNameSET(h CGoHandle) *pkix.RelativeDistinguishedNameSET {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RelativeDistinguishedNameSET")
	if p == nil {
		return nil
	}
	return p.(*pkix.RelativeDistinguishedNameSET)
}
func deptrFromHandle_pkix_RelativeDistinguishedNameSET(h CGoHandle) pkix.RelativeDistinguishedNameSET {
	p := ptrFromHandle_pkix_RelativeDistinguishedNameSET(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_pkix_RelativeDistinguishedNameSET(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RelativeDistinguishedNameSET", p))
}

// --- wrapping slice: pkix.RelativeDistinguishedNameSET ---
//
//export pkix_RelativeDistinguishedNameSET_CTor
func pkix_RelativeDistinguishedNameSET_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pkix_RelativeDistinguishedNameSET(&pkix.RelativeDistinguishedNameSET{}))
}

//export pkix_RelativeDistinguishedNameSET_len
func pkix_RelativeDistinguishedNameSET_len(handle CGoHandle) int {
	return len(deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle))
}

//export pkix_RelativeDistinguishedNameSET_elem
func pkix_RelativeDistinguishedNameSET_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	return handleFromPtr_pkix_AttributeTypeAndValue(&(s[_idx]))
}

//export pkix_RelativeDistinguishedNameSET_subslice
func pkix_RelativeDistinguishedNameSET_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_pkix_RelativeDistinguishedNameSET(&ss))
}

//export pkix_RelativeDistinguishedNameSET_set
func pkix_RelativeDistinguishedNameSET_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	s[_idx] = *ptrFromHandle_pkix_AttributeTypeAndValue(_vl)
}

//export pkix_RelativeDistinguishedNameSET_append
func pkix_RelativeDistinguishedNameSET_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	*s = append(*s, *ptrFromHandle_pkix_AttributeTypeAndValue(_vl))
}

// Converters for non-pointer handles for type: pkix.RevokedCertificate
func ptrFromHandle_pkix_RevokedCertificate(h CGoHandle) *pkix.RevokedCertificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RevokedCertificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.RevokedCertificate{})).(*pkix.RevokedCertificate)
}
func handleFromPtr_pkix_RevokedCertificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RevokedCertificate", p))
}

// Converters for non-pointer handles for type: pkix.TBSCertificateList
func ptrFromHandle_pkix_TBSCertificateList(h CGoHandle) *pkix.TBSCertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.TBSCertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.TBSCertificateList{})).(*pkix.TBSCertificateList)
}
func handleFromPtr_pkix_TBSCertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.TBSCertificateList", p))
}

// Converters for pointer handles for type: encoding.TextMarshaler
func ptrFromHandle_encoding_TextMarshaler(h CGoHandle) encoding.TextMarshaler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "encoding.TextMarshaler")
	if p == nil {
		return nil
	}
	return p.(encoding.TextMarshaler)
}
func handleFromPtr_encoding_TextMarshaler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("encoding.TextMarshaler", p))
}

// Converters for pointer handles for type: encoding.TextUnmarshaler
func ptrFromHandle_encoding_TextUnmarshaler(h CGoHandle) encoding.TextUnmarshaler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "encoding.TextUnmarshaler")
	if p == nil {
		return nil
	}
	return p.(encoding.TextUnmarshaler)
}
func handleFromPtr_encoding_TextUnmarshaler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("encoding.TextUnmarshaler", p))
}

// Converters for non-pointer handles for type: asn1.BitString
func ptrFromHandle_asn1_BitString(h CGoHandle) *asn1.BitString {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.BitString")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(asn1.BitString{})).(*asn1.BitString)
}
func handleFromPtr_asn1_BitString(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.BitString", p))
}

// Converters for implicit pointer handles for type: asn1.ObjectIdentifier
func ptrFromHandle_asn1_ObjectIdentifier(h CGoHandle) *asn1.ObjectIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.ObjectIdentifier")
	if p == nil {
		return nil
	}
	return p.(*asn1.ObjectIdentifier)
}
func deptrFromHandle_asn1_ObjectIdentifier(h CGoHandle) asn1.ObjectIdentifier {
	p := ptrFromHandle_asn1_ObjectIdentifier(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_asn1_ObjectIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.ObjectIdentifier", p))
}

// --- wrapping slice: asn1.ObjectIdentifier ---
//
//export asn1_ObjectIdentifier_CTor
func asn1_ObjectIdentifier_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_asn1_ObjectIdentifier(&asn1.ObjectIdentifier{}))
}

//export asn1_ObjectIdentifier_len
func asn1_ObjectIdentifier_len(handle CGoHandle) int {
	return len(deptrFromHandle_asn1_ObjectIdentifier(handle))
}

//export asn1_ObjectIdentifier_elem
func asn1_ObjectIdentifier_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	return C.longlong(s[_idx])
}

//export asn1_ObjectIdentifier_subslice
func asn1_ObjectIdentifier_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_asn1_ObjectIdentifier(&ss))
}

//export asn1_ObjectIdentifier_set
func asn1_ObjectIdentifier_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	s[_idx] = int(_vl)
}

//export asn1_ObjectIdentifier_append
func asn1_ObjectIdentifier_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_asn1_ObjectIdentifier(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: asn1.RawContent
func ptrFromHandle_asn1_RawContent(h CGoHandle) *asn1.RawContent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.RawContent")
	if p == nil {
		return nil
	}
	return p.(*asn1.RawContent)
}
func deptrFromHandle_asn1_RawContent(h CGoHandle) asn1.RawContent {
	p := ptrFromHandle_asn1_RawContent(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_asn1_RawContent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.RawContent", p))
}

// --- wrapping slice: asn1.RawContent ---
//
//export asn1_RawContent_CTor
func asn1_RawContent_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_asn1_RawContent(&asn1.RawContent{}))
}

//export asn1_RawContent_len
func asn1_RawContent_len(handle CGoHandle) int {
	return len(deptrFromHandle_asn1_RawContent(handle))
}

//export asn1_RawContent_elem
func asn1_RawContent_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_asn1_RawContent(handle)
	return C.char(s[_idx])
}

//export asn1_RawContent_subslice
func asn1_RawContent_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_asn1_RawContent(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_asn1_RawContent(&ss))
}

//export asn1_RawContent_set
func asn1_RawContent_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_asn1_RawContent(handle)
	s[_idx] = byte(_vl)
}

//export asn1_RawContent_append
func asn1_RawContent_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_asn1_RawContent(handle)
	*s = append(*s, byte(_vl))
}

// Converters for non-pointer handles for type: asn1.RawValue
func ptrFromHandle_asn1_RawValue(h CGoHandle) *asn1.RawValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.RawValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(asn1.RawValue{})).(*asn1.RawValue)
}
func handleFromPtr_asn1_RawValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.RawValue", p))
}

// Converters for non-pointer handles for type: flag.Flag
func ptrFromHandle_flag_Flag(h CGoHandle) *flag.Flag {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "flag.Flag")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(flag.Flag{})).(*flag.Flag)
}
func handleFromPtr_flag_Flag(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("flag.Flag", p))
}

// Converters for non-pointer handles for type: flag.FlagSet
func ptrFromHandle_flag_FlagSet(h CGoHandle) *flag.FlagSet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "flag.FlagSet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(flag.FlagSet{})).(*flag.FlagSet)
}
func handleFromPtr_flag_FlagSet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("flag.FlagSet", p))
}

// Converters for pointer handles for type: flag.Value
func ptrFromHandle_flag_Value(h CGoHandle) flag.Value {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "flag.Value")
	if p == nil {
		return nil
	}
	return p.(flag.Value)
}
func handleFromPtr_flag_Value(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("flag.Value", p))
}

// Converters for pointer handles for type: fmt.ScanState
func ptrFromHandle_fmt_ScanState(h CGoHandle) fmt.ScanState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fmt.ScanState")
	if p == nil {
		return nil
	}
	return p.(fmt.ScanState)
}
func handleFromPtr_fmt_ScanState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fmt.ScanState", p))
}

// Converters for pointer handles for type: fmt.State
func ptrFromHandle_fmt_State(h CGoHandle) fmt.State {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fmt.State")
	if p == nil {
		return nil
	}
	return p.(fmt.State)
}
func handleFromPtr_fmt_State(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fmt.State", p))
}

// Converters for pointer handles for type: proto.Message
func ptrFromHandle_proto_Message(h CGoHandle) proto.Message {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "proto.Message")
	if p == nil {
		return nil
	}
	return p.(proto.Message)
}
func handleFromPtr_proto_Message(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("proto.Message", p))
}

// Converters for non-pointer handles for type: fuzz.Continue
func ptrFromHandle_fuzz_Continue(h CGoHandle) *fuzz.Continue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fuzz.Continue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fuzz.Continue{})).(*fuzz.Continue)
}
func handleFromPtr_fuzz_Continue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fuzz.Continue", p))
}

// Converters for pointer handles for type: io.ReadCloser
func ptrFromHandle_io_ReadCloser(h CGoHandle) io.ReadCloser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.ReadCloser")
	if p == nil {
		return nil
	}
	return p.(io.ReadCloser)
}
func handleFromPtr_io_ReadCloser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.ReadCloser", p))
}

// Converters for pointer handles for type: io.Reader
func ptrFromHandle_io_Reader(h CGoHandle) io.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Reader")
	if p == nil {
		return nil
	}
	return p.(io.Reader)
}
func handleFromPtr_io_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Reader", p))
}

// Converters for pointer handles for type: io.Writer
func ptrFromHandle_io_Writer(h CGoHandle) io.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Writer")
	if p == nil {
		return nil
	}
	return p.(io.Writer)
}
func handleFromPtr_io_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Writer", p))
}

// Converters for pointer handles for type: meta.RESTMapper
func ptrFromHandle_meta_RESTMapper(h CGoHandle) meta.RESTMapper {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "meta.RESTMapper")
	if p == nil {
		return nil
	}
	return p.(meta.RESTMapper)
}
func handleFromPtr_meta_RESTMapper(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("meta.RESTMapper", p))
}

// Converters for non-pointer handles for type: v1.CreateOptions
func ptrFromHandle_v1_CreateOptions(h CGoHandle) *v1.CreateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.CreateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.CreateOptions{})).(*v1.CreateOptions)
}
func handleFromPtr_v1_CreateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.CreateOptions", p))
}

// Converters for non-pointer handles for type: v1.DeleteOptions
func ptrFromHandle_v1_DeleteOptions(h CGoHandle) *v1.DeleteOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.DeleteOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.DeleteOptions{})).(*v1.DeleteOptions)
}
func handleFromPtr_v1_DeleteOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.DeleteOptions", p))
}

// Converters for non-pointer handles for type: v1.FieldsV1
func ptrFromHandle_v1_FieldsV1(h CGoHandle) *v1.FieldsV1 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.FieldsV1")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.FieldsV1{})).(*v1.FieldsV1)
}
func handleFromPtr_v1_FieldsV1(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.FieldsV1", p))
}

// Converters for non-pointer handles for type: v1.GetOptions
func ptrFromHandle_v1_GetOptions(h CGoHandle) *v1.GetOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.GetOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.GetOptions{})).(*v1.GetOptions)
}
func handleFromPtr_v1_GetOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.GetOptions", p))
}

// Converters for non-pointer handles for type: v1.ListOptions
func ptrFromHandle_v1_ListOptions(h CGoHandle) *v1.ListOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.ListOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.ListOptions{})).(*v1.ListOptions)
}
func handleFromPtr_v1_ListOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.ListOptions", p))
}

// Converters for non-pointer handles for type: v1.ManagedFieldsEntry
func ptrFromHandle_v1_ManagedFieldsEntry(h CGoHandle) *v1.ManagedFieldsEntry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.ManagedFieldsEntry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.ManagedFieldsEntry{})).(*v1.ManagedFieldsEntry)
}
func handleFromPtr_v1_ManagedFieldsEntry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.ManagedFieldsEntry", p))
}

// Converters for non-pointer handles for type: v1.OwnerReference
func ptrFromHandle_v1_OwnerReference(h CGoHandle) *v1.OwnerReference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.OwnerReference")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.OwnerReference{})).(*v1.OwnerReference)
}
func handleFromPtr_v1_OwnerReference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.OwnerReference", p))
}

// Converters for non-pointer handles for type: v1.PatchOptions
func ptrFromHandle_v1_PatchOptions(h CGoHandle) *v1.PatchOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.PatchOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.PatchOptions{})).(*v1.PatchOptions)
}
func handleFromPtr_v1_PatchOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.PatchOptions", p))
}

// Converters for non-pointer handles for type: v1.Preconditions
func ptrFromHandle_v1_Preconditions(h CGoHandle) *v1.Preconditions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.Preconditions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Preconditions{})).(*v1.Preconditions)
}
func handleFromPtr_v1_Preconditions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.Preconditions", p))
}

// Converters for non-pointer handles for type: v1.Time
func ptrFromHandle_v1_Time(h CGoHandle) *v1.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Time{})).(*v1.Time)
}
func handleFromPtr_v1_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.Time", p))
}

// Converters for non-pointer handles for type: v1.Timestamp
func ptrFromHandle_v1_Timestamp(h CGoHandle) *v1.Timestamp {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.Timestamp")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.Timestamp{})).(*v1.Timestamp)
}
func handleFromPtr_v1_Timestamp(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.Timestamp", p))
}

// Converters for non-pointer handles for type: v1.UpdateOptions
func ptrFromHandle_v1_UpdateOptions(h CGoHandle) *v1.UpdateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "v1.UpdateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(v1.UpdateOptions{})).(*v1.UpdateOptions)
}
func handleFromPtr_v1_UpdateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("v1.UpdateOptions", p))
}

// Converters for non-pointer handles for type: conversion.ConversionFuncs
func ptrFromHandle_conversion_ConversionFuncs(h CGoHandle) *conversion.ConversionFuncs {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "conversion.ConversionFuncs")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.ConversionFuncs{})).(*conversion.ConversionFuncs)
}
func handleFromPtr_conversion_ConversionFuncs(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("conversion.ConversionFuncs", p))
}

// Converters for non-pointer handles for type: conversion.Converter
func ptrFromHandle_conversion_Converter(h CGoHandle) *conversion.Converter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "conversion.Converter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Converter{})).(*conversion.Converter)
}
func handleFromPtr_conversion_Converter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("conversion.Converter", p))
}

// Converters for non-pointer handles for type: conversion.Meta
func ptrFromHandle_conversion_Meta(h CGoHandle) *conversion.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "conversion.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Meta{})).(*conversion.Meta)
}
func handleFromPtr_conversion_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("conversion.Meta", p))
}

// Converters for pointer handles for type: fields.Selector
func ptrFromHandle_fields_Selector(h CGoHandle) fields.Selector {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fields.Selector")
	if p == nil {
		return nil
	}
	return p.(fields.Selector)
}
func handleFromPtr_fields_Selector(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fields.Selector", p))
}

// Converters for pointer handles for type: labels.Selector
func ptrFromHandle_labels_Selector(h CGoHandle) labels.Selector {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "labels.Selector")
	if p == nil {
		return nil
	}
	return p.(labels.Selector)
}
func handleFromPtr_labels_Selector(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("labels.Selector", p))
}

// Converters for pointer handles for type: runtime.Codec
func ptrFromHandle_runtime_Codec(h CGoHandle) runtime.Codec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Codec")
	if p == nil {
		return nil
	}
	return p.(runtime.Codec)
}
func handleFromPtr_runtime_Codec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Codec", p))
}

// Converters for pointer handles for type: runtime.Decoder
func ptrFromHandle_runtime_Decoder(h CGoHandle) runtime.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Decoder")
	if p == nil {
		return nil
	}
	return p.(runtime.Decoder)
}
func handleFromPtr_runtime_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Decoder", p))
}

// Converters for pointer handles for type: runtime.Encoder
func ptrFromHandle_runtime_Encoder(h CGoHandle) runtime.Encoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Encoder")
	if p == nil {
		return nil
	}
	return p.(runtime.Encoder)
}
func handleFromPtr_runtime_Encoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Encoder", p))
}

// Converters for pointer handles for type: runtime.GroupVersioner
func ptrFromHandle_runtime_GroupVersioner(h CGoHandle) runtime.GroupVersioner {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.GroupVersioner")
	if p == nil {
		return nil
	}
	return p.(runtime.GroupVersioner)
}
func handleFromPtr_runtime_GroupVersioner(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.GroupVersioner", p))
}

// Converters for pointer handles for type: runtime.NegotiatedSerializer
func ptrFromHandle_runtime_NegotiatedSerializer(h CGoHandle) runtime.NegotiatedSerializer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.NegotiatedSerializer")
	if p == nil {
		return nil
	}
	return p.(runtime.NegotiatedSerializer)
}
func handleFromPtr_runtime_NegotiatedSerializer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.NegotiatedSerializer", p))
}

// Converters for pointer handles for type: runtime.Object
func ptrFromHandle_runtime_Object(h CGoHandle) runtime.Object {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Object")
	if p == nil {
		return nil
	}
	return p.(runtime.Object)
}
func handleFromPtr_runtime_Object(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Object", p))
}

// Converters for non-pointer handles for type: runtime.Scheme
func ptrFromHandle_runtime_Scheme(h CGoHandle) *runtime.Scheme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Scheme")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.Scheme{})).(*runtime.Scheme)
}
func handleFromPtr_runtime_Scheme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Scheme", p))
}

// Converters for pointer handles for type: runtime.Serializer
func ptrFromHandle_runtime_Serializer(h CGoHandle) runtime.Serializer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Serializer")
	if p == nil {
		return nil
	}
	return p.(runtime.Serializer)
}
func handleFromPtr_runtime_Serializer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Serializer", p))
}

// Converters for non-pointer handles for type: runtime.SerializerInfo
func ptrFromHandle_runtime_SerializerInfo(h CGoHandle) *runtime.SerializerInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.SerializerInfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.SerializerInfo{})).(*runtime.SerializerInfo)
}
func handleFromPtr_runtime_SerializerInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.SerializerInfo", p))
}

// Converters for non-pointer handles for type: runtime.StreamSerializerInfo
func ptrFromHandle_runtime_StreamSerializerInfo(h CGoHandle) *runtime.StreamSerializerInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.StreamSerializerInfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.StreamSerializerInfo{})).(*runtime.StreamSerializerInfo)
}
func handleFromPtr_runtime_StreamSerializerInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.StreamSerializerInfo", p))
}

// Converters for non-pointer handles for type: schema.GroupKind
func ptrFromHandle_schema_GroupKind(h CGoHandle) *schema.GroupKind {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupKind")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupKind{})).(*schema.GroupKind)
}
func handleFromPtr_schema_GroupKind(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupKind", p))
}

// Converters for non-pointer handles for type: schema.GroupResource
func ptrFromHandle_schema_GroupResource(h CGoHandle) *schema.GroupResource {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupResource")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupResource{})).(*schema.GroupResource)
}
func handleFromPtr_schema_GroupResource(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupResource", p))
}

// Converters for non-pointer handles for type: schema.GroupVersion
func ptrFromHandle_schema_GroupVersion(h CGoHandle) *schema.GroupVersion {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupVersion")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupVersion{})).(*schema.GroupVersion)
}
func handleFromPtr_schema_GroupVersion(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupVersion", p))
}

// Converters for non-pointer handles for type: schema.GroupVersionKind
func ptrFromHandle_schema_GroupVersionKind(h CGoHandle) *schema.GroupVersionKind {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupVersionKind")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupVersionKind{})).(*schema.GroupVersionKind)
}
func handleFromPtr_schema_GroupVersionKind(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupVersionKind", p))
}

// Converters for non-pointer handles for type: schema.GroupVersionResource
func ptrFromHandle_schema_GroupVersionResource(h CGoHandle) *schema.GroupVersionResource {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupVersionResource")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupVersionResource{})).(*schema.GroupVersionResource)
}
func handleFromPtr_schema_GroupVersionResource(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupVersionResource", p))
}

// Converters for pointer handles for type: schema.ObjectKind
func ptrFromHandle_schema_ObjectKind(h CGoHandle) schema.ObjectKind {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.ObjectKind")
	if p == nil {
		return nil
	}
	return p.(schema.ObjectKind)
}
func handleFromPtr_schema_ObjectKind(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.ObjectKind", p))
}

// Converters for non-pointer handles for type: serializer.CodecFactory
func ptrFromHandle_serializer_CodecFactory(h CGoHandle) *serializer.CodecFactory {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "serializer.CodecFactory")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(serializer.CodecFactory{})).(*serializer.CodecFactory)
}
func handleFromPtr_serializer_CodecFactory(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("serializer.CodecFactory", p))
}

// Converters for non-pointer handles for type: types.NamespacedName
func ptrFromHandle_types_NamespacedName(h CGoHandle) *types.NamespacedName {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "types.NamespacedName")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(types.NamespacedName{})).(*types.NamespacedName)
}
func handleFromPtr_types_NamespacedName(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("types.NamespacedName", p))
}

// Converters for pointer handles for type: watch.Interface
func ptrFromHandle_watch_Interface(h CGoHandle) watch.Interface {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "watch.Interface")
	if p == nil {
		return nil
	}
	return p.(watch.Interface)
}
func handleFromPtr_watch_Interface(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("watch.Interface", p))
}

// Converters for pointer handles for type: rest.AuthProviderConfigPersister
func ptrFromHandle_rest_AuthProviderConfigPersister(h CGoHandle) rest.AuthProviderConfigPersister {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.AuthProviderConfigPersister")
	if p == nil {
		return nil
	}
	return p.(rest.AuthProviderConfigPersister)
}
func handleFromPtr_rest_AuthProviderConfigPersister(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.AuthProviderConfigPersister", p))
}

// Converters for non-pointer handles for type: rest.Config
func ptrFromHandle_rest_Config(h CGoHandle) *rest.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.Config{})).(*rest.Config)
}
func handleFromPtr_rest_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.Config", p))
}

// Converters for non-pointer handles for type: rest.ImpersonationConfig
func ptrFromHandle_rest_ImpersonationConfig(h CGoHandle) *rest.ImpersonationConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.ImpersonationConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.ImpersonationConfig{})).(*rest.ImpersonationConfig)
}
func handleFromPtr_rest_ImpersonationConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.ImpersonationConfig", p))
}

// Converters for pointer handles for type: rest.Interface
func ptrFromHandle_rest_Interface(h CGoHandle) rest.Interface {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.Interface")
	if p == nil {
		return nil
	}
	return p.(rest.Interface)
}
func handleFromPtr_rest_Interface(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.Interface", p))
}

// Converters for pointer handles for type: rest.WarningHandler
func ptrFromHandle_rest_WarningHandler(h CGoHandle) rest.WarningHandler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.WarningHandler")
	if p == nil {
		return nil
	}
	return p.(rest.WarningHandler)
}
func handleFromPtr_rest_WarningHandler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.WarningHandler", p))
}

// Converters for pointer handles for type: testing.ObjectTracker
func ptrFromHandle_testing_ObjectTracker(h CGoHandle) testing.ObjectTracker {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "testing.ObjectTracker")
	if p == nil {
		return nil
	}
	return p.(testing.ObjectTracker)
}
func handleFromPtr_testing_ObjectTracker(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("testing.ObjectTracker", p))
}

// Converters for non-pointer handles for type: api.AuthProviderConfig
func ptrFromHandle_api_AuthProviderConfig(h CGoHandle) *api.AuthProviderConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.AuthProviderConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.AuthProviderConfig{})).(*api.AuthProviderConfig)
}
func handleFromPtr_api_AuthProviderConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.AuthProviderConfig", p))
}

// Converters for non-pointer handles for type: api.ExecConfig
func ptrFromHandle_api_ExecConfig(h CGoHandle) *api.ExecConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.ExecConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecConfig{})).(*api.ExecConfig)
}
func handleFromPtr_api_ExecConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.ExecConfig", p))
}

// Converters for non-pointer handles for type: api.ExecEnvVar
func ptrFromHandle_api_ExecEnvVar(h CGoHandle) *api.ExecEnvVar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.ExecEnvVar")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecEnvVar{})).(*api.ExecEnvVar)
}
func handleFromPtr_api_ExecEnvVar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.ExecEnvVar", p))
}

// Converters for non-pointer handles for type: transport.Config
func ptrFromHandle_transport_Config(h CGoHandle) *transport.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.Config{})).(*transport.Config)
}
func handleFromPtr_transport_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.Config", p))
}

// Converters for non-pointer handles for type: transport.DialHolder
func ptrFromHandle_transport_DialHolder(h CGoHandle) *transport.DialHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.DialHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.DialHolder{})).(*transport.DialHolder)
}
func handleFromPtr_transport_DialHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.DialHolder", p))
}

// Converters for non-pointer handles for type: transport.GetCertHolder
func ptrFromHandle_transport_GetCertHolder(h CGoHandle) *transport.GetCertHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.GetCertHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.GetCertHolder{})).(*transport.GetCertHolder)
}
func handleFromPtr_transport_GetCertHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.GetCertHolder", p))
}

// Converters for non-pointer handles for type: transport.ImpersonationConfig
func ptrFromHandle_transport_ImpersonationConfig(h CGoHandle) *transport.ImpersonationConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.ImpersonationConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.ImpersonationConfig{})).(*transport.ImpersonationConfig)
}
func handleFromPtr_transport_ImpersonationConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.ImpersonationConfig", p))
}

// Converters for non-pointer handles for type: transport.TLSConfig
func ptrFromHandle_transport_TLSConfig(h CGoHandle) *transport.TLSConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.TLSConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.TLSConfig{})).(*transport.TLSConfig)
}
func handleFromPtr_transport_TLSConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.TLSConfig", p))
}

// Converters for pointer handles for type: flowcontrol.RateLimiter
func ptrFromHandle_flowcontrol_RateLimiter(h CGoHandle) flowcontrol.RateLimiter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "flowcontrol.RateLimiter")
	if p == nil {
		return nil
	}
	return p.(flowcontrol.RateLimiter)
}
func handleFromPtr_flowcontrol_RateLimiter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("flowcontrol.RateLimiter", p))
}

// Converters for non-pointer handles for type: big.Int
func ptrFromHandle_big_Int(h CGoHandle) *big.Int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "big.Int")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(big.Int{})).(*big.Int)
}
func handleFromPtr_big_Int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("big.Int", p))
}

// Converters for non-pointer handles for type: rand.Rand
func ptrFromHandle_rand_Rand(h CGoHandle) *rand.Rand {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rand.Rand")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rand.Rand{})).(*rand.Rand)
}
func handleFromPtr_rand_Rand(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rand.Rand", p))
}

// Converters for pointer handles for type: multipart.File
func ptrFromHandle_multipart_File(h CGoHandle) multipart.File {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.File")
	if p == nil {
		return nil
	}
	return p.(multipart.File)
}
func handleFromPtr_multipart_File(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.File", p))
}

// Converters for non-pointer handles for type: multipart.FileHeader
func ptrFromHandle_multipart_FileHeader(h CGoHandle) *multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.FileHeader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.FileHeader{})).(*multipart.FileHeader)
}
func handleFromPtr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.FileHeader", p))
}

// Converters for non-pointer handles for type: multipart.Form
func ptrFromHandle_multipart_Form(h CGoHandle) *multipart.Form {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Form")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Form{})).(*multipart.Form)
}
func handleFromPtr_multipart_Form(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Form", p))
}

// Converters for non-pointer handles for type: multipart.Part
func ptrFromHandle_multipart_Part(h CGoHandle) *multipart.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Part{})).(*multipart.Part)
}
func handleFromPtr_multipart_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Part", p))
}

// Converters for non-pointer handles for type: multipart.Reader
func ptrFromHandle_multipart_Reader(h CGoHandle) *multipart.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Reader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Reader{})).(*multipart.Reader)
}
func handleFromPtr_multipart_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Reader", p))
}

// Converters for implicit pointer handles for type: net.IP
func ptrFromHandle_net_IP(h CGoHandle) *net.IP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IP")
	if p == nil {
		return nil
	}
	return p.(*net.IP)
}
func deptrFromHandle_net_IP(h CGoHandle) net.IP {
	p := ptrFromHandle_net_IP(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IP", p))
}

// --- wrapping slice: net.IP ---
//
//export net_IP_CTor
func net_IP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IP(&net.IP{}))
}

//export net_IP_len
func net_IP_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IP(handle))
}

//export net_IP_elem
func net_IP_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IP(handle)
	return C.char(s[_idx])
}

//export net_IP_subslice
func net_IP_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IP(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IP(&ss))
}

//export net_IP_set
func net_IP_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IP(handle)
	s[_idx] = byte(_vl)
}

//export net_IP_append
func net_IP_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IP(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: net.IPMask
func ptrFromHandle_net_IPMask(h CGoHandle) *net.IPMask {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IPMask")
	if p == nil {
		return nil
	}
	return p.(*net.IPMask)
}
func deptrFromHandle_net_IPMask(h CGoHandle) net.IPMask {
	p := ptrFromHandle_net_IPMask(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IPMask(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IPMask", p))
}

// --- wrapping slice: net.IPMask ---
//
//export net_IPMask_CTor
func net_IPMask_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IPMask(&net.IPMask{}))
}

//export net_IPMask_len
func net_IPMask_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IPMask(handle))
}

//export net_IPMask_elem
func net_IPMask_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IPMask(handle)
	return C.char(s[_idx])
}

//export net_IPMask_subslice
func net_IPMask_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IPMask(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IPMask(&ss))
}

//export net_IPMask_set
func net_IPMask_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IPMask(handle)
	s[_idx] = byte(_vl)
}

//export net_IPMask_append
func net_IPMask_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IPMask(handle)
	*s = append(*s, byte(_vl))
}

// Converters for non-pointer handles for type: net.IPNet
func ptrFromHandle_net_IPNet(h CGoHandle) *net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IPNet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.IPNet{})).(*net.IPNet)
}
func handleFromPtr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IPNet", p))
}

// Converters for non-pointer handles for type: http.Client
func ptrFromHandle_http_Client(h CGoHandle) *http.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Client{})).(*http.Client)
}
func handleFromPtr_http_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Client", p))
}

// Converters for non-pointer handles for type: http.Cookie
func ptrFromHandle_http_Cookie(h CGoHandle) *http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Cookie")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Cookie{})).(*http.Cookie)
}
func handleFromPtr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Cookie", p))
}

// Converters for pointer handles for type: http.CookieJar
func ptrFromHandle_http_CookieJar(h CGoHandle) http.CookieJar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.CookieJar")
	if p == nil {
		return nil
	}
	return p.(http.CookieJar)
}
func handleFromPtr_http_CookieJar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.CookieJar", p))
}

// Converters for implicit pointer handles for type: http.Header
func ptrFromHandle_http_Header(h CGoHandle) *http.Header {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Header")
	if p == nil {
		return nil
	}
	return p.(*http.Header)
}
func deptrFromHandle_http_Header(h CGoHandle) http.Header {
	p := ptrFromHandle_http_Header(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_http_Header(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Header", p))
}

// --- wrapping map: http.Header ---
//
//export http_Header_CTor
func http_Header_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_http_Header(&http.Header{}))
}

//export http_Header_len
func http_Header_len(handle CGoHandle) int {
	return len(deptrFromHandle_http_Header(handle))
}

//export http_Header_elem
func http_Header_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_http_Header(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export http_Header_contains
func http_Header_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_http_Header(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export http_Header_set
func http_Header_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_http_Header(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export http_Header_delete
func http_Header_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_http_Header(handle)
	delete(s, C.GoString(_ky))
}

//export http_Header_keys
func http_Header_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_http_Header(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: http.Request
func ptrFromHandle_http_Request(h CGoHandle) *http.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Request{})).(*http.Request)
}
func handleFromPtr_http_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Request", p))
}

// Converters for non-pointer handles for type: http.Response
func ptrFromHandle_http_Response(h CGoHandle) *http.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Response{})).(*http.Response)
}
func handleFromPtr_http_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Response", p))
}

// Converters for pointer handles for type: http.RoundTripper
func ptrFromHandle_http_RoundTripper(h CGoHandle) http.RoundTripper {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.RoundTripper")
	if p == nil {
		return nil
	}
	return p.(http.RoundTripper)
}
func handleFromPtr_http_RoundTripper(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.RoundTripper", p))
}

// Converters for implicit pointer handles for type: textproto.MIMEHeader
func ptrFromHandle_textproto_MIMEHeader(h CGoHandle) *textproto.MIMEHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "textproto.MIMEHeader")
	if p == nil {
		return nil
	}
	return p.(*textproto.MIMEHeader)
}
func deptrFromHandle_textproto_MIMEHeader(h CGoHandle) textproto.MIMEHeader {
	p := ptrFromHandle_textproto_MIMEHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_textproto_MIMEHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("textproto.MIMEHeader", p))
}

// --- wrapping map: textproto.MIMEHeader ---
//
//export textproto_MIMEHeader_CTor
func textproto_MIMEHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_textproto_MIMEHeader(&textproto.MIMEHeader{}))
}

//export textproto_MIMEHeader_len
func textproto_MIMEHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_textproto_MIMEHeader(handle))
}

//export textproto_MIMEHeader_elem
func textproto_MIMEHeader_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export textproto_MIMEHeader_contains
func textproto_MIMEHeader_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export textproto_MIMEHeader_set
func textproto_MIMEHeader_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export textproto_MIMEHeader_delete
func textproto_MIMEHeader_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	delete(s, C.GoString(_ky))
}

//export textproto_MIMEHeader_keys
func textproto_MIMEHeader_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: url.URL
func ptrFromHandle_url_URL(h CGoHandle) *url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.URL")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.URL{})).(*url.URL)
}
func handleFromPtr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.URL", p))
}

// Converters for non-pointer handles for type: url.Userinfo
func ptrFromHandle_url_Userinfo(h CGoHandle) *url.Userinfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.Userinfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.Userinfo{})).(*url.Userinfo)
}
func handleFromPtr_url_Userinfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.Userinfo", p))
}

// Converters for implicit pointer handles for type: url.Values
func ptrFromHandle_url_Values(h CGoHandle) *url.Values {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.Values")
	if p == nil {
		return nil
	}
	return p.(*url.Values)
}
func deptrFromHandle_url_Values(h CGoHandle) url.Values {
	p := ptrFromHandle_url_Values(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_url_Values(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.Values", p))
}

// --- wrapping map: url.Values ---
//
//export url_Values_CTor
func url_Values_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_url_Values(&url.Values{}))
}

//export url_Values_len
func url_Values_len(handle CGoHandle) int {
	return len(deptrFromHandle_url_Values(handle))
}

//export url_Values_elem
func url_Values_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_url_Values(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export url_Values_contains
func url_Values_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_url_Values(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export url_Values_set
func url_Values_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_url_Values(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export url_Values_delete
func url_Values_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_url_Values(handle)
	delete(s, C.GoString(_ky))
}

//export url_Values_keys
func url_Values_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_url_Values(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for pointer handles for type: reflect.Type
func ptrFromHandle_reflect_Type(h CGoHandle) reflect.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "reflect.Type")
	if p == nil {
		return nil
	}
	return p.(reflect.Type)
}
func handleFromPtr_reflect_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("reflect.Type", p))
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: client ---

// ---- Types ---

// Converters for pointer handles for type: *client.CacheOptions
func ptrFromHandle_Ptr_client_CacheOptions(h CGoHandle) *client.CacheOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.CacheOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.CacheOptions{})).(*client.CacheOptions)
}
func handleFromPtr_Ptr_client_CacheOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.CacheOptions", p))
}

// Converters for pointer handles for type: *client.CreateOptions
func ptrFromHandle_Ptr_client_CreateOptions(h CGoHandle) *client.CreateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.CreateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.CreateOptions{})).(*client.CreateOptions)
}
func handleFromPtr_Ptr_client_CreateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.CreateOptions", p))
}

// Converters for pointer handles for type: *client.DeleteAllOfOptions
func ptrFromHandle_Ptr_client_DeleteAllOfOptions(h CGoHandle) *client.DeleteAllOfOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.DeleteAllOfOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.DeleteAllOfOptions{})).(*client.DeleteAllOfOptions)
}
func handleFromPtr_Ptr_client_DeleteAllOfOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.DeleteAllOfOptions", p))
}

// Converters for pointer handles for type: *client.DeleteOptions
func ptrFromHandle_Ptr_client_DeleteOptions(h CGoHandle) *client.DeleteOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.DeleteOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.DeleteOptions{})).(*client.DeleteOptions)
}
func handleFromPtr_Ptr_client_DeleteOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.DeleteOptions", p))
}

// Converters for pointer handles for type: *client.GetOptions
func ptrFromHandle_Ptr_client_GetOptions(h CGoHandle) *client.GetOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.GetOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.GetOptions{})).(*client.GetOptions)
}
func handleFromPtr_Ptr_client_GetOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.GetOptions", p))
}

// Converters for pointer handles for type: *client.ListOptions
func ptrFromHandle_Ptr_client_ListOptions(h CGoHandle) *client.ListOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.ListOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.ListOptions{})).(*client.ListOptions)
}
func handleFromPtr_Ptr_client_ListOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.ListOptions", p))
}

// Converters for pointer handles for type: *client.MatchingFieldsSelector
func ptrFromHandle_Ptr_client_MatchingFieldsSelector(h CGoHandle) *client.MatchingFieldsSelector {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.MatchingFieldsSelector")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.MatchingFieldsSelector{})).(*client.MatchingFieldsSelector)
}
func handleFromPtr_Ptr_client_MatchingFieldsSelector(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.MatchingFieldsSelector", p))
}

// Converters for pointer handles for type: *client.MatchingLabelsSelector
func ptrFromHandle_Ptr_client_MatchingLabelsSelector(h CGoHandle) *client.MatchingLabelsSelector {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.MatchingLabelsSelector")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.MatchingLabelsSelector{})).(*client.MatchingLabelsSelector)
}
func handleFromPtr_Ptr_client_MatchingLabelsSelector(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.MatchingLabelsSelector", p))
}

// Converters for pointer handles for type: *client.MergeFromOptions
func ptrFromHandle_Ptr_client_MergeFromOptions(h CGoHandle) *client.MergeFromOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.MergeFromOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.MergeFromOptions{})).(*client.MergeFromOptions)
}
func handleFromPtr_Ptr_client_MergeFromOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.MergeFromOptions", p))
}

// Converters for pointer handles for type: *client.MergeFromWithOptimisticLock
func ptrFromHandle_Ptr_client_MergeFromWithOptimisticLock(h CGoHandle) *client.MergeFromWithOptimisticLock {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.MergeFromWithOptimisticLock")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.MergeFromWithOptimisticLock{})).(*client.MergeFromWithOptimisticLock)
}
func handleFromPtr_Ptr_client_MergeFromWithOptimisticLock(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.MergeFromWithOptimisticLock", p))
}

// Converters for pointer handles for type: *client.Options
func ptrFromHandle_Ptr_client_Options(h CGoHandle) *client.Options {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.Options")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.Options{})).(*client.Options)
}
func handleFromPtr_Ptr_client_Options(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.Options", p))
}

// Converters for pointer handles for type: *client.PatchOptions
func ptrFromHandle_Ptr_client_PatchOptions(h CGoHandle) *client.PatchOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.PatchOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.PatchOptions{})).(*client.PatchOptions)
}
func handleFromPtr_Ptr_client_PatchOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.PatchOptions", p))
}

// Converters for pointer handles for type: *client.Preconditions
func ptrFromHandle_Ptr_client_Preconditions(h CGoHandle) *client.Preconditions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.Preconditions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.Preconditions{})).(*client.Preconditions)
}
func handleFromPtr_Ptr_client_Preconditions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.Preconditions", p))
}

// Converters for pointer handles for type: *client.SubResourceCreateOptions
func ptrFromHandle_Ptr_client_SubResourceCreateOptions(h CGoHandle) *client.SubResourceCreateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.SubResourceCreateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.SubResourceCreateOptions{})).(*client.SubResourceCreateOptions)
}
func handleFromPtr_Ptr_client_SubResourceCreateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.SubResourceCreateOptions", p))
}

// Converters for pointer handles for type: *client.SubResourceGetOptions
func ptrFromHandle_Ptr_client_SubResourceGetOptions(h CGoHandle) *client.SubResourceGetOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.SubResourceGetOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.SubResourceGetOptions{})).(*client.SubResourceGetOptions)
}
func handleFromPtr_Ptr_client_SubResourceGetOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.SubResourceGetOptions", p))
}

// Converters for pointer handles for type: *client.SubResourcePatchOptions
func ptrFromHandle_Ptr_client_SubResourcePatchOptions(h CGoHandle) *client.SubResourcePatchOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.SubResourcePatchOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.SubResourcePatchOptions{})).(*client.SubResourcePatchOptions)
}
func handleFromPtr_Ptr_client_SubResourcePatchOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.SubResourcePatchOptions", p))
}

// Converters for pointer handles for type: *client.SubResourceUpdateOptions
func ptrFromHandle_Ptr_client_SubResourceUpdateOptions(h CGoHandle) *client.SubResourceUpdateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.SubResourceUpdateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.SubResourceUpdateOptions{})).(*client.SubResourceUpdateOptions)
}
func handleFromPtr_Ptr_client_SubResourceUpdateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.SubResourceUpdateOptions", p))
}

// Converters for pointer handles for type: *client.UpdateOptions
func ptrFromHandle_Ptr_client_UpdateOptions(h CGoHandle) *client.UpdateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.UpdateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.UpdateOptions{})).(*client.UpdateOptions)
}
func handleFromPtr_Ptr_client_UpdateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.UpdateOptions", p))
}

// Converters for implicit pointer handles for type: []*x509.Certificate
func ptrFromHandle_Slice_Ptr_x509_Certificate(h CGoHandle) *[]*x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*x509.Certificate")
	if p == nil {
		return nil
	}
	return p.(*[]*x509.Certificate)
}
func deptrFromHandle_Slice_Ptr_x509_Certificate(h CGoHandle) []*x509.Certificate {
	p := ptrFromHandle_Slice_Ptr_x509_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*x509.Certificate", p))
}

// --- wrapping slice: []*x509.Certificate ---
//
//export Slice_Ptr_x509_Certificate_CTor
func Slice_Ptr_x509_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_x509_Certificate(&[]*x509.Certificate{}))
}

//export Slice_Ptr_x509_Certificate_len
func Slice_Ptr_x509_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_x509_Certificate(handle))
}

//export Slice_Ptr_x509_Certificate_elem
func Slice_Ptr_x509_Certificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	return handleFromPtr_Ptr_x509_Certificate(&(s[_idx]))
}

//export Slice_Ptr_x509_Certificate_subslice
func Slice_Ptr_x509_Certificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_x509_Certificate(&ss))
}

//export Slice_Ptr_x509_Certificate_set
func Slice_Ptr_x509_Certificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	s[_idx] = ptrFromHandle_Ptr_x509_Certificate(_vl)
}

//export Slice_Ptr_x509_Certificate_append
func Slice_Ptr_x509_Certificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	*s = append(*s, ptrFromHandle_Ptr_x509_Certificate(_vl))
}

// Converters for implicit pointer handles for type: []*multipart.FileHeader
func ptrFromHandle_Slice_Ptr_multipart_FileHeader(h CGoHandle) *[]*multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return p.(*[]*multipart.FileHeader)
}
func deptrFromHandle_Slice_Ptr_multipart_FileHeader(h CGoHandle) []*multipart.FileHeader {
	p := ptrFromHandle_Slice_Ptr_multipart_FileHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*multipart.FileHeader", p))
}

// --- wrapping slice: []*multipart.FileHeader ---
//
//export Slice_Ptr_multipart_FileHeader_CTor
func Slice_Ptr_multipart_FileHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_multipart_FileHeader(&[]*multipart.FileHeader{}))
}

//export Slice_Ptr_multipart_FileHeader_len
func Slice_Ptr_multipart_FileHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle))
}

//export Slice_Ptr_multipart_FileHeader_elem
func Slice_Ptr_multipart_FileHeader_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	return handleFromPtr_Ptr_multipart_FileHeader(&(s[_idx]))
}

//export Slice_Ptr_multipart_FileHeader_subslice
func Slice_Ptr_multipart_FileHeader_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_multipart_FileHeader(&ss))
}

//export Slice_Ptr_multipart_FileHeader_set
func Slice_Ptr_multipart_FileHeader_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	s[_idx] = ptrFromHandle_Ptr_multipart_FileHeader(_vl)
}

//export Slice_Ptr_multipart_FileHeader_append
func Slice_Ptr_multipart_FileHeader_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	*s = append(*s, ptrFromHandle_Ptr_multipart_FileHeader(_vl))
}

// Converters for implicit pointer handles for type: []*net.IPNet
func ptrFromHandle_Slice_Ptr_net_IPNet(h CGoHandle) *[]*net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*net.IPNet")
	if p == nil {
		return nil
	}
	return p.(*[]*net.IPNet)
}
func deptrFromHandle_Slice_Ptr_net_IPNet(h CGoHandle) []*net.IPNet {
	p := ptrFromHandle_Slice_Ptr_net_IPNet(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*net.IPNet", p))
}

// --- wrapping slice: []*net.IPNet ---
//
//export Slice_Ptr_net_IPNet_CTor
func Slice_Ptr_net_IPNet_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_net_IPNet(&[]*net.IPNet{}))
}

//export Slice_Ptr_net_IPNet_len
func Slice_Ptr_net_IPNet_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_net_IPNet(handle))
}

//export Slice_Ptr_net_IPNet_elem
func Slice_Ptr_net_IPNet_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	return handleFromPtr_Ptr_net_IPNet(&(s[_idx]))
}

//export Slice_Ptr_net_IPNet_subslice
func Slice_Ptr_net_IPNet_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_net_IPNet(&ss))
}

//export Slice_Ptr_net_IPNet_set
func Slice_Ptr_net_IPNet_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	s[_idx] = ptrFromHandle_Ptr_net_IPNet(_vl)
}

//export Slice_Ptr_net_IPNet_append
func Slice_Ptr_net_IPNet_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_net_IPNet(handle)
	*s = append(*s, ptrFromHandle_Ptr_net_IPNet(_vl))
}

// Converters for implicit pointer handles for type: []*http.Cookie
func ptrFromHandle_Slice_Ptr_http_Cookie(h CGoHandle) *[]*http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*http.Cookie")
	if p == nil {
		return nil
	}
	return p.(*[]*http.Cookie)
}
func deptrFromHandle_Slice_Ptr_http_Cookie(h CGoHandle) []*http.Cookie {
	p := ptrFromHandle_Slice_Ptr_http_Cookie(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*http.Cookie", p))
}

// --- wrapping slice: []*http.Cookie ---
//
//export Slice_Ptr_http_Cookie_CTor
func Slice_Ptr_http_Cookie_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_http_Cookie(&[]*http.Cookie{}))
}

//export Slice_Ptr_http_Cookie_len
func Slice_Ptr_http_Cookie_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_http_Cookie(handle))
}

//export Slice_Ptr_http_Cookie_elem
func Slice_Ptr_http_Cookie_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	return handleFromPtr_Ptr_http_Cookie(&(s[_idx]))
}

//export Slice_Ptr_http_Cookie_subslice
func Slice_Ptr_http_Cookie_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_http_Cookie(&ss))
}

//export Slice_Ptr_http_Cookie_set
func Slice_Ptr_http_Cookie_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	s[_idx] = ptrFromHandle_Ptr_http_Cookie(_vl)
}

//export Slice_Ptr_http_Cookie_append
func Slice_Ptr_http_Cookie_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_http_Cookie(handle)
	*s = append(*s, ptrFromHandle_Ptr_http_Cookie(_vl))
}

// Converters for implicit pointer handles for type: []*url.URL
func ptrFromHandle_Slice_Ptr_url_URL(h CGoHandle) *[]*url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*url.URL")
	if p == nil {
		return nil
	}
	return p.(*[]*url.URL)
}
func deptrFromHandle_Slice_Ptr_url_URL(h CGoHandle) []*url.URL {
	p := ptrFromHandle_Slice_Ptr_url_URL(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*url.URL", p))
}

// --- wrapping slice: []*url.URL ---
//
//export Slice_Ptr_url_URL_CTor
func Slice_Ptr_url_URL_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_url_URL(&[]*url.URL{}))
}

//export Slice_Ptr_url_URL_len
func Slice_Ptr_url_URL_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_url_URL(handle))
}

//export Slice_Ptr_url_URL_elem
func Slice_Ptr_url_URL_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	return handleFromPtr_Ptr_url_URL(&(s[_idx]))
}

//export Slice_Ptr_url_URL_subslice
func Slice_Ptr_url_URL_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_url_URL(&ss))
}

//export Slice_Ptr_url_URL_set
func Slice_Ptr_url_URL_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	s[_idx] = ptrFromHandle_Ptr_url_URL(_vl)
}

//export Slice_Ptr_url_URL_append
func Slice_Ptr_url_URL_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_url_URL(handle)
	*s = append(*s, ptrFromHandle_Ptr_url_URL(_vl))
}

// Converters for implicit pointer handles for type: [][]*x509.Certificate
func ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h CGoHandle) *[][]*x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]*x509.Certificate")
	if p == nil {
		return nil
	}
	return p.(*[][]*x509.Certificate)
}
func deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h CGoHandle) [][]*x509.Certificate {
	p := ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]*x509.Certificate", p))
}

// --- wrapping slice: [][]*x509.Certificate ---
//
//export Slice_Slice_Ptr_x509_Certificate_CTor
func Slice_Slice_Ptr_x509_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_Ptr_x509_Certificate(&[][]*x509.Certificate{}))
}

//export Slice_Slice_Ptr_x509_Certificate_len
func Slice_Slice_Ptr_x509_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle))
}

//export Slice_Slice_Ptr_x509_Certificate_elem
func Slice_Slice_Ptr_x509_Certificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	return handleFromPtr_Slice_Ptr_x509_Certificate(&(s[_idx]))
}

//export Slice_Slice_Ptr_x509_Certificate_subslice
func Slice_Slice_Ptr_x509_Certificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_Ptr_x509_Certificate(&ss))
}

//export Slice_Slice_Ptr_x509_Certificate_set
func Slice_Slice_Ptr_x509_Certificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	s[_idx] = deptrFromHandle_Slice_Ptr_x509_Certificate(_vl)
}

//export Slice_Slice_Ptr_x509_Certificate_append
func Slice_Slice_Ptr_x509_Certificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	*s = append(*s, deptrFromHandle_Slice_Ptr_x509_Certificate(_vl))
}

// Converters for implicit pointer handles for type: [][]byte
func ptrFromHandle_Slice_Slice_byte(h CGoHandle) *[][]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]byte")
	if p == nil {
		return nil
	}
	return p.(*[][]byte)
}
func deptrFromHandle_Slice_Slice_byte(h CGoHandle) [][]byte {
	p := ptrFromHandle_Slice_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]byte", p))
}

// --- wrapping slice: [][]byte ---
//
//export Slice_Slice_byte_CTor
func Slice_Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&[][]byte{}))
}

//export Slice_Slice_byte_len
func Slice_Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_byte(handle))
}

//export Slice_Slice_byte_elem
func Slice_Slice_byte_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	return handleFromPtr_Slice_byte(&(s[_idx]))
}

//export Slice_Slice_byte_subslice
func Slice_Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&ss))
}

//export Slice_Slice_byte_set
func Slice_Slice_byte_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	s[_idx] = deptrFromHandle_Slice_byte(_vl)
}

//export Slice_Slice_byte_append
func Slice_Slice_byte_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_byte(handle)
	*s = append(*s, deptrFromHandle_Slice_byte(_vl))
}

// Converters for implicit pointer handles for type: []x509.ExtKeyUsage
func ptrFromHandle_Slice_x509_ExtKeyUsage(h CGoHandle) *[]x509.ExtKeyUsage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]x509.ExtKeyUsage")
	if p == nil {
		return nil
	}
	return p.(*[]x509.ExtKeyUsage)
}
func deptrFromHandle_Slice_x509_ExtKeyUsage(h CGoHandle) []x509.ExtKeyUsage {
	p := ptrFromHandle_Slice_x509_ExtKeyUsage(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_x509_ExtKeyUsage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]x509.ExtKeyUsage", p))
}

// --- wrapping slice: []x509.ExtKeyUsage ---
//
//export Slice_x509_ExtKeyUsage_CTor
func Slice_x509_ExtKeyUsage_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_x509_ExtKeyUsage(&[]x509.ExtKeyUsage{}))
}

//export Slice_x509_ExtKeyUsage_len
func Slice_x509_ExtKeyUsage_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_x509_ExtKeyUsage(handle))
}

//export Slice_x509_ExtKeyUsage_elem
func Slice_x509_ExtKeyUsage_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	return C.longlong(int(s[_idx]))
}

//export Slice_x509_ExtKeyUsage_subslice
func Slice_x509_ExtKeyUsage_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_x509_ExtKeyUsage(&ss))
}

//export Slice_x509_ExtKeyUsage_set
func Slice_x509_ExtKeyUsage_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	s[_idx] = x509.ExtKeyUsage(int(_vl))
}

//export Slice_x509_ExtKeyUsage_append
func Slice_x509_ExtKeyUsage_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	*s = append(*s, x509.ExtKeyUsage(int(_vl)))
}

// Converters for implicit pointer handles for type: []x509.OID
func ptrFromHandle_Slice_x509_OID(h CGoHandle) *[]x509.OID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]x509.OID")
	if p == nil {
		return nil
	}
	return p.(*[]x509.OID)
}
func deptrFromHandle_Slice_x509_OID(h CGoHandle) []x509.OID {
	p := ptrFromHandle_Slice_x509_OID(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_x509_OID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]x509.OID", p))
}

// --- wrapping slice: []x509.OID ---
//
//export Slice_x509_OID_CTor
func Slice_x509_OID_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_x509_OID(&[]x509.OID{}))
}

//export Slice_x509_OID_len
func Slice_x509_OID_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_x509_OID(handle))
}

//export Slice_x509_OID_elem
func Slice_x509_OID_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_x509_OID(handle)
	return handleFromPtr_x509_OID(&(s[_idx]))
}

//export Slice_x509_OID_subslice
func Slice_x509_OID_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_x509_OID(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_x509_OID(&ss))
}

//export Slice_x509_OID_set
func Slice_x509_OID_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_x509_OID(handle)
	s[_idx] = *ptrFromHandle_x509_OID(_vl)
}

//export Slice_x509_OID_append
func Slice_x509_OID_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_x509_OID(handle)
	*s = append(*s, *ptrFromHandle_x509_OID(_vl))
}

// Converters for implicit pointer handles for type: []pkix.AttributeTypeAndValue
func ptrFromHandle_Slice_pkix_AttributeTypeAndValue(h CGoHandle) *[]pkix.AttributeTypeAndValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.AttributeTypeAndValue")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.AttributeTypeAndValue)
}
func deptrFromHandle_Slice_pkix_AttributeTypeAndValue(h CGoHandle) []pkix.AttributeTypeAndValue {
	p := ptrFromHandle_Slice_pkix_AttributeTypeAndValue(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_AttributeTypeAndValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.AttributeTypeAndValue", p))
}

// --- wrapping slice: []pkix.AttributeTypeAndValue ---
//
//export Slice_pkix_AttributeTypeAndValue_CTor
func Slice_pkix_AttributeTypeAndValue_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_AttributeTypeAndValue(&[]pkix.AttributeTypeAndValue{}))
}

//export Slice_pkix_AttributeTypeAndValue_len
func Slice_pkix_AttributeTypeAndValue_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle))
}

//export Slice_pkix_AttributeTypeAndValue_elem
func Slice_pkix_AttributeTypeAndValue_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	return handleFromPtr_pkix_AttributeTypeAndValue(&(s[_idx]))
}

//export Slice_pkix_AttributeTypeAndValue_subslice
func Slice_pkix_AttributeTypeAndValue_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_AttributeTypeAndValue(&ss))
}

//export Slice_pkix_AttributeTypeAndValue_set
func Slice_pkix_AttributeTypeAndValue_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	s[_idx] = *ptrFromHandle_pkix_AttributeTypeAndValue(_vl)
}

//export Slice_pkix_AttributeTypeAndValue_append
func Slice_pkix_AttributeTypeAndValue_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	*s = append(*s, *ptrFromHandle_pkix_AttributeTypeAndValue(_vl))
}

// Converters for implicit pointer handles for type: []pkix.Extension
func ptrFromHandle_Slice_pkix_Extension(h CGoHandle) *[]pkix.Extension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.Extension")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.Extension)
}
func deptrFromHandle_Slice_pkix_Extension(h CGoHandle) []pkix.Extension {
	p := ptrFromHandle_Slice_pkix_Extension(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_Extension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.Extension", p))
}

// --- wrapping slice: []pkix.Extension ---
//
//export Slice_pkix_Extension_CTor
func Slice_pkix_Extension_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_Extension(&[]pkix.Extension{}))
}

//export Slice_pkix_Extension_len
func Slice_pkix_Extension_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_Extension(handle))
}

//export Slice_pkix_Extension_elem
func Slice_pkix_Extension_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	return handleFromPtr_pkix_Extension(&(s[_idx]))
}

//export Slice_pkix_Extension_subslice
func Slice_pkix_Extension_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_Extension(&ss))
}

//export Slice_pkix_Extension_set
func Slice_pkix_Extension_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	s[_idx] = *ptrFromHandle_pkix_Extension(_vl)
}

//export Slice_pkix_Extension_append
func Slice_pkix_Extension_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_Extension(handle)
	*s = append(*s, *ptrFromHandle_pkix_Extension(_vl))
}

// Converters for implicit pointer handles for type: []pkix.RevokedCertificate
func ptrFromHandle_Slice_pkix_RevokedCertificate(h CGoHandle) *[]pkix.RevokedCertificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.RevokedCertificate")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.RevokedCertificate)
}
func deptrFromHandle_Slice_pkix_RevokedCertificate(h CGoHandle) []pkix.RevokedCertificate {
	p := ptrFromHandle_Slice_pkix_RevokedCertificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_RevokedCertificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.RevokedCertificate", p))
}

// --- wrapping slice: []pkix.RevokedCertificate ---
//
//export Slice_pkix_RevokedCertificate_CTor
func Slice_pkix_RevokedCertificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_RevokedCertificate(&[]pkix.RevokedCertificate{}))
}

//export Slice_pkix_RevokedCertificate_len
func Slice_pkix_RevokedCertificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_RevokedCertificate(handle))
}

//export Slice_pkix_RevokedCertificate_elem
func Slice_pkix_RevokedCertificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	return handleFromPtr_pkix_RevokedCertificate(&(s[_idx]))
}

//export Slice_pkix_RevokedCertificate_subslice
func Slice_pkix_RevokedCertificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_RevokedCertificate(&ss))
}

//export Slice_pkix_RevokedCertificate_set
func Slice_pkix_RevokedCertificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	s[_idx] = *ptrFromHandle_pkix_RevokedCertificate(_vl)
}

//export Slice_pkix_RevokedCertificate_append
func Slice_pkix_RevokedCertificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	*s = append(*s, *ptrFromHandle_pkix_RevokedCertificate(_vl))
}

// Converters for implicit pointer handles for type: []asn1.ObjectIdentifier
func ptrFromHandle_Slice_asn1_ObjectIdentifier(h CGoHandle) *[]asn1.ObjectIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]asn1.ObjectIdentifier")
	if p == nil {
		return nil
	}
	return p.(*[]asn1.ObjectIdentifier)
}
func deptrFromHandle_Slice_asn1_ObjectIdentifier(h CGoHandle) []asn1.ObjectIdentifier {
	p := ptrFromHandle_Slice_asn1_ObjectIdentifier(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_asn1_ObjectIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]asn1.ObjectIdentifier", p))
}

// --- wrapping slice: []asn1.ObjectIdentifier ---
//
//export Slice_asn1_ObjectIdentifier_CTor
func Slice_asn1_ObjectIdentifier_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_asn1_ObjectIdentifier(&[]asn1.ObjectIdentifier{}))
}

//export Slice_asn1_ObjectIdentifier_len
func Slice_asn1_ObjectIdentifier_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_asn1_ObjectIdentifier(handle))
}

//export Slice_asn1_ObjectIdentifier_elem
func Slice_asn1_ObjectIdentifier_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	return handleFromPtr_asn1_ObjectIdentifier(&(s[_idx]))
}

//export Slice_asn1_ObjectIdentifier_subslice
func Slice_asn1_ObjectIdentifier_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_asn1_ObjectIdentifier(&ss))
}

//export Slice_asn1_ObjectIdentifier_set
func Slice_asn1_ObjectIdentifier_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	s[_idx] = deptrFromHandle_asn1_ObjectIdentifier(_vl)
}

//export Slice_asn1_ObjectIdentifier_append
func Slice_asn1_ObjectIdentifier_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	*s = append(*s, deptrFromHandle_asn1_ObjectIdentifier(_vl))
}

// Converters for implicit pointer handles for type: []v1.ManagedFieldsEntry
func ptrFromHandle_Slice_v1_ManagedFieldsEntry(h CGoHandle) *[]v1.ManagedFieldsEntry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]v1.ManagedFieldsEntry")
	if p == nil {
		return nil
	}
	return p.(*[]v1.ManagedFieldsEntry)
}
func deptrFromHandle_Slice_v1_ManagedFieldsEntry(h CGoHandle) []v1.ManagedFieldsEntry {
	p := ptrFromHandle_Slice_v1_ManagedFieldsEntry(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_v1_ManagedFieldsEntry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]v1.ManagedFieldsEntry", p))
}

// --- wrapping slice: []v1.ManagedFieldsEntry ---
//
//export Slice_v1_ManagedFieldsEntry_CTor
func Slice_v1_ManagedFieldsEntry_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_v1_ManagedFieldsEntry(&[]v1.ManagedFieldsEntry{}))
}

//export Slice_v1_ManagedFieldsEntry_len
func Slice_v1_ManagedFieldsEntry_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_v1_ManagedFieldsEntry(handle))
}

//export Slice_v1_ManagedFieldsEntry_elem
func Slice_v1_ManagedFieldsEntry_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_v1_ManagedFieldsEntry(handle)
	return handleFromPtr_v1_ManagedFieldsEntry(&(s[_idx]))
}

//export Slice_v1_ManagedFieldsEntry_subslice
func Slice_v1_ManagedFieldsEntry_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_v1_ManagedFieldsEntry(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_v1_ManagedFieldsEntry(&ss))
}

//export Slice_v1_ManagedFieldsEntry_set
func Slice_v1_ManagedFieldsEntry_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_v1_ManagedFieldsEntry(handle)
	s[_idx] = *ptrFromHandle_v1_ManagedFieldsEntry(_vl)
}

//export Slice_v1_ManagedFieldsEntry_append
func Slice_v1_ManagedFieldsEntry_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_v1_ManagedFieldsEntry(handle)
	*s = append(*s, *ptrFromHandle_v1_ManagedFieldsEntry(_vl))
}

// Converters for implicit pointer handles for type: []v1.OwnerReference
func ptrFromHandle_Slice_v1_OwnerReference(h CGoHandle) *[]v1.OwnerReference {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]v1.OwnerReference")
	if p == nil {
		return nil
	}
	return p.(*[]v1.OwnerReference)
}
func deptrFromHandle_Slice_v1_OwnerReference(h CGoHandle) []v1.OwnerReference {
	p := ptrFromHandle_Slice_v1_OwnerReference(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_v1_OwnerReference(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]v1.OwnerReference", p))
}

// --- wrapping slice: []v1.OwnerReference ---
//
//export Slice_v1_OwnerReference_CTor
func Slice_v1_OwnerReference_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_v1_OwnerReference(&[]v1.OwnerReference{}))
}

//export Slice_v1_OwnerReference_len
func Slice_v1_OwnerReference_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_v1_OwnerReference(handle))
}

//export Slice_v1_OwnerReference_elem
func Slice_v1_OwnerReference_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_v1_OwnerReference(handle)
	return handleFromPtr_v1_OwnerReference(&(s[_idx]))
}

//export Slice_v1_OwnerReference_subslice
func Slice_v1_OwnerReference_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_v1_OwnerReference(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_v1_OwnerReference(&ss))
}

//export Slice_v1_OwnerReference_set
func Slice_v1_OwnerReference_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_v1_OwnerReference(handle)
	s[_idx] = *ptrFromHandle_v1_OwnerReference(_vl)
}

//export Slice_v1_OwnerReference_append
func Slice_v1_OwnerReference_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_v1_OwnerReference(handle)
	*s = append(*s, *ptrFromHandle_v1_OwnerReference(_vl))
}

// Converters for implicit pointer handles for type: []runtime.Object
func ptrFromHandle_Slice_runtime_Object(h CGoHandle) *[]runtime.Object {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]runtime.Object")
	if p == nil {
		return nil
	}
	return p.(*[]runtime.Object)
}
func deptrFromHandle_Slice_runtime_Object(h CGoHandle) []runtime.Object {
	p := ptrFromHandle_Slice_runtime_Object(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_runtime_Object(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]runtime.Object", p))
}

// --- wrapping slice: []runtime.Object ---
//
//export Slice_runtime_Object_CTor
func Slice_runtime_Object_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_runtime_Object(&[]runtime.Object{}))
}

//export Slice_runtime_Object_len
func Slice_runtime_Object_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_runtime_Object(handle))
}

//export Slice_runtime_Object_elem
func Slice_runtime_Object_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_runtime_Object(handle)
	return handleFromPtr_runtime_Object(&(s[_idx]))
}

//export Slice_runtime_Object_subslice
func Slice_runtime_Object_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_runtime_Object(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_runtime_Object(&ss))
}

//export Slice_runtime_Object_set
func Slice_runtime_Object_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_runtime_Object(handle)
	s[_idx] = ptrFromHandle_runtime_Object(_vl)
}

//export Slice_runtime_Object_append
func Slice_runtime_Object_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_runtime_Object(handle)
	*s = append(*s, ptrFromHandle_runtime_Object(_vl))
}

// Converters for implicit pointer handles for type: []schema.GroupVersion
func ptrFromHandle_Slice_schema_GroupVersion(h CGoHandle) *[]schema.GroupVersion {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]schema.GroupVersion")
	if p == nil {
		return nil
	}
	return p.(*[]schema.GroupVersion)
}
func deptrFromHandle_Slice_schema_GroupVersion(h CGoHandle) []schema.GroupVersion {
	p := ptrFromHandle_Slice_schema_GroupVersion(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_schema_GroupVersion(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]schema.GroupVersion", p))
}

// --- wrapping slice: []schema.GroupVersion ---
//
//export Slice_schema_GroupVersion_CTor
func Slice_schema_GroupVersion_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersion(&[]schema.GroupVersion{}))
}

//export Slice_schema_GroupVersion_len
func Slice_schema_GroupVersion_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_schema_GroupVersion(handle))
}

//export Slice_schema_GroupVersion_elem
func Slice_schema_GroupVersion_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersion(handle)
	return handleFromPtr_schema_GroupVersion(&(s[_idx]))
}

//export Slice_schema_GroupVersion_subslice
func Slice_schema_GroupVersion_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersion(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersion(&ss))
}

//export Slice_schema_GroupVersion_set
func Slice_schema_GroupVersion_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_schema_GroupVersion(handle)
	s[_idx] = *ptrFromHandle_schema_GroupVersion(_vl)
}

//export Slice_schema_GroupVersion_append
func Slice_schema_GroupVersion_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_schema_GroupVersion(handle)
	*s = append(*s, *ptrFromHandle_schema_GroupVersion(_vl))
}

// Converters for implicit pointer handles for type: []schema.GroupVersionKind
func ptrFromHandle_Slice_schema_GroupVersionKind(h CGoHandle) *[]schema.GroupVersionKind {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]schema.GroupVersionKind")
	if p == nil {
		return nil
	}
	return p.(*[]schema.GroupVersionKind)
}
func deptrFromHandle_Slice_schema_GroupVersionKind(h CGoHandle) []schema.GroupVersionKind {
	p := ptrFromHandle_Slice_schema_GroupVersionKind(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_schema_GroupVersionKind(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]schema.GroupVersionKind", p))
}

// --- wrapping slice: []schema.GroupVersionKind ---
//
//export Slice_schema_GroupVersionKind_CTor
func Slice_schema_GroupVersionKind_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersionKind(&[]schema.GroupVersionKind{}))
}

//export Slice_schema_GroupVersionKind_len
func Slice_schema_GroupVersionKind_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_schema_GroupVersionKind(handle))
}

//export Slice_schema_GroupVersionKind_elem
func Slice_schema_GroupVersionKind_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersionKind(handle)
	return handleFromPtr_schema_GroupVersionKind(&(s[_idx]))
}

//export Slice_schema_GroupVersionKind_subslice
func Slice_schema_GroupVersionKind_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersionKind(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersionKind(&ss))
}

//export Slice_schema_GroupVersionKind_set
func Slice_schema_GroupVersionKind_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_schema_GroupVersionKind(handle)
	s[_idx] = *ptrFromHandle_schema_GroupVersionKind(_vl)
}

//export Slice_schema_GroupVersionKind_append
func Slice_schema_GroupVersionKind_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_schema_GroupVersionKind(handle)
	*s = append(*s, *ptrFromHandle_schema_GroupVersionKind(_vl))
}

// Converters for implicit pointer handles for type: []api.ExecEnvVar
func ptrFromHandle_Slice_api_ExecEnvVar(h CGoHandle) *[]api.ExecEnvVar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]api.ExecEnvVar")
	if p == nil {
		return nil
	}
	return p.(*[]api.ExecEnvVar)
}
func deptrFromHandle_Slice_api_ExecEnvVar(h CGoHandle) []api.ExecEnvVar {
	p := ptrFromHandle_Slice_api_ExecEnvVar(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_api_ExecEnvVar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]api.ExecEnvVar", p))
}

// --- wrapping slice: []api.ExecEnvVar ---
//
//export Slice_api_ExecEnvVar_CTor
func Slice_api_ExecEnvVar_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_api_ExecEnvVar(&[]api.ExecEnvVar{}))
}

//export Slice_api_ExecEnvVar_len
func Slice_api_ExecEnvVar_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_api_ExecEnvVar(handle))
}

//export Slice_api_ExecEnvVar_elem
func Slice_api_ExecEnvVar_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_api_ExecEnvVar(handle)
	return handleFromPtr_api_ExecEnvVar(&(s[_idx]))
}

//export Slice_api_ExecEnvVar_subslice
func Slice_api_ExecEnvVar_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_api_ExecEnvVar(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_api_ExecEnvVar(&ss))
}

//export Slice_api_ExecEnvVar_set
func Slice_api_ExecEnvVar_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_api_ExecEnvVar(handle)
	s[_idx] = *ptrFromHandle_api_ExecEnvVar(_vl)
}

//export Slice_api_ExecEnvVar_append
func Slice_api_ExecEnvVar_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_api_ExecEnvVar(handle)
	*s = append(*s, *ptrFromHandle_api_ExecEnvVar(_vl))
}

// Converters for implicit pointer handles for type: []big.Word
func ptrFromHandle_Slice_big_Word(h CGoHandle) *[]big.Word {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]big.Word")
	if p == nil {
		return nil
	}
	return p.(*[]big.Word)
}
func deptrFromHandle_Slice_big_Word(h CGoHandle) []big.Word {
	p := ptrFromHandle_Slice_big_Word(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_big_Word(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]big.Word", p))
}

// --- wrapping slice: []big.Word ---
//
//export Slice_big_Word_CTor
func Slice_big_Word_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_big_Word(&[]big.Word{}))
}

//export Slice_big_Word_len
func Slice_big_Word_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_big_Word(handle))
}

//export Slice_big_Word_elem
func Slice_big_Word_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_big_Word(handle)
	return C.ulonglong(uint(s[_idx]))
}

//export Slice_big_Word_subslice
func Slice_big_Word_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_big_Word(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_big_Word(&ss))
}

//export Slice_big_Word_set
func Slice_big_Word_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_big_Word(handle)
	s[_idx] = big.Word(uint(_vl))
}

//export Slice_big_Word_append
func Slice_big_Word_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_big_Word(handle)
	*s = append(*s, big.Word(uint(_vl)))
}

// Converters for implicit pointer handles for type: []net.IP
func ptrFromHandle_Slice_net_IP(h CGoHandle) *[]net.IP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]net.IP")
	if p == nil {
		return nil
	}
	return p.(*[]net.IP)
}
func deptrFromHandle_Slice_net_IP(h CGoHandle) []net.IP {
	p := ptrFromHandle_Slice_net_IP(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_net_IP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]net.IP", p))
}

// --- wrapping slice: []net.IP ---
//
//export Slice_net_IP_CTor
func Slice_net_IP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_net_IP(&[]net.IP{}))
}

//export Slice_net_IP_len
func Slice_net_IP_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_net_IP(handle))
}

//export Slice_net_IP_elem
func Slice_net_IP_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_net_IP(handle)
	return handleFromPtr_net_IP(&(s[_idx]))
}

//export Slice_net_IP_subslice
func Slice_net_IP_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_net_IP(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_net_IP(&ss))
}

//export Slice_net_IP_set
func Slice_net_IP_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_net_IP(handle)
	s[_idx] = deptrFromHandle_net_IP(_vl)
}

//export Slice_net_IP_append
func Slice_net_IP_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_net_IP(handle)
	*s = append(*s, deptrFromHandle_net_IP(_vl))
}

// Converters for implicit pointer handles for type: []client.CreateOption
func ptrFromHandle_Slice_client_CreateOption(h CGoHandle) *[]client.CreateOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.CreateOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.CreateOption)
}
func deptrFromHandle_Slice_client_CreateOption(h CGoHandle) []client.CreateOption {
	p := ptrFromHandle_Slice_client_CreateOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_CreateOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.CreateOption", p))
}

// --- wrapping slice: []client.CreateOption ---
//
//export Slice_client_CreateOption_CTor
func Slice_client_CreateOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_CreateOption(&[]client.CreateOption{}))
}

//export Slice_client_CreateOption_len
func Slice_client_CreateOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_CreateOption(handle))
}

//export Slice_client_CreateOption_elem
func Slice_client_CreateOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_CreateOption(handle)
	return handleFromPtr_client_CreateOption(&(s[_idx]))
}

//export Slice_client_CreateOption_subslice
func Slice_client_CreateOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_CreateOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_CreateOption(&ss))
}

//export Slice_client_CreateOption_set
func Slice_client_CreateOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_CreateOption(handle)
	s[_idx] = ptrFromHandle_client_CreateOption(_vl)
}

//export Slice_client_CreateOption_append
func Slice_client_CreateOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_CreateOption(handle)
	*s = append(*s, ptrFromHandle_client_CreateOption(_vl))
}

// Converters for implicit pointer handles for type: []client.DeleteAllOfOption
func ptrFromHandle_Slice_client_DeleteAllOfOption(h CGoHandle) *[]client.DeleteAllOfOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.DeleteAllOfOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.DeleteAllOfOption)
}
func deptrFromHandle_Slice_client_DeleteAllOfOption(h CGoHandle) []client.DeleteAllOfOption {
	p := ptrFromHandle_Slice_client_DeleteAllOfOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_DeleteAllOfOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.DeleteAllOfOption", p))
}

// --- wrapping slice: []client.DeleteAllOfOption ---
//
//export Slice_client_DeleteAllOfOption_CTor
func Slice_client_DeleteAllOfOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_DeleteAllOfOption(&[]client.DeleteAllOfOption{}))
}

//export Slice_client_DeleteAllOfOption_len
func Slice_client_DeleteAllOfOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_DeleteAllOfOption(handle))
}

//export Slice_client_DeleteAllOfOption_elem
func Slice_client_DeleteAllOfOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_DeleteAllOfOption(handle)
	return handleFromPtr_client_DeleteAllOfOption(&(s[_idx]))
}

//export Slice_client_DeleteAllOfOption_subslice
func Slice_client_DeleteAllOfOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_DeleteAllOfOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_DeleteAllOfOption(&ss))
}

//export Slice_client_DeleteAllOfOption_set
func Slice_client_DeleteAllOfOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_DeleteAllOfOption(handle)
	s[_idx] = ptrFromHandle_client_DeleteAllOfOption(_vl)
}

//export Slice_client_DeleteAllOfOption_append
func Slice_client_DeleteAllOfOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_DeleteAllOfOption(handle)
	*s = append(*s, ptrFromHandle_client_DeleteAllOfOption(_vl))
}

// Converters for implicit pointer handles for type: []client.DeleteOption
func ptrFromHandle_Slice_client_DeleteOption(h CGoHandle) *[]client.DeleteOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.DeleteOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.DeleteOption)
}
func deptrFromHandle_Slice_client_DeleteOption(h CGoHandle) []client.DeleteOption {
	p := ptrFromHandle_Slice_client_DeleteOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_DeleteOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.DeleteOption", p))
}

// --- wrapping slice: []client.DeleteOption ---
//
//export Slice_client_DeleteOption_CTor
func Slice_client_DeleteOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_DeleteOption(&[]client.DeleteOption{}))
}

//export Slice_client_DeleteOption_len
func Slice_client_DeleteOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_DeleteOption(handle))
}

//export Slice_client_DeleteOption_elem
func Slice_client_DeleteOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_DeleteOption(handle)
	return handleFromPtr_client_DeleteOption(&(s[_idx]))
}

//export Slice_client_DeleteOption_subslice
func Slice_client_DeleteOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_DeleteOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_DeleteOption(&ss))
}

//export Slice_client_DeleteOption_set
func Slice_client_DeleteOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_DeleteOption(handle)
	s[_idx] = ptrFromHandle_client_DeleteOption(_vl)
}

//export Slice_client_DeleteOption_append
func Slice_client_DeleteOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_DeleteOption(handle)
	*s = append(*s, ptrFromHandle_client_DeleteOption(_vl))
}

// Converters for implicit pointer handles for type: []client.GetOption
func ptrFromHandle_Slice_client_GetOption(h CGoHandle) *[]client.GetOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.GetOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.GetOption)
}
func deptrFromHandle_Slice_client_GetOption(h CGoHandle) []client.GetOption {
	p := ptrFromHandle_Slice_client_GetOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_GetOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.GetOption", p))
}

// --- wrapping slice: []client.GetOption ---
//
//export Slice_client_GetOption_CTor
func Slice_client_GetOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_GetOption(&[]client.GetOption{}))
}

//export Slice_client_GetOption_len
func Slice_client_GetOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_GetOption(handle))
}

//export Slice_client_GetOption_elem
func Slice_client_GetOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_GetOption(handle)
	return handleFromPtr_client_GetOption(&(s[_idx]))
}

//export Slice_client_GetOption_subslice
func Slice_client_GetOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_GetOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_GetOption(&ss))
}

//export Slice_client_GetOption_set
func Slice_client_GetOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_GetOption(handle)
	s[_idx] = ptrFromHandle_client_GetOption(_vl)
}

//export Slice_client_GetOption_append
func Slice_client_GetOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_GetOption(handle)
	*s = append(*s, ptrFromHandle_client_GetOption(_vl))
}

// Converters for implicit pointer handles for type: []client.ListOption
func ptrFromHandle_Slice_client_ListOption(h CGoHandle) *[]client.ListOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.ListOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.ListOption)
}
func deptrFromHandle_Slice_client_ListOption(h CGoHandle) []client.ListOption {
	p := ptrFromHandle_Slice_client_ListOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_ListOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.ListOption", p))
}

// --- wrapping slice: []client.ListOption ---
//
//export Slice_client_ListOption_CTor
func Slice_client_ListOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_ListOption(&[]client.ListOption{}))
}

//export Slice_client_ListOption_len
func Slice_client_ListOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_ListOption(handle))
}

//export Slice_client_ListOption_elem
func Slice_client_ListOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_ListOption(handle)
	return handleFromPtr_client_ListOption(&(s[_idx]))
}

//export Slice_client_ListOption_subslice
func Slice_client_ListOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_ListOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_ListOption(&ss))
}

//export Slice_client_ListOption_set
func Slice_client_ListOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_ListOption(handle)
	s[_idx] = ptrFromHandle_client_ListOption(_vl)
}

//export Slice_client_ListOption_append
func Slice_client_ListOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_ListOption(handle)
	*s = append(*s, ptrFromHandle_client_ListOption(_vl))
}

// Converters for implicit pointer handles for type: []client.MergeFromOption
func ptrFromHandle_Slice_client_MergeFromOption(h CGoHandle) *[]client.MergeFromOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.MergeFromOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.MergeFromOption)
}
func deptrFromHandle_Slice_client_MergeFromOption(h CGoHandle) []client.MergeFromOption {
	p := ptrFromHandle_Slice_client_MergeFromOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_MergeFromOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.MergeFromOption", p))
}

// --- wrapping slice: []client.MergeFromOption ---
//
//export Slice_client_MergeFromOption_CTor
func Slice_client_MergeFromOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_MergeFromOption(&[]client.MergeFromOption{}))
}

//export Slice_client_MergeFromOption_len
func Slice_client_MergeFromOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_MergeFromOption(handle))
}

//export Slice_client_MergeFromOption_elem
func Slice_client_MergeFromOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_MergeFromOption(handle)
	return handleFromPtr_client_MergeFromOption(&(s[_idx]))
}

//export Slice_client_MergeFromOption_subslice
func Slice_client_MergeFromOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_MergeFromOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_MergeFromOption(&ss))
}

//export Slice_client_MergeFromOption_set
func Slice_client_MergeFromOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_MergeFromOption(handle)
	s[_idx] = ptrFromHandle_client_MergeFromOption(_vl)
}

//export Slice_client_MergeFromOption_append
func Slice_client_MergeFromOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_MergeFromOption(handle)
	*s = append(*s, ptrFromHandle_client_MergeFromOption(_vl))
}

// Converters for implicit pointer handles for type: []client.Object
func ptrFromHandle_Slice_client_Object(h CGoHandle) *[]client.Object {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.Object")
	if p == nil {
		return nil
	}
	return p.(*[]client.Object)
}
func deptrFromHandle_Slice_client_Object(h CGoHandle) []client.Object {
	p := ptrFromHandle_Slice_client_Object(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_Object(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.Object", p))
}

// --- wrapping slice: []client.Object ---
//
//export Slice_client_Object_CTor
func Slice_client_Object_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_Object(&[]client.Object{}))
}

//export Slice_client_Object_len
func Slice_client_Object_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_Object(handle))
}

//export Slice_client_Object_elem
func Slice_client_Object_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_Object(handle)
	return handleFromPtr_client_Object(&(s[_idx]))
}

//export Slice_client_Object_subslice
func Slice_client_Object_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_Object(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_Object(&ss))
}

//export Slice_client_Object_set
func Slice_client_Object_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_Object(handle)
	s[_idx] = ptrFromHandle_client_Object(_vl)
}

//export Slice_client_Object_append
func Slice_client_Object_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_Object(handle)
	*s = append(*s, ptrFromHandle_client_Object(_vl))
}

// Converters for implicit pointer handles for type: []client.PatchOption
func ptrFromHandle_Slice_client_PatchOption(h CGoHandle) *[]client.PatchOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.PatchOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.PatchOption)
}
func deptrFromHandle_Slice_client_PatchOption(h CGoHandle) []client.PatchOption {
	p := ptrFromHandle_Slice_client_PatchOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_PatchOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.PatchOption", p))
}

// --- wrapping slice: []client.PatchOption ---
//
//export Slice_client_PatchOption_CTor
func Slice_client_PatchOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_PatchOption(&[]client.PatchOption{}))
}

//export Slice_client_PatchOption_len
func Slice_client_PatchOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_PatchOption(handle))
}

//export Slice_client_PatchOption_elem
func Slice_client_PatchOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_PatchOption(handle)
	return handleFromPtr_client_PatchOption(&(s[_idx]))
}

//export Slice_client_PatchOption_subslice
func Slice_client_PatchOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_PatchOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_PatchOption(&ss))
}

//export Slice_client_PatchOption_set
func Slice_client_PatchOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_PatchOption(handle)
	s[_idx] = ptrFromHandle_client_PatchOption(_vl)
}

//export Slice_client_PatchOption_append
func Slice_client_PatchOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_PatchOption(handle)
	*s = append(*s, ptrFromHandle_client_PatchOption(_vl))
}

// Converters for implicit pointer handles for type: []client.SubResourceCreateOption
func ptrFromHandle_Slice_client_SubResourceCreateOption(h CGoHandle) *[]client.SubResourceCreateOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.SubResourceCreateOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.SubResourceCreateOption)
}
func deptrFromHandle_Slice_client_SubResourceCreateOption(h CGoHandle) []client.SubResourceCreateOption {
	p := ptrFromHandle_Slice_client_SubResourceCreateOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_SubResourceCreateOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.SubResourceCreateOption", p))
}

// --- wrapping slice: []client.SubResourceCreateOption ---
//
//export Slice_client_SubResourceCreateOption_CTor
func Slice_client_SubResourceCreateOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_SubResourceCreateOption(&[]client.SubResourceCreateOption{}))
}

//export Slice_client_SubResourceCreateOption_len
func Slice_client_SubResourceCreateOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_SubResourceCreateOption(handle))
}

//export Slice_client_SubResourceCreateOption_elem
func Slice_client_SubResourceCreateOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_SubResourceCreateOption(handle)
	return handleFromPtr_client_SubResourceCreateOption(&(s[_idx]))
}

//export Slice_client_SubResourceCreateOption_subslice
func Slice_client_SubResourceCreateOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_SubResourceCreateOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_SubResourceCreateOption(&ss))
}

//export Slice_client_SubResourceCreateOption_set
func Slice_client_SubResourceCreateOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_SubResourceCreateOption(handle)
	s[_idx] = ptrFromHandle_client_SubResourceCreateOption(_vl)
}

//export Slice_client_SubResourceCreateOption_append
func Slice_client_SubResourceCreateOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_SubResourceCreateOption(handle)
	*s = append(*s, ptrFromHandle_client_SubResourceCreateOption(_vl))
}

// Converters for implicit pointer handles for type: []client.SubResourceGetOption
func ptrFromHandle_Slice_client_SubResourceGetOption(h CGoHandle) *[]client.SubResourceGetOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.SubResourceGetOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.SubResourceGetOption)
}
func deptrFromHandle_Slice_client_SubResourceGetOption(h CGoHandle) []client.SubResourceGetOption {
	p := ptrFromHandle_Slice_client_SubResourceGetOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_SubResourceGetOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.SubResourceGetOption", p))
}

// --- wrapping slice: []client.SubResourceGetOption ---
//
//export Slice_client_SubResourceGetOption_CTor
func Slice_client_SubResourceGetOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_SubResourceGetOption(&[]client.SubResourceGetOption{}))
}

//export Slice_client_SubResourceGetOption_len
func Slice_client_SubResourceGetOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_SubResourceGetOption(handle))
}

//export Slice_client_SubResourceGetOption_elem
func Slice_client_SubResourceGetOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_SubResourceGetOption(handle)
	return handleFromPtr_client_SubResourceGetOption(&(s[_idx]))
}

//export Slice_client_SubResourceGetOption_subslice
func Slice_client_SubResourceGetOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_SubResourceGetOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_SubResourceGetOption(&ss))
}

//export Slice_client_SubResourceGetOption_set
func Slice_client_SubResourceGetOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_SubResourceGetOption(handle)
	s[_idx] = ptrFromHandle_client_SubResourceGetOption(_vl)
}

//export Slice_client_SubResourceGetOption_append
func Slice_client_SubResourceGetOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_SubResourceGetOption(handle)
	*s = append(*s, ptrFromHandle_client_SubResourceGetOption(_vl))
}

// Converters for implicit pointer handles for type: []client.SubResourcePatchOption
func ptrFromHandle_Slice_client_SubResourcePatchOption(h CGoHandle) *[]client.SubResourcePatchOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.SubResourcePatchOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.SubResourcePatchOption)
}
func deptrFromHandle_Slice_client_SubResourcePatchOption(h CGoHandle) []client.SubResourcePatchOption {
	p := ptrFromHandle_Slice_client_SubResourcePatchOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_SubResourcePatchOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.SubResourcePatchOption", p))
}

// --- wrapping slice: []client.SubResourcePatchOption ---
//
//export Slice_client_SubResourcePatchOption_CTor
func Slice_client_SubResourcePatchOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_SubResourcePatchOption(&[]client.SubResourcePatchOption{}))
}

//export Slice_client_SubResourcePatchOption_len
func Slice_client_SubResourcePatchOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_SubResourcePatchOption(handle))
}

//export Slice_client_SubResourcePatchOption_elem
func Slice_client_SubResourcePatchOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_SubResourcePatchOption(handle)
	return handleFromPtr_client_SubResourcePatchOption(&(s[_idx]))
}

//export Slice_client_SubResourcePatchOption_subslice
func Slice_client_SubResourcePatchOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_SubResourcePatchOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_SubResourcePatchOption(&ss))
}

//export Slice_client_SubResourcePatchOption_set
func Slice_client_SubResourcePatchOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_SubResourcePatchOption(handle)
	s[_idx] = ptrFromHandle_client_SubResourcePatchOption(_vl)
}

//export Slice_client_SubResourcePatchOption_append
func Slice_client_SubResourcePatchOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_SubResourcePatchOption(handle)
	*s = append(*s, ptrFromHandle_client_SubResourcePatchOption(_vl))
}

// Converters for implicit pointer handles for type: []client.SubResourceUpdateOption
func ptrFromHandle_Slice_client_SubResourceUpdateOption(h CGoHandle) *[]client.SubResourceUpdateOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.SubResourceUpdateOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.SubResourceUpdateOption)
}
func deptrFromHandle_Slice_client_SubResourceUpdateOption(h CGoHandle) []client.SubResourceUpdateOption {
	p := ptrFromHandle_Slice_client_SubResourceUpdateOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_SubResourceUpdateOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.SubResourceUpdateOption", p))
}

// --- wrapping slice: []client.SubResourceUpdateOption ---
//
//export Slice_client_SubResourceUpdateOption_CTor
func Slice_client_SubResourceUpdateOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_SubResourceUpdateOption(&[]client.SubResourceUpdateOption{}))
}

//export Slice_client_SubResourceUpdateOption_len
func Slice_client_SubResourceUpdateOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_SubResourceUpdateOption(handle))
}

//export Slice_client_SubResourceUpdateOption_elem
func Slice_client_SubResourceUpdateOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_SubResourceUpdateOption(handle)
	return handleFromPtr_client_SubResourceUpdateOption(&(s[_idx]))
}

//export Slice_client_SubResourceUpdateOption_subslice
func Slice_client_SubResourceUpdateOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_SubResourceUpdateOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_SubResourceUpdateOption(&ss))
}

//export Slice_client_SubResourceUpdateOption_set
func Slice_client_SubResourceUpdateOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_SubResourceUpdateOption(handle)
	s[_idx] = ptrFromHandle_client_SubResourceUpdateOption(_vl)
}

//export Slice_client_SubResourceUpdateOption_append
func Slice_client_SubResourceUpdateOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_SubResourceUpdateOption(handle)
	*s = append(*s, ptrFromHandle_client_SubResourceUpdateOption(_vl))
}

// Converters for implicit pointer handles for type: []client.UpdateOption
func ptrFromHandle_Slice_client_UpdateOption(h CGoHandle) *[]client.UpdateOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.UpdateOption")
	if p == nil {
		return nil
	}
	return p.(*[]client.UpdateOption)
}
func deptrFromHandle_Slice_client_UpdateOption(h CGoHandle) []client.UpdateOption {
	p := ptrFromHandle_Slice_client_UpdateOption(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_UpdateOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.UpdateOption", p))
}

// --- wrapping slice: []client.UpdateOption ---
//
//export Slice_client_UpdateOption_CTor
func Slice_client_UpdateOption_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_UpdateOption(&[]client.UpdateOption{}))
}

//export Slice_client_UpdateOption_len
func Slice_client_UpdateOption_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_UpdateOption(handle))
}

//export Slice_client_UpdateOption_elem
func Slice_client_UpdateOption_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_UpdateOption(handle)
	return handleFromPtr_client_UpdateOption(&(s[_idx]))
}

//export Slice_client_UpdateOption_subslice
func Slice_client_UpdateOption_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_UpdateOption(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_UpdateOption(&ss))
}

//export Slice_client_UpdateOption_set
func Slice_client_UpdateOption_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_UpdateOption(handle)
	s[_idx] = ptrFromHandle_client_UpdateOption(_vl)
}

//export Slice_client_UpdateOption_append
func Slice_client_UpdateOption_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_UpdateOption(handle)
	*s = append(*s, ptrFromHandle_client_UpdateOption(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for implicit pointer handles for type: map[schema.GroupVersionKind]reflect.Type
func ptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(h CGoHandle) *map[schema.GroupVersionKind]reflect.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[schema.GroupVersionKind]reflect.Type")
	if p == nil {
		return nil
	}
	return p.(*map[schema.GroupVersionKind]reflect.Type)
}
func deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(h CGoHandle) map[schema.GroupVersionKind]reflect.Type {
	p := ptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_schema_GroupVersionKind_reflect_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[schema.GroupVersionKind]reflect.Type", p))
}

// --- wrapping map: map[schema.GroupVersionKind]reflect.Type ---
//
//export Map_schema_GroupVersionKind_reflect_Type_CTor
func Map_schema_GroupVersionKind_reflect_Type_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_schema_GroupVersionKind_reflect_Type(&map[schema.GroupVersionKind]reflect.Type{}))
}

//export Map_schema_GroupVersionKind_reflect_Type_len
func Map_schema_GroupVersionKind_reflect_Type_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle))
}

//export Map_schema_GroupVersionKind_reflect_Type_elem
func Map_schema_GroupVersionKind_reflect_Type_elem(handle CGoHandle, _ky CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	v, ok := s[*ptrFromHandle_schema_GroupVersionKind(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_reflect_Type(&v)
}

//export Map_schema_GroupVersionKind_reflect_Type_contains
func Map_schema_GroupVersionKind_reflect_Type_contains(handle CGoHandle, _ky CGoHandle) C.char {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	_, ok := s[*ptrFromHandle_schema_GroupVersionKind(_ky)]
	return boolGoToPy(ok)
}

//export Map_schema_GroupVersionKind_reflect_Type_set
func Map_schema_GroupVersionKind_reflect_Type_set(handle CGoHandle, _ky CGoHandle, _vl CGoHandle) {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	s[*ptrFromHandle_schema_GroupVersionKind(_ky)] = ptrFromHandle_reflect_Type(_vl)
}

//export Map_schema_GroupVersionKind_reflect_Type_delete
func Map_schema_GroupVersionKind_reflect_Type_delete(handle CGoHandle, _ky CGoHandle) {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	delete(s, *ptrFromHandle_schema_GroupVersionKind(_ky))
}

//export Map_schema_GroupVersionKind_reflect_Type_keys
func Map_schema_GroupVersionKind_reflect_Type_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	kys := make([]schema.GroupVersionKind, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_schema_GroupVersionKind(&kys)
}

// Converters for implicit pointer handles for type: map[string][]*multipart.FileHeader
func ptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h CGoHandle) *map[string][]*multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return p.(*map[string][]*multipart.FileHeader)
}
func deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h CGoHandle) map[string][]*multipart.FileHeader {
	p := ptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]*multipart.FileHeader", p))
}

// --- wrapping map: map[string][]*multipart.FileHeader ---
//
//export Map_string_Slice_Ptr_multipart_FileHeader_CTor
func Map_string_Slice_Ptr_multipart_FileHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_Ptr_multipart_FileHeader(&map[string][]*multipart.FileHeader{}))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_len
func Map_string_Slice_Ptr_multipart_FileHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_elem
func Map_string_Slice_Ptr_multipart_FileHeader_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_Ptr_multipart_FileHeader(&v)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_contains
func Map_string_Slice_Ptr_multipart_FileHeader_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_set
func Map_string_Slice_Ptr_multipart_FileHeader_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_Ptr_multipart_FileHeader(_vl)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_delete
func Map_string_Slice_Ptr_multipart_FileHeader_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_keys
func Map_string_Slice_Ptr_multipart_FileHeader_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string][]string
func ptrFromHandle_Map_string_Slice_string(h CGoHandle) *map[string][]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]string")
	if p == nil {
		return nil
	}
	return p.(*map[string][]string)
}
func deptrFromHandle_Map_string_Slice_string(h CGoHandle) map[string][]string {
	p := ptrFromHandle_Map_string_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]string", p))
}

// --- wrapping map: map[string][]string ---
//
//export Map_string_Slice_string_CTor
func Map_string_Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_string(&map[string][]string{}))
}

//export Map_string_Slice_string_len
func Map_string_Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_string(handle))
}

//export Map_string_Slice_string_elem
func Map_string_Slice_string_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export Map_string_Slice_string_contains
func Map_string_Slice_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_string_set
func Map_string_Slice_string_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export Map_string_Slice_string_delete
func Map_string_Slice_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_string_keys
func Map_string_Slice_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]bool
func ptrFromHandle_Map_string_bool(h CGoHandle) *map[string]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]bool")
	if p == nil {
		return nil
	}
	return p.(*map[string]bool)
}
func deptrFromHandle_Map_string_bool(h CGoHandle) map[string]bool {
	p := ptrFromHandle_Map_string_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]bool", p))
}

// --- wrapping map: map[string]bool ---
//
//export Map_string_bool_CTor
func Map_string_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_bool(&map[string]bool{}))
}

//export Map_string_bool_len
func Map_string_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_bool(handle))
}

//export Map_string_bool_elem
func Map_string_bool_elem(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_bool(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return boolGoToPy(v)
}

//export Map_string_bool_contains
func Map_string_bool_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_bool(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_bool_set
func Map_string_bool_set(handle CGoHandle, _ky *C.char, _vl C.char) {
	s := deptrFromHandle_Map_string_bool(handle)
	s[C.GoString(_ky)] = boolPyToGo(_vl)
}

//export Map_string_bool_delete
func Map_string_bool_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_bool(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_bool_keys
func Map_string_bool_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_bool(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]reflect.Type
func ptrFromHandle_Map_string_reflect_Type(h CGoHandle) *map[string]reflect.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]reflect.Type")
	if p == nil {
		return nil
	}
	return p.(*map[string]reflect.Type)
}
func deptrFromHandle_Map_string_reflect_Type(h CGoHandle) map[string]reflect.Type {
	p := ptrFromHandle_Map_string_reflect_Type(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_reflect_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]reflect.Type", p))
}

// --- wrapping map: map[string]reflect.Type ---
//
//export Map_string_reflect_Type_CTor
func Map_string_reflect_Type_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_reflect_Type(&map[string]reflect.Type{}))
}

//export Map_string_reflect_Type_len
func Map_string_reflect_Type_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_reflect_Type(handle))
}

//export Map_string_reflect_Type_elem
func Map_string_reflect_Type_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_reflect_Type(&v)
}

//export Map_string_reflect_Type_contains
func Map_string_reflect_Type_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_reflect_Type_set
func Map_string_reflect_Type_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	s[C.GoString(_ky)] = ptrFromHandle_reflect_Type(_vl)
}

//export Map_string_reflect_Type_delete
func Map_string_reflect_Type_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_reflect_Type_keys
func Map_string_reflect_Type_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]string
func ptrFromHandle_Map_string_string(h CGoHandle) *map[string]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]string")
	if p == nil {
		return nil
	}
	return p.(*map[string]string)
}
func deptrFromHandle_Map_string_string(h CGoHandle) map[string]string {
	p := ptrFromHandle_Map_string_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]string", p))
}

// --- wrapping map: map[string]string ---
//
//export Map_string_string_CTor
func Map_string_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_string(&map[string]string{}))
}

//export Map_string_string_len
func Map_string_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_string(handle))
}

//export Map_string_string_elem
func Map_string_string_elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_Map_string_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(v)
}

//export Map_string_string_contains
func Map_string_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_string_set
func Map_string_string_set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export Map_string_string_delete
func Map_string_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_string_keys
func Map_string_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: client.CacheOptions
func ptrFromHandle_client_CacheOptions(h CGoHandle) *client.CacheOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.CacheOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.CacheOptions{})).(*client.CacheOptions)
}
func handleFromPtr_client_CacheOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.CacheOptions", p))
}

// Converters for pointer handles for type: client.Client
func ptrFromHandle_client_Client(h CGoHandle) client.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.Client")
	if p == nil {
		return nil
	}
	return p.(client.Client)
}
func handleFromPtr_client_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.Client", p))
}

// Converters for pointer handles for type: client.CreateOption
func ptrFromHandle_client_CreateOption(h CGoHandle) client.CreateOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.CreateOption")
	if p == nil {
		return nil
	}
	return p.(client.CreateOption)
}
func handleFromPtr_client_CreateOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.CreateOption", p))
}

// Converters for non-pointer handles for type: client.CreateOptions
func ptrFromHandle_client_CreateOptions(h CGoHandle) *client.CreateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.CreateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.CreateOptions{})).(*client.CreateOptions)
}
func handleFromPtr_client_CreateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.CreateOptions", p))
}

// Converters for pointer handles for type: client.DeleteAllOfOption
func ptrFromHandle_client_DeleteAllOfOption(h CGoHandle) client.DeleteAllOfOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.DeleteAllOfOption")
	if p == nil {
		return nil
	}
	return p.(client.DeleteAllOfOption)
}
func handleFromPtr_client_DeleteAllOfOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.DeleteAllOfOption", p))
}

// Converters for non-pointer handles for type: client.DeleteAllOfOptions
func ptrFromHandle_client_DeleteAllOfOptions(h CGoHandle) *client.DeleteAllOfOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.DeleteAllOfOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.DeleteAllOfOptions{})).(*client.DeleteAllOfOptions)
}
func handleFromPtr_client_DeleteAllOfOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.DeleteAllOfOptions", p))
}

// Converters for pointer handles for type: client.DeleteOption
func ptrFromHandle_client_DeleteOption(h CGoHandle) client.DeleteOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.DeleteOption")
	if p == nil {
		return nil
	}
	return p.(client.DeleteOption)
}
func handleFromPtr_client_DeleteOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.DeleteOption", p))
}

// Converters for non-pointer handles for type: client.DeleteOptions
func ptrFromHandle_client_DeleteOptions(h CGoHandle) *client.DeleteOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.DeleteOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.DeleteOptions{})).(*client.DeleteOptions)
}
func handleFromPtr_client_DeleteOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.DeleteOptions", p))
}

// Converters for pointer handles for type: client.FieldIndexer
func ptrFromHandle_client_FieldIndexer(h CGoHandle) client.FieldIndexer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.FieldIndexer")
	if p == nil {
		return nil
	}
	return p.(client.FieldIndexer)
}
func handleFromPtr_client_FieldIndexer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.FieldIndexer", p))
}

// Converters for pointer handles for type: client.GetOption
func ptrFromHandle_client_GetOption(h CGoHandle) client.GetOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.GetOption")
	if p == nil {
		return nil
	}
	return p.(client.GetOption)
}
func handleFromPtr_client_GetOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.GetOption", p))
}

// Converters for non-pointer handles for type: client.GetOptions
func ptrFromHandle_client_GetOptions(h CGoHandle) *client.GetOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.GetOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.GetOptions{})).(*client.GetOptions)
}
func handleFromPtr_client_GetOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.GetOptions", p))
}

// Converters for implicit pointer handles for type: client.HasLabels
func ptrFromHandle_client_HasLabels(h CGoHandle) *client.HasLabels {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.HasLabels")
	if p == nil {
		return nil
	}
	return p.(*client.HasLabels)
}
func deptrFromHandle_client_HasLabels(h CGoHandle) client.HasLabels {
	p := ptrFromHandle_client_HasLabels(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_client_HasLabels(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.HasLabels", p))
}

// Converters for pointer handles for type: client.ListOption
func ptrFromHandle_client_ListOption(h CGoHandle) client.ListOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.ListOption")
	if p == nil {
		return nil
	}
	return p.(client.ListOption)
}
func handleFromPtr_client_ListOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.ListOption", p))
}

// Converters for non-pointer handles for type: client.ListOptions
func ptrFromHandle_client_ListOptions(h CGoHandle) *client.ListOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.ListOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.ListOptions{})).(*client.ListOptions)
}
func handleFromPtr_client_ListOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.ListOptions", p))
}

// Converters for implicit pointer handles for type: client.MatchingFields
func ptrFromHandle_client_MatchingFields(h CGoHandle) *client.MatchingFields {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.MatchingFields")
	if p == nil {
		return nil
	}
	return p.(*client.MatchingFields)
}
func deptrFromHandle_client_MatchingFields(h CGoHandle) client.MatchingFields {
	p := ptrFromHandle_client_MatchingFields(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_client_MatchingFields(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.MatchingFields", p))
}

// Converters for non-pointer handles for type: client.MatchingFieldsSelector
func ptrFromHandle_client_MatchingFieldsSelector(h CGoHandle) *client.MatchingFieldsSelector {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.MatchingFieldsSelector")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.MatchingFieldsSelector{})).(*client.MatchingFieldsSelector)
}
func handleFromPtr_client_MatchingFieldsSelector(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.MatchingFieldsSelector", p))
}

// Converters for implicit pointer handles for type: client.MatchingLabels
func ptrFromHandle_client_MatchingLabels(h CGoHandle) *client.MatchingLabels {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.MatchingLabels")
	if p == nil {
		return nil
	}
	return p.(*client.MatchingLabels)
}
func deptrFromHandle_client_MatchingLabels(h CGoHandle) client.MatchingLabels {
	p := ptrFromHandle_client_MatchingLabels(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_client_MatchingLabels(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.MatchingLabels", p))
}

// Converters for non-pointer handles for type: client.MatchingLabelsSelector
func ptrFromHandle_client_MatchingLabelsSelector(h CGoHandle) *client.MatchingLabelsSelector {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.MatchingLabelsSelector")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.MatchingLabelsSelector{})).(*client.MatchingLabelsSelector)
}
func handleFromPtr_client_MatchingLabelsSelector(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.MatchingLabelsSelector", p))
}

// Converters for pointer handles for type: client.MergeFromOption
func ptrFromHandle_client_MergeFromOption(h CGoHandle) client.MergeFromOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.MergeFromOption")
	if p == nil {
		return nil
	}
	return p.(client.MergeFromOption)
}
func handleFromPtr_client_MergeFromOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.MergeFromOption", p))
}

// Converters for non-pointer handles for type: client.MergeFromOptions
func ptrFromHandle_client_MergeFromOptions(h CGoHandle) *client.MergeFromOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.MergeFromOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.MergeFromOptions{})).(*client.MergeFromOptions)
}
func handleFromPtr_client_MergeFromOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.MergeFromOptions", p))
}

// Converters for non-pointer handles for type: client.MergeFromWithOptimisticLock
func ptrFromHandle_client_MergeFromWithOptimisticLock(h CGoHandle) *client.MergeFromWithOptimisticLock {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.MergeFromWithOptimisticLock")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.MergeFromWithOptimisticLock{})).(*client.MergeFromWithOptimisticLock)
}
func handleFromPtr_client_MergeFromWithOptimisticLock(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.MergeFromWithOptimisticLock", p))
}

// Converters for pointer handles for type: client.Object
func ptrFromHandle_client_Object(h CGoHandle) client.Object {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.Object")
	if p == nil {
		return nil
	}
	return p.(client.Object)
}
func handleFromPtr_client_Object(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.Object", p))
}

// Converters for pointer handles for type: client.ObjectList
func ptrFromHandle_client_ObjectList(h CGoHandle) client.ObjectList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.ObjectList")
	if p == nil {
		return nil
	}
	return p.(client.ObjectList)
}
func handleFromPtr_client_ObjectList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.ObjectList", p))
}

// Converters for non-pointer handles for type: client.Options
func ptrFromHandle_client_Options(h CGoHandle) *client.Options {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.Options")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.Options{})).(*client.Options)
}
func handleFromPtr_client_Options(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.Options", p))
}

// Converters for pointer handles for type: client.Patch
func ptrFromHandle_client_Patch(h CGoHandle) client.Patch {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.Patch")
	if p == nil {
		return nil
	}
	return p.(client.Patch)
}
func handleFromPtr_client_Patch(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.Patch", p))
}

// Converters for pointer handles for type: client.PatchOption
func ptrFromHandle_client_PatchOption(h CGoHandle) client.PatchOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.PatchOption")
	if p == nil {
		return nil
	}
	return p.(client.PatchOption)
}
func handleFromPtr_client_PatchOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.PatchOption", p))
}

// Converters for non-pointer handles for type: client.PatchOptions
func ptrFromHandle_client_PatchOptions(h CGoHandle) *client.PatchOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.PatchOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.PatchOptions{})).(*client.PatchOptions)
}
func handleFromPtr_client_PatchOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.PatchOptions", p))
}

// Converters for non-pointer handles for type: client.Preconditions
func ptrFromHandle_client_Preconditions(h CGoHandle) *client.Preconditions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.Preconditions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.Preconditions{})).(*client.Preconditions)
}
func handleFromPtr_client_Preconditions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.Preconditions", p))
}

// Converters for pointer handles for type: client.Reader
func ptrFromHandle_client_Reader(h CGoHandle) client.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.Reader")
	if p == nil {
		return nil
	}
	return p.(client.Reader)
}
func handleFromPtr_client_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.Reader", p))
}

// Converters for pointer handles for type: client.StatusClient
func ptrFromHandle_client_StatusClient(h CGoHandle) client.StatusClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.StatusClient")
	if p == nil {
		return nil
	}
	return p.(client.StatusClient)
}
func handleFromPtr_client_StatusClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.StatusClient", p))
}

// Converters for pointer handles for type: client.SubResourceClient
func ptrFromHandle_client_SubResourceClient(h CGoHandle) client.SubResourceClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourceClient")
	if p == nil {
		return nil
	}
	return p.(client.SubResourceClient)
}
func handleFromPtr_client_SubResourceClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourceClient", p))
}

// Converters for pointer handles for type: client.SubResourceClientConstructor
func ptrFromHandle_client_SubResourceClientConstructor(h CGoHandle) client.SubResourceClientConstructor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourceClientConstructor")
	if p == nil {
		return nil
	}
	return p.(client.SubResourceClientConstructor)
}
func handleFromPtr_client_SubResourceClientConstructor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourceClientConstructor", p))
}

// Converters for pointer handles for type: client.SubResourceCreateOption
func ptrFromHandle_client_SubResourceCreateOption(h CGoHandle) client.SubResourceCreateOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourceCreateOption")
	if p == nil {
		return nil
	}
	return p.(client.SubResourceCreateOption)
}
func handleFromPtr_client_SubResourceCreateOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourceCreateOption", p))
}

// Converters for non-pointer handles for type: client.SubResourceCreateOptions
func ptrFromHandle_client_SubResourceCreateOptions(h CGoHandle) *client.SubResourceCreateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourceCreateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.SubResourceCreateOptions{})).(*client.SubResourceCreateOptions)
}
func handleFromPtr_client_SubResourceCreateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourceCreateOptions", p))
}

// Converters for pointer handles for type: client.SubResourceGetOption
func ptrFromHandle_client_SubResourceGetOption(h CGoHandle) client.SubResourceGetOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourceGetOption")
	if p == nil {
		return nil
	}
	return p.(client.SubResourceGetOption)
}
func handleFromPtr_client_SubResourceGetOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourceGetOption", p))
}

// Converters for non-pointer handles for type: client.SubResourceGetOptions
func ptrFromHandle_client_SubResourceGetOptions(h CGoHandle) *client.SubResourceGetOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourceGetOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.SubResourceGetOptions{})).(*client.SubResourceGetOptions)
}
func handleFromPtr_client_SubResourceGetOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourceGetOptions", p))
}

// Converters for pointer handles for type: client.SubResourcePatchOption
func ptrFromHandle_client_SubResourcePatchOption(h CGoHandle) client.SubResourcePatchOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourcePatchOption")
	if p == nil {
		return nil
	}
	return p.(client.SubResourcePatchOption)
}
func handleFromPtr_client_SubResourcePatchOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourcePatchOption", p))
}

// Converters for non-pointer handles for type: client.SubResourcePatchOptions
func ptrFromHandle_client_SubResourcePatchOptions(h CGoHandle) *client.SubResourcePatchOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourcePatchOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.SubResourcePatchOptions{})).(*client.SubResourcePatchOptions)
}
func handleFromPtr_client_SubResourcePatchOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourcePatchOptions", p))
}

// Converters for pointer handles for type: client.SubResourceReader
func ptrFromHandle_client_SubResourceReader(h CGoHandle) client.SubResourceReader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourceReader")
	if p == nil {
		return nil
	}
	return p.(client.SubResourceReader)
}
func handleFromPtr_client_SubResourceReader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourceReader", p))
}

// Converters for pointer handles for type: client.SubResourceUpdateAndPatchOption
func ptrFromHandle_client_SubResourceUpdateAndPatchOption(h CGoHandle) client.SubResourceUpdateAndPatchOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourceUpdateAndPatchOption")
	if p == nil {
		return nil
	}
	return p.(client.SubResourceUpdateAndPatchOption)
}
func handleFromPtr_client_SubResourceUpdateAndPatchOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourceUpdateAndPatchOption", p))
}

// Converters for pointer handles for type: client.SubResourceUpdateOption
func ptrFromHandle_client_SubResourceUpdateOption(h CGoHandle) client.SubResourceUpdateOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourceUpdateOption")
	if p == nil {
		return nil
	}
	return p.(client.SubResourceUpdateOption)
}
func handleFromPtr_client_SubResourceUpdateOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourceUpdateOption", p))
}

// Converters for non-pointer handles for type: client.SubResourceUpdateOptions
func ptrFromHandle_client_SubResourceUpdateOptions(h CGoHandle) *client.SubResourceUpdateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourceUpdateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.SubResourceUpdateOptions{})).(*client.SubResourceUpdateOptions)
}
func handleFromPtr_client_SubResourceUpdateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourceUpdateOptions", p))
}

// Converters for pointer handles for type: client.SubResourceWriter
func ptrFromHandle_client_SubResourceWriter(h CGoHandle) client.SubResourceWriter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.SubResourceWriter")
	if p == nil {
		return nil
	}
	return p.(client.SubResourceWriter)
}
func handleFromPtr_client_SubResourceWriter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.SubResourceWriter", p))
}

// Converters for pointer handles for type: client.UpdateOption
func ptrFromHandle_client_UpdateOption(h CGoHandle) client.UpdateOption {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.UpdateOption")
	if p == nil {
		return nil
	}
	return p.(client.UpdateOption)
}
func handleFromPtr_client_UpdateOption(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.UpdateOption", p))
}

// Converters for non-pointer handles for type: client.UpdateOptions
func ptrFromHandle_client_UpdateOptions(h CGoHandle) *client.UpdateOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.UpdateOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.UpdateOptions{})).(*client.UpdateOptions)
}
func handleFromPtr_client_UpdateOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.UpdateOptions", p))
}

// Converters for pointer handles for type: client.WithWatch
func ptrFromHandle_client_WithWatch(h CGoHandle) client.WithWatch {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.WithWatch")
	if p == nil {
		return nil
	}
	return p.(client.WithWatch)
}
func handleFromPtr_client_WithWatch(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.WithWatch", p))
}

// Converters for pointer handles for type: client.Writer
func ptrFromHandle_client_Writer(h CGoHandle) client.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.Writer")
	if p == nil {
		return nil
	}
	return p.(client.Writer)
}
func handleFromPtr_client_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.Writer", p))
}

// ---- Global Variables: can only use functions to access ---
//
//export client_Apply
func client_Apply() CGoHandle {
	return handleFromPtr_client_Patch(client.Apply)
}

//export client_Set_Apply
func client_Set_Apply(val CGoHandle) {
	client.Apply = ptrFromHandle_client_Patch(val)
}

//export client_Merge
func client_Merge() CGoHandle {
	return handleFromPtr_client_Patch(client.Merge)
}

//export client_Set_Merge
func client_Set_Merge(val CGoHandle) {
	client.Merge = ptrFromHandle_client_Patch(val)
}

// ---- Interfaces ---

//export client_Reader_Get
func client_Reader_Get(_handle CGoHandle, ctx CGoHandle, key CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Reader")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Reader).Get(ptrFromHandle_context_Context(ctx), *ptrFromHandle_types_NamespacedName(key), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_GetOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Reader_List
func client_Reader_List(_handle CGoHandle, ctx CGoHandle, list CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Reader")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Reader).List(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_ObjectList(list), deptrFromHandle_Slice_client_ListOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_StatusClient_Status
func client_StatusClient_Status(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.StatusClient")
	if __err != nil {
		return handleFromPtr_client_SubResourceWriter(nil)
	}
	return handleFromPtr_client_SubResourceWriter(vifc.(client.StatusClient).Status())

}

//export client_SubResourceUpdateAndPatchOption_ApplyToSubResourcePatch
func client_SubResourceUpdateAndPatchOption_ApplyToSubResourcePatch(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceUpdateAndPatchOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.SubResourceUpdateAndPatchOption).ApplyToSubResourcePatch(ptrFromHandle_Ptr_client_SubResourcePatchOptions(arg_0))
	} else {
		vifc.(client.SubResourceUpdateAndPatchOption).ApplyToSubResourcePatch(ptrFromHandle_Ptr_client_SubResourcePatchOptions(arg_0))
	}
}

//export client_SubResourceUpdateAndPatchOption_ApplyToSubResourceUpdate
func client_SubResourceUpdateAndPatchOption_ApplyToSubResourceUpdate(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceUpdateAndPatchOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.SubResourceUpdateAndPatchOption).ApplyToSubResourceUpdate(ptrFromHandle_Ptr_client_SubResourceUpdateOptions(arg_0))
	} else {
		vifc.(client.SubResourceUpdateAndPatchOption).ApplyToSubResourceUpdate(ptrFromHandle_Ptr_client_SubResourceUpdateOptions(arg_0))
	}
}

//export client_GetOption_ApplyToGet
func client_GetOption_ApplyToGet(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.GetOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.GetOption).ApplyToGet(ptrFromHandle_Ptr_client_GetOptions(arg_0))
	} else {
		vifc.(client.GetOption).ApplyToGet(ptrFromHandle_Ptr_client_GetOptions(arg_0))
	}
}

//export client_ObjectList_DeepCopyObject
func client_ObjectList_DeepCopyObject(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ObjectList")
	if __err != nil {
		return handleFromPtr_runtime_Object(nil)
	}
	return handleFromPtr_runtime_Object(vifc.(client.ObjectList).DeepCopyObject())

}

//export client_ObjectList_GetContinue
func client_ObjectList_GetContinue(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ObjectList")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(client.ObjectList).GetContinue())

}

//export client_ObjectList_GetObjectKind
func client_ObjectList_GetObjectKind(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ObjectList")
	if __err != nil {
		return handleFromPtr_schema_ObjectKind(nil)
	}
	return handleFromPtr_schema_ObjectKind(vifc.(client.ObjectList).GetObjectKind())

}

//export client_ObjectList_GetResourceVersion
func client_ObjectList_GetResourceVersion(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ObjectList")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(client.ObjectList).GetResourceVersion())

}

//export client_ObjectList_GetSelfLink
func client_ObjectList_GetSelfLink(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ObjectList")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(client.ObjectList).GetSelfLink())

}

//export client_ObjectList_SetContinue
func client_ObjectList_SetContinue(_handle CGoHandle, c *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ObjectList")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.ObjectList).SetContinue(C.GoString(c))
	} else {
		vifc.(client.ObjectList).SetContinue(C.GoString(c))
	}
}

//export client_ObjectList_SetResourceVersion
func client_ObjectList_SetResourceVersion(_handle CGoHandle, version *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ObjectList")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.ObjectList).SetResourceVersion(C.GoString(version))
	} else {
		vifc.(client.ObjectList).SetResourceVersion(C.GoString(version))
	}
}

//export client_ObjectList_SetSelfLink
func client_ObjectList_SetSelfLink(_handle CGoHandle, selfLink *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ObjectList")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.ObjectList).SetSelfLink(C.GoString(selfLink))
	} else {
		vifc.(client.ObjectList).SetSelfLink(C.GoString(selfLink))
	}
}

//export client_SubResourcePatchOption_ApplyToSubResourcePatch
func client_SubResourcePatchOption_ApplyToSubResourcePatch(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourcePatchOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.SubResourcePatchOption).ApplyToSubResourcePatch(ptrFromHandle_Ptr_client_SubResourcePatchOptions(arg_0))
	} else {
		vifc.(client.SubResourcePatchOption).ApplyToSubResourcePatch(ptrFromHandle_Ptr_client_SubResourcePatchOptions(arg_0))
	}
}

//export client_CreateOption_ApplyToCreate
func client_CreateOption_ApplyToCreate(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.CreateOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.CreateOption).ApplyToCreate(ptrFromHandle_Ptr_client_CreateOptions(arg_0))
	} else {
		vifc.(client.CreateOption).ApplyToCreate(ptrFromHandle_Ptr_client_CreateOptions(arg_0))
	}
}

//export client_DeleteOption_ApplyToDelete
func client_DeleteOption_ApplyToDelete(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.DeleteOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.DeleteOption).ApplyToDelete(ptrFromHandle_Ptr_client_DeleteOptions(arg_0))
	} else {
		vifc.(client.DeleteOption).ApplyToDelete(ptrFromHandle_Ptr_client_DeleteOptions(arg_0))
	}
}

//export client_Object_DeepCopyObject
func client_Object_DeepCopyObject(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return handleFromPtr_runtime_Object(nil)
	}
	return handleFromPtr_runtime_Object(vifc.(client.Object).DeepCopyObject())

}

//export client_Object_GetAnnotations
func client_Object_GetAnnotations(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return handleFromPtr_Map_string_string(nil)
	}
	cret := vifc.(client.Object).GetAnnotations()

	return handleFromPtr_Map_string_string(&cret)
}

//export client_Object_GetCreationTimestamp
func client_Object_GetCreationTimestamp(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return handleFromPtr_v1_Time(nil)
	}
	cret := vifc.(client.Object).GetCreationTimestamp()

	return handleFromPtr_v1_Time(&cret)
}

//export client_Object_GetDeletionTimestamp
func client_Object_GetDeletionTimestamp(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return handleFromPtr_Ptr_v1_Time(nil)
	}
	return handleFromPtr_Ptr_v1_Time(vifc.(client.Object).GetDeletionTimestamp())

}

//export client_Object_GetFinalizers
func client_Object_GetFinalizers(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return handleFromPtr_Slice_string(nil)
	}
	cret := vifc.(client.Object).GetFinalizers()

	return handleFromPtr_Slice_string(&cret)
}

//export client_Object_GetGenerateName
func client_Object_GetGenerateName(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(client.Object).GetGenerateName())

}

//export client_Object_GetGeneration
func client_Object_GetGeneration(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(vifc.(client.Object).GetGeneration())

}

//export client_Object_GetLabels
func client_Object_GetLabels(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return handleFromPtr_Map_string_string(nil)
	}
	cret := vifc.(client.Object).GetLabels()

	return handleFromPtr_Map_string_string(&cret)
}

//export client_Object_GetManagedFields
func client_Object_GetManagedFields(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return handleFromPtr_Slice_v1_ManagedFieldsEntry(nil)
	}
	cret := vifc.(client.Object).GetManagedFields()

	return handleFromPtr_Slice_v1_ManagedFieldsEntry(&cret)
}

//export client_Object_GetName
func client_Object_GetName(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(client.Object).GetName())

}

//export client_Object_GetNamespace
func client_Object_GetNamespace(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(client.Object).GetNamespace())

}

//export client_Object_GetObjectKind
func client_Object_GetObjectKind(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return handleFromPtr_schema_ObjectKind(nil)
	}
	return handleFromPtr_schema_ObjectKind(vifc.(client.Object).GetObjectKind())

}

//export client_Object_GetOwnerReferences
func client_Object_GetOwnerReferences(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return handleFromPtr_Slice_v1_OwnerReference(nil)
	}
	cret := vifc.(client.Object).GetOwnerReferences()

	return handleFromPtr_Slice_v1_OwnerReference(&cret)
}

//export client_Object_GetResourceVersion
func client_Object_GetResourceVersion(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(client.Object).GetResourceVersion())

}

//export client_Object_GetSelfLink
func client_Object_GetSelfLink(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(client.Object).GetSelfLink())

}

//export client_Object_GetUID
func client_Object_GetUID(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return C.CString(string(""))
	}
	return C.CString(string(vifc.(client.Object).GetUID()))

}

//export client_Object_SetAnnotations
func client_Object_SetAnnotations(_handle CGoHandle, annotations CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetAnnotations(deptrFromHandle_Map_string_string(annotations))
	} else {
		vifc.(client.Object).SetAnnotations(deptrFromHandle_Map_string_string(annotations))
	}
}

//export client_Object_SetCreationTimestamp
func client_Object_SetCreationTimestamp(_handle CGoHandle, timestamp CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetCreationTimestamp(*ptrFromHandle_v1_Time(timestamp))
	} else {
		vifc.(client.Object).SetCreationTimestamp(*ptrFromHandle_v1_Time(timestamp))
	}
}

//export client_Object_SetDeletionTimestamp
func client_Object_SetDeletionTimestamp(_handle CGoHandle, timestamp CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetDeletionTimestamp(ptrFromHandle_Ptr_v1_Time(timestamp))
	} else {
		vifc.(client.Object).SetDeletionTimestamp(ptrFromHandle_Ptr_v1_Time(timestamp))
	}
}

//export client_Object_SetFinalizers
func client_Object_SetFinalizers(_handle CGoHandle, finalizers CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetFinalizers(deptrFromHandle_Slice_string(finalizers))
	} else {
		vifc.(client.Object).SetFinalizers(deptrFromHandle_Slice_string(finalizers))
	}
}

//export client_Object_SetGenerateName
func client_Object_SetGenerateName(_handle CGoHandle, name *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetGenerateName(C.GoString(name))
	} else {
		vifc.(client.Object).SetGenerateName(C.GoString(name))
	}
}

//export client_Object_SetGeneration
func client_Object_SetGeneration(_handle CGoHandle, generation C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetGeneration(int64(generation))
	} else {
		vifc.(client.Object).SetGeneration(int64(generation))
	}
}

//export client_Object_SetLabels
func client_Object_SetLabels(_handle CGoHandle, labels CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetLabels(deptrFromHandle_Map_string_string(labels))
	} else {
		vifc.(client.Object).SetLabels(deptrFromHandle_Map_string_string(labels))
	}
}

//export client_Object_SetManagedFields
func client_Object_SetManagedFields(_handle CGoHandle, managedFields CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetManagedFields(deptrFromHandle_Slice_v1_ManagedFieldsEntry(managedFields))
	} else {
		vifc.(client.Object).SetManagedFields(deptrFromHandle_Slice_v1_ManagedFieldsEntry(managedFields))
	}
}

//export client_Object_SetName
func client_Object_SetName(_handle CGoHandle, name *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetName(C.GoString(name))
	} else {
		vifc.(client.Object).SetName(C.GoString(name))
	}
}

//export client_Object_SetNamespace
func client_Object_SetNamespace(_handle CGoHandle, namespace *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetNamespace(C.GoString(namespace))
	} else {
		vifc.(client.Object).SetNamespace(C.GoString(namespace))
	}
}

//export client_Object_SetOwnerReferences
func client_Object_SetOwnerReferences(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetOwnerReferences(deptrFromHandle_Slice_v1_OwnerReference(arg_0))
	} else {
		vifc.(client.Object).SetOwnerReferences(deptrFromHandle_Slice_v1_OwnerReference(arg_0))
	}
}

//export client_Object_SetResourceVersion
func client_Object_SetResourceVersion(_handle CGoHandle, version *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetResourceVersion(C.GoString(version))
	} else {
		vifc.(client.Object).SetResourceVersion(C.GoString(version))
	}
}

//export client_Object_SetSelfLink
func client_Object_SetSelfLink(_handle CGoHandle, selfLink *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetSelfLink(C.GoString(selfLink))
	} else {
		vifc.(client.Object).SetSelfLink(C.GoString(selfLink))
	}
}

//export client_Object_SetUID
func client_Object_SetUID(_handle CGoHandle, uid *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Object")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.Object).SetUID(types.UID(C.GoString(uid)))
	} else {
		vifc.(client.Object).SetUID(types.UID(C.GoString(uid)))
	}
}

//export client_Writer_Create
func client_Writer_Create(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Writer")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Writer).Create(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_CreateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Writer_Delete
func client_Writer_Delete(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Writer")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Writer).Delete(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_DeleteOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Writer_DeleteAllOf
func client_Writer_DeleteAllOf(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Writer")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Writer).DeleteAllOf(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_DeleteAllOfOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Writer_Patch
func client_Writer_Patch(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, patch CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Writer")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Writer).Patch(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), ptrFromHandle_client_Patch(patch), deptrFromHandle_Slice_client_PatchOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Writer_Update
func client_Writer_Update(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Writer")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Writer).Update(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_UpdateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_MergeFromOption_ApplyToMergeFrom
func client_MergeFromOption_ApplyToMergeFrom(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.MergeFromOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.MergeFromOption).ApplyToMergeFrom(ptrFromHandle_Ptr_client_MergeFromOptions(arg_0))
	} else {
		vifc.(client.MergeFromOption).ApplyToMergeFrom(ptrFromHandle_Ptr_client_MergeFromOptions(arg_0))
	}
}

//export client_PatchOption_ApplyToPatch
func client_PatchOption_ApplyToPatch(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.PatchOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.PatchOption).ApplyToPatch(ptrFromHandle_Ptr_client_PatchOptions(arg_0))
	} else {
		vifc.(client.PatchOption).ApplyToPatch(ptrFromHandle_Ptr_client_PatchOptions(arg_0))
	}
}

//export client_SubResourceGetOption_ApplyToSubResourceGet
func client_SubResourceGetOption_ApplyToSubResourceGet(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceGetOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.SubResourceGetOption).ApplyToSubResourceGet(ptrFromHandle_Ptr_client_SubResourceGetOptions(arg_0))
	} else {
		vifc.(client.SubResourceGetOption).ApplyToSubResourceGet(ptrFromHandle_Ptr_client_SubResourceGetOptions(arg_0))
	}
}

//export client_SubResourceReader_Get
func client_SubResourceReader_Get(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, subResource CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceReader")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.SubResourceReader).Get(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), ptrFromHandle_client_Object(subResource), deptrFromHandle_Slice_client_SubResourceGetOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_WithWatch_Create
func client_WithWatch_Create(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.WithWatch).Create(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_CreateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_WithWatch_Delete
func client_WithWatch_Delete(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.WithWatch).Delete(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_DeleteOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_WithWatch_DeleteAllOf
func client_WithWatch_DeleteAllOf(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.WithWatch).DeleteAllOf(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_DeleteAllOfOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_WithWatch_Get
func client_WithWatch_Get(_handle CGoHandle, ctx CGoHandle, key CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.WithWatch).Get(ptrFromHandle_context_Context(ctx), *ptrFromHandle_types_NamespacedName(key), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_GetOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_WithWatch_GroupVersionKindFor
func client_WithWatch_GroupVersionKindFor(_handle CGoHandle, obj CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return handleFromPtr_schema_GroupVersionKind(nil)
	}
	cret, __err := vifc.(client.WithWatch).GroupVersionKindFor(ptrFromHandle_runtime_Object(obj))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_schema_GroupVersionKind(nil)
	}
	return handleFromPtr_schema_GroupVersionKind(&cret)
}

//export client_WithWatch_IsObjectNamespaced
func client_WithWatch_IsObjectNamespaced(_handle CGoHandle, obj CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return boolGoToPy(false)
	}
	cret, __err := vifc.(client.WithWatch).IsObjectNamespaced(ptrFromHandle_runtime_Object(obj))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return boolGoToPy(false)
	}
	return boolGoToPy(cret)
}

//export client_WithWatch_List
func client_WithWatch_List(_handle CGoHandle, ctx CGoHandle, list CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.WithWatch).List(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_ObjectList(list), deptrFromHandle_Slice_client_ListOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_WithWatch_Patch
func client_WithWatch_Patch(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, patch CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.WithWatch).Patch(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), ptrFromHandle_client_Patch(patch), deptrFromHandle_Slice_client_PatchOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_WithWatch_RESTMapper
func client_WithWatch_RESTMapper(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return handleFromPtr_meta_RESTMapper(nil)
	}
	return handleFromPtr_meta_RESTMapper(vifc.(client.WithWatch).RESTMapper())

}

//export client_WithWatch_Scheme
func client_WithWatch_Scheme(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return handleFromPtr_Ptr_runtime_Scheme(nil)
	}
	return handleFromPtr_Ptr_runtime_Scheme(vifc.(client.WithWatch).Scheme())

}

//export client_WithWatch_Status
func client_WithWatch_Status(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return handleFromPtr_client_SubResourceWriter(nil)
	}
	return handleFromPtr_client_SubResourceWriter(vifc.(client.WithWatch).Status())

}

//export client_WithWatch_SubResource
func client_WithWatch_SubResource(_handle CGoHandle, subResource *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return handleFromPtr_client_SubResourceClient(nil)
	}
	return handleFromPtr_client_SubResourceClient(vifc.(client.WithWatch).SubResource(C.GoString(subResource)))

}

//export client_WithWatch_Update
func client_WithWatch_Update(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.WithWatch).Update(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_UpdateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_WithWatch_Watch
func client_WithWatch_Watch(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.WithWatch")
	if __err != nil {
		return handleFromPtr_watch_Interface(nil)
	}
	cret, __err := vifc.(client.WithWatch).Watch(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_ObjectList(obj), deptrFromHandle_Slice_client_ListOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_watch_Interface(nil)
	}
	return handleFromPtr_watch_Interface(cret)
}

//export client_SubResourceClient_Create
func client_SubResourceClient_Create(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, subResource CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceClient")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.SubResourceClient).Create(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), ptrFromHandle_client_Object(subResource), deptrFromHandle_Slice_client_SubResourceCreateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_SubResourceClient_Get
func client_SubResourceClient_Get(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, subResource CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceClient")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.SubResourceClient).Get(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), ptrFromHandle_client_Object(subResource), deptrFromHandle_Slice_client_SubResourceGetOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_SubResourceClient_Patch
func client_SubResourceClient_Patch(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, patch CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceClient")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.SubResourceClient).Patch(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), ptrFromHandle_client_Patch(patch), deptrFromHandle_Slice_client_SubResourcePatchOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_SubResourceClient_Update
func client_SubResourceClient_Update(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceClient")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.SubResourceClient).Update(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_SubResourceUpdateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_SubResourceUpdateOption_ApplyToSubResourceUpdate
func client_SubResourceUpdateOption_ApplyToSubResourceUpdate(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceUpdateOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.SubResourceUpdateOption).ApplyToSubResourceUpdate(ptrFromHandle_Ptr_client_SubResourceUpdateOptions(arg_0))
	} else {
		vifc.(client.SubResourceUpdateOption).ApplyToSubResourceUpdate(ptrFromHandle_Ptr_client_SubResourceUpdateOptions(arg_0))
	}
}

//export client_SubResourceWriter_Create
func client_SubResourceWriter_Create(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, subResource CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceWriter")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.SubResourceWriter).Create(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), ptrFromHandle_client_Object(subResource), deptrFromHandle_Slice_client_SubResourceCreateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_SubResourceWriter_Patch
func client_SubResourceWriter_Patch(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, patch CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceWriter")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.SubResourceWriter).Patch(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), ptrFromHandle_client_Patch(patch), deptrFromHandle_Slice_client_SubResourcePatchOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_SubResourceWriter_Update
func client_SubResourceWriter_Update(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceWriter")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.SubResourceWriter).Update(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_SubResourceUpdateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Client_Create
func client_Client_Create(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Client).Create(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_CreateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Client_Delete
func client_Client_Delete(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Client).Delete(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_DeleteOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Client_DeleteAllOf
func client_Client_DeleteAllOf(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Client).DeleteAllOf(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_DeleteAllOfOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Client_Get
func client_Client_Get(_handle CGoHandle, ctx CGoHandle, key CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Client).Get(ptrFromHandle_context_Context(ctx), *ptrFromHandle_types_NamespacedName(key), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_GetOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Client_GroupVersionKindFor
func client_Client_GroupVersionKindFor(_handle CGoHandle, obj CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return handleFromPtr_schema_GroupVersionKind(nil)
	}
	cret, __err := vifc.(client.Client).GroupVersionKindFor(ptrFromHandle_runtime_Object(obj))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_schema_GroupVersionKind(nil)
	}
	return handleFromPtr_schema_GroupVersionKind(&cret)
}

//export client_Client_IsObjectNamespaced
func client_Client_IsObjectNamespaced(_handle CGoHandle, obj CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return boolGoToPy(false)
	}
	cret, __err := vifc.(client.Client).IsObjectNamespaced(ptrFromHandle_runtime_Object(obj))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return boolGoToPy(false)
	}
	return boolGoToPy(cret)
}

//export client_Client_List
func client_Client_List(_handle CGoHandle, ctx CGoHandle, list CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Client).List(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_ObjectList(list), deptrFromHandle_Slice_client_ListOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Client_Patch
func client_Client_Patch(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, patch CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Client).Patch(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), ptrFromHandle_client_Patch(patch), deptrFromHandle_Slice_client_PatchOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_Client_RESTMapper
func client_Client_RESTMapper(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return handleFromPtr_meta_RESTMapper(nil)
	}
	return handleFromPtr_meta_RESTMapper(vifc.(client.Client).RESTMapper())

}

//export client_Client_Scheme
func client_Client_Scheme(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return handleFromPtr_Ptr_runtime_Scheme(nil)
	}
	return handleFromPtr_Ptr_runtime_Scheme(vifc.(client.Client).Scheme())

}

//export client_Client_Status
func client_Client_Status(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return handleFromPtr_client_SubResourceWriter(nil)
	}
	return handleFromPtr_client_SubResourceWriter(vifc.(client.Client).Status())

}

//export client_Client_SubResource
func client_Client_SubResource(_handle CGoHandle, subResource *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return handleFromPtr_client_SubResourceClient(nil)
	}
	return handleFromPtr_client_SubResourceClient(vifc.(client.Client).SubResource(C.GoString(subResource)))

}

//export client_Client_Update
func client_Client_Update(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.Client).Update(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_UpdateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_ListOption_ApplyToList
func client_ListOption_ApplyToList(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.ListOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.ListOption).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(arg_0))
	} else {
		vifc.(client.ListOption).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(arg_0))
	}
}

//export client_Patch_Data
func client_Patch_Data(_handle CGoHandle, obj CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Patch")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := vifc.(client.Patch).Data(ptrFromHandle_client_Object(obj))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export client_Patch_Type
func client_Patch_Type(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.Patch")
	if __err != nil {
		return C.CString(string(""))
	}
	return C.CString(string(vifc.(client.Patch).Type()))

}

//export client_SubResourceClientConstructor_SubResource
func client_SubResourceClientConstructor_SubResource(_handle CGoHandle, subResource *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceClientConstructor")
	if __err != nil {
		return handleFromPtr_client_SubResourceClient(nil)
	}
	return handleFromPtr_client_SubResourceClient(vifc.(client.SubResourceClientConstructor).SubResource(C.GoString(subResource)))

}

//export client_SubResourceWriter_Create
func client_SubResourceWriter_Create(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, subResource CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceWriter")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.SubResourceWriter).Create(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), ptrFromHandle_client_Object(subResource), deptrFromHandle_Slice_client_SubResourceCreateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_SubResourceWriter_Patch
func client_SubResourceWriter_Patch(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, patch CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceWriter")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.SubResourceWriter).Patch(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), ptrFromHandle_client_Patch(patch), deptrFromHandle_Slice_client_SubResourcePatchOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_SubResourceWriter_Update
func client_SubResourceWriter_Update(_handle CGoHandle, ctx CGoHandle, obj CGoHandle, opts CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceWriter")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(client.SubResourceWriter).Update(ptrFromHandle_context_Context(ctx), ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_SubResourceUpdateOption(opts)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_SubResourceCreateOption_ApplyToSubResourceCreate
func client_SubResourceCreateOption_ApplyToSubResourceCreate(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.SubResourceCreateOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.SubResourceCreateOption).ApplyToSubResourceCreate(ptrFromHandle_Ptr_client_SubResourceCreateOptions(arg_0))
	} else {
		vifc.(client.SubResourceCreateOption).ApplyToSubResourceCreate(ptrFromHandle_Ptr_client_SubResourceCreateOptions(arg_0))
	}
}

//export client_UpdateOption_ApplyToUpdate
func client_UpdateOption_ApplyToUpdate(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.UpdateOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.UpdateOption).ApplyToUpdate(ptrFromHandle_Ptr_client_UpdateOptions(arg_0))
	} else {
		vifc.(client.UpdateOption).ApplyToUpdate(ptrFromHandle_Ptr_client_UpdateOptions(arg_0))
	}
}

//export client_DeleteAllOfOption_ApplyToDeleteAllOf
func client_DeleteAllOfOption_ApplyToDeleteAllOf(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "client.DeleteAllOfOption")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(client.DeleteAllOfOption).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(arg_0))
	} else {
		vifc.(client.DeleteAllOfOption).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(arg_0))
	}
}

// ---- Structs ---

// --- wrapping struct: client.MergeFromOptions ---
//
//export client_MergeFromOptions_CTor
func client_MergeFromOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_MergeFromOptions(&client.MergeFromOptions{}))
}

//export client_MergeFromOptions_OptimisticLock_Get
func client_MergeFromOptions_OptimisticLock_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_client_MergeFromOptions(handle)
	return boolGoToPy(op.OptimisticLock)
}

//export client_MergeFromOptions_OptimisticLock_Set
func client_MergeFromOptions_OptimisticLock_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_client_MergeFromOptions(handle)
	op.OptimisticLock = boolPyToGo(val)
}

// --- wrapping struct: client.Preconditions ---
//
//export client_Preconditions_CTor
func client_Preconditions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_Preconditions(&client.Preconditions{}))
}

//export client_Preconditions_ApplyToDelete
func client_Preconditions_ApplyToDelete(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.Preconditions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.Preconditions{})).(*client.Preconditions).ApplyToDelete(ptrFromHandle_Ptr_client_DeleteOptions(opts))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.Preconditions{})).(*client.Preconditions).ApplyToDelete(ptrFromHandle_Ptr_client_DeleteOptions(opts))
	}
}

//export client_Preconditions_ApplyToDeleteAllOf
func client_Preconditions_ApplyToDeleteAllOf(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.Preconditions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.Preconditions{})).(*client.Preconditions).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.Preconditions{})).(*client.Preconditions).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	}
}

// --- wrapping struct: client.CreateOptions ---
//
//export client_CreateOptions_CTor
func client_CreateOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_CreateOptions(&client.CreateOptions{}))
}

//export client_CreateOptions_DryRun_Get
func client_CreateOptions_DryRun_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_CreateOptions(handle)
	return handleFromPtr_Slice_string(&op.DryRun)
}

//export client_CreateOptions_DryRun_Set
func client_CreateOptions_DryRun_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_CreateOptions(handle)
	op.DryRun = deptrFromHandle_Slice_string(val)
}

//export client_CreateOptions_FieldManager_Get
func client_CreateOptions_FieldManager_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_CreateOptions(handle)
	return C.CString(op.FieldManager)
}

//export client_CreateOptions_FieldManager_Set
func client_CreateOptions_FieldManager_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_CreateOptions(handle)
	op.FieldManager = C.GoString(val)
}

//export client_CreateOptions_FieldValidation_Get
func client_CreateOptions_FieldValidation_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_CreateOptions(handle)
	return C.CString(op.FieldValidation)
}

//export client_CreateOptions_FieldValidation_Set
func client_CreateOptions_FieldValidation_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_CreateOptions(handle)
	op.FieldValidation = C.GoString(val)
}

//export client_CreateOptions_Raw_Get
func client_CreateOptions_Raw_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_CreateOptions(handle)
	return handleFromPtr_Ptr_v1_CreateOptions(op.Raw)
}

//export client_CreateOptions_Raw_Set
func client_CreateOptions_Raw_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_CreateOptions(handle)
	op.Raw = ptrFromHandle_Ptr_v1_CreateOptions(val)
}

//export client_CreateOptions_AsCreateOptions
func client_CreateOptions_AsCreateOptions(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.CreateOptions")
	if __err != nil {
		return handleFromPtr_Ptr_v1_CreateOptions(nil)
	}
	return handleFromPtr_Ptr_v1_CreateOptions(gopyh.Embed(vifc, reflect.TypeOf(client.CreateOptions{})).(*client.CreateOptions).AsCreateOptions())

}

//export client_CreateOptions_ApplyOptions
func client_CreateOptions_ApplyOptions(_handle CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.CreateOptions")
	if __err != nil {
		return handleFromPtr_Ptr_client_CreateOptions(nil)
	}
	return handleFromPtr_Ptr_client_CreateOptions(gopyh.Embed(vifc, reflect.TypeOf(client.CreateOptions{})).(*client.CreateOptions).ApplyOptions(deptrFromHandle_Slice_client_CreateOption(opts)))

}

//export client_CreateOptions_ApplyToCreate
func client_CreateOptions_ApplyToCreate(_handle CGoHandle, co CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.CreateOptions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.CreateOptions{})).(*client.CreateOptions).ApplyToCreate(ptrFromHandle_Ptr_client_CreateOptions(co))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.CreateOptions{})).(*client.CreateOptions).ApplyToCreate(ptrFromHandle_Ptr_client_CreateOptions(co))
	}
}

// --- wrapping struct: client.CacheOptions ---
//
//export client_CacheOptions_CTor
func client_CacheOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_CacheOptions(&client.CacheOptions{}))
}

//export client_CacheOptions_Reader_Get
func client_CacheOptions_Reader_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_CacheOptions(handle)
	return handleFromPtr_client_Reader(op.Reader)
}

//export client_CacheOptions_Reader_Set
func client_CacheOptions_Reader_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_CacheOptions(handle)
	op.Reader = ptrFromHandle_client_Reader(val)
}

//export client_CacheOptions_DisableFor_Get
func client_CacheOptions_DisableFor_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_CacheOptions(handle)
	return handleFromPtr_Slice_client_Object(&op.DisableFor)
}

//export client_CacheOptions_DisableFor_Set
func client_CacheOptions_DisableFor_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_CacheOptions(handle)
	op.DisableFor = deptrFromHandle_Slice_client_Object(val)
}

//export client_CacheOptions_Unstructured_Get
func client_CacheOptions_Unstructured_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_client_CacheOptions(handle)
	return boolGoToPy(op.Unstructured)
}

//export client_CacheOptions_Unstructured_Set
func client_CacheOptions_Unstructured_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_client_CacheOptions(handle)
	op.Unstructured = boolPyToGo(val)
}

// --- wrapping struct: client.GetOptions ---
//
//export client_GetOptions_CTor
func client_GetOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_GetOptions(&client.GetOptions{}))
}

//export client_GetOptions_Raw_Get
func client_GetOptions_Raw_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_GetOptions(handle)
	return handleFromPtr_Ptr_v1_GetOptions(op.Raw)
}

//export client_GetOptions_Raw_Set
func client_GetOptions_Raw_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_GetOptions(handle)
	op.Raw = ptrFromHandle_Ptr_v1_GetOptions(val)
}

//export client_GetOptions_ApplyToGet
func client_GetOptions_ApplyToGet(_handle CGoHandle, lo CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.GetOptions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.GetOptions{})).(*client.GetOptions).ApplyToGet(ptrFromHandle_Ptr_client_GetOptions(lo))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.GetOptions{})).(*client.GetOptions).ApplyToGet(ptrFromHandle_Ptr_client_GetOptions(lo))
	}
}

//export client_GetOptions_AsGetOptions
func client_GetOptions_AsGetOptions(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.GetOptions")
	if __err != nil {
		return handleFromPtr_Ptr_v1_GetOptions(nil)
	}
	return handleFromPtr_Ptr_v1_GetOptions(gopyh.Embed(vifc, reflect.TypeOf(client.GetOptions{})).(*client.GetOptions).AsGetOptions())

}

//export client_GetOptions_ApplyOptions
func client_GetOptions_ApplyOptions(_handle CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.GetOptions")
	if __err != nil {
		return handleFromPtr_Ptr_client_GetOptions(nil)
	}
	return handleFromPtr_Ptr_client_GetOptions(gopyh.Embed(vifc, reflect.TypeOf(client.GetOptions{})).(*client.GetOptions).ApplyOptions(deptrFromHandle_Slice_client_GetOption(opts)))

}

// --- wrapping struct: client.ListOptions ---
//
//export client_ListOptions_CTor
func client_ListOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_ListOptions(&client.ListOptions{}))
}

//export client_ListOptions_LabelSelector_Get
func client_ListOptions_LabelSelector_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_ListOptions(handle)
	return handleFromPtr_labels_Selector(op.LabelSelector)
}

//export client_ListOptions_LabelSelector_Set
func client_ListOptions_LabelSelector_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_ListOptions(handle)
	op.LabelSelector = ptrFromHandle_labels_Selector(val)
}

//export client_ListOptions_FieldSelector_Get
func client_ListOptions_FieldSelector_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_ListOptions(handle)
	return handleFromPtr_fields_Selector(op.FieldSelector)
}

//export client_ListOptions_FieldSelector_Set
func client_ListOptions_FieldSelector_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_ListOptions(handle)
	op.FieldSelector = ptrFromHandle_fields_Selector(val)
}

//export client_ListOptions_Namespace_Get
func client_ListOptions_Namespace_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_ListOptions(handle)
	return C.CString(op.Namespace)
}

//export client_ListOptions_Namespace_Set
func client_ListOptions_Namespace_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_ListOptions(handle)
	op.Namespace = C.GoString(val)
}

//export client_ListOptions_Limit_Get
func client_ListOptions_Limit_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_client_ListOptions(handle)
	return C.longlong(op.Limit)
}

//export client_ListOptions_Limit_Set
func client_ListOptions_Limit_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_client_ListOptions(handle)
	op.Limit = int64(val)
}

//export client_ListOptions_Continue_Get
func client_ListOptions_Continue_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_ListOptions(handle)
	return C.CString(op.Continue)
}

//export client_ListOptions_Continue_Set
func client_ListOptions_Continue_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_ListOptions(handle)
	op.Continue = C.GoString(val)
}

//export client_ListOptions_Raw_Get
func client_ListOptions_Raw_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_ListOptions(handle)
	return handleFromPtr_Ptr_v1_ListOptions(op.Raw)
}

//export client_ListOptions_Raw_Set
func client_ListOptions_Raw_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_ListOptions(handle)
	op.Raw = ptrFromHandle_Ptr_v1_ListOptions(val)
}

//export client_ListOptions_ApplyToList
func client_ListOptions_ApplyToList(_handle CGoHandle, lo CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.ListOptions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.ListOptions{})).(*client.ListOptions).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(lo))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.ListOptions{})).(*client.ListOptions).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(lo))
	}
}

//export client_ListOptions_AsListOptions
func client_ListOptions_AsListOptions(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.ListOptions")
	if __err != nil {
		return handleFromPtr_Ptr_v1_ListOptions(nil)
	}
	return handleFromPtr_Ptr_v1_ListOptions(gopyh.Embed(vifc, reflect.TypeOf(client.ListOptions{})).(*client.ListOptions).AsListOptions())

}

//export client_ListOptions_ApplyOptions
func client_ListOptions_ApplyOptions(_handle CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.ListOptions")
	if __err != nil {
		return handleFromPtr_Ptr_client_ListOptions(nil)
	}
	return handleFromPtr_Ptr_client_ListOptions(gopyh.Embed(vifc, reflect.TypeOf(client.ListOptions{})).(*client.ListOptions).ApplyOptions(deptrFromHandle_Slice_client_ListOption(opts)))

}

// --- wrapping struct: client.MergeFromWithOptimisticLock ---
//
//export client_MergeFromWithOptimisticLock_CTor
func client_MergeFromWithOptimisticLock_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_MergeFromWithOptimisticLock(&client.MergeFromWithOptimisticLock{}))
}

//export client_MergeFromWithOptimisticLock_ApplyToMergeFrom
func client_MergeFromWithOptimisticLock_ApplyToMergeFrom(_handle CGoHandle, myin CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.MergeFromWithOptimisticLock")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.MergeFromWithOptimisticLock{})).(*client.MergeFromWithOptimisticLock).ApplyToMergeFrom(ptrFromHandle_Ptr_client_MergeFromOptions(myin))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.MergeFromWithOptimisticLock{})).(*client.MergeFromWithOptimisticLock).ApplyToMergeFrom(ptrFromHandle_Ptr_client_MergeFromOptions(myin))
	}
}

// --- wrapping struct: types.NamespacedName ---
//
//export types_NamespacedName_CTor
func types_NamespacedName_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_types_NamespacedName(&types.NamespacedName{}))
}

//export types_NamespacedName_Namespace_Get
func types_NamespacedName_Namespace_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_types_NamespacedName(handle)
	return C.CString(op.Namespace)
}

//export types_NamespacedName_Namespace_Set
func types_NamespacedName_Namespace_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_types_NamespacedName(handle)
	op.Namespace = C.GoString(val)
}

//export types_NamespacedName_Name_Get
func types_NamespacedName_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_types_NamespacedName(handle)
	return C.CString(op.Name)
}

//export types_NamespacedName_Name_Set
func types_NamespacedName_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_types_NamespacedName(handle)
	op.Name = C.GoString(val)
}

//export types_NamespacedName_String
func types_NamespacedName_String(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*types.NamespacedName")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(types.NamespacedName{})).(*types.NamespacedName).String())

}

// --- wrapping struct: client.PatchOptions ---
//
//export client_PatchOptions_CTor
func client_PatchOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_PatchOptions(&client.PatchOptions{}))
}

//export client_PatchOptions_DryRun_Get
func client_PatchOptions_DryRun_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_PatchOptions(handle)
	return handleFromPtr_Slice_string(&op.DryRun)
}

//export client_PatchOptions_DryRun_Set
func client_PatchOptions_DryRun_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_PatchOptions(handle)
	op.DryRun = deptrFromHandle_Slice_string(val)
}

//export client_PatchOptions_FieldManager_Get
func client_PatchOptions_FieldManager_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_PatchOptions(handle)
	return C.CString(op.FieldManager)
}

//export client_PatchOptions_FieldManager_Set
func client_PatchOptions_FieldManager_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_PatchOptions(handle)
	op.FieldManager = C.GoString(val)
}

//export client_PatchOptions_FieldValidation_Get
func client_PatchOptions_FieldValidation_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_PatchOptions(handle)
	return C.CString(op.FieldValidation)
}

//export client_PatchOptions_FieldValidation_Set
func client_PatchOptions_FieldValidation_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_PatchOptions(handle)
	op.FieldValidation = C.GoString(val)
}

//export client_PatchOptions_Raw_Get
func client_PatchOptions_Raw_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_PatchOptions(handle)
	return handleFromPtr_Ptr_v1_PatchOptions(op.Raw)
}

//export client_PatchOptions_Raw_Set
func client_PatchOptions_Raw_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_PatchOptions(handle)
	op.Raw = ptrFromHandle_Ptr_v1_PatchOptions(val)
}

//export client_PatchOptions_ApplyOptions
func client_PatchOptions_ApplyOptions(_handle CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.PatchOptions")
	if __err != nil {
		return handleFromPtr_Ptr_client_PatchOptions(nil)
	}
	return handleFromPtr_Ptr_client_PatchOptions(gopyh.Embed(vifc, reflect.TypeOf(client.PatchOptions{})).(*client.PatchOptions).ApplyOptions(deptrFromHandle_Slice_client_PatchOption(opts)))

}

//export client_PatchOptions_AsPatchOptions
func client_PatchOptions_AsPatchOptions(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.PatchOptions")
	if __err != nil {
		return handleFromPtr_Ptr_v1_PatchOptions(nil)
	}
	return handleFromPtr_Ptr_v1_PatchOptions(gopyh.Embed(vifc, reflect.TypeOf(client.PatchOptions{})).(*client.PatchOptions).AsPatchOptions())

}

//export client_PatchOptions_ApplyToPatch
func client_PatchOptions_ApplyToPatch(_handle CGoHandle, po CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.PatchOptions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.PatchOptions{})).(*client.PatchOptions).ApplyToPatch(ptrFromHandle_Ptr_client_PatchOptions(po))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.PatchOptions{})).(*client.PatchOptions).ApplyToPatch(ptrFromHandle_Ptr_client_PatchOptions(po))
	}
}

// --- wrapping struct: client.DeleteAllOfOptions ---
//
//export client_DeleteAllOfOptions_CTor
func client_DeleteAllOfOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_DeleteAllOfOptions(&client.DeleteAllOfOptions{}))
}

//export client_DeleteAllOfOptions_ApplyOptions
func client_DeleteAllOfOptions_ApplyOptions(_handle CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DeleteAllOfOptions")
	if __err != nil {
		return handleFromPtr_Ptr_client_DeleteAllOfOptions(nil)
	}
	return handleFromPtr_Ptr_client_DeleteAllOfOptions(gopyh.Embed(vifc, reflect.TypeOf(client.DeleteAllOfOptions{})).(*client.DeleteAllOfOptions).ApplyOptions(deptrFromHandle_Slice_client_DeleteAllOfOption(opts)))

}

//export client_DeleteAllOfOptions_ApplyToDeleteAllOf
func client_DeleteAllOfOptions_ApplyToDeleteAllOf(_handle CGoHandle, do CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DeleteAllOfOptions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.DeleteAllOfOptions{})).(*client.DeleteAllOfOptions).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(do))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.DeleteAllOfOptions{})).(*client.DeleteAllOfOptions).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(do))
	}
}

// --- wrapping struct: client.MatchingFieldsSelector ---
//
//export client_MatchingFieldsSelector_CTor
func client_MatchingFieldsSelector_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_MatchingFieldsSelector(&client.MatchingFieldsSelector{}))
}

//export client_MatchingFieldsSelector_ApplyToList
func client_MatchingFieldsSelector_ApplyToList(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.MatchingFieldsSelector")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.MatchingFieldsSelector{})).(*client.MatchingFieldsSelector).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(opts))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.MatchingFieldsSelector{})).(*client.MatchingFieldsSelector).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(opts))
	}
}

//export client_MatchingFieldsSelector_ApplyToDeleteAllOf
func client_MatchingFieldsSelector_ApplyToDeleteAllOf(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.MatchingFieldsSelector")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.MatchingFieldsSelector{})).(*client.MatchingFieldsSelector).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.MatchingFieldsSelector{})).(*client.MatchingFieldsSelector).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	}
}

// --- wrapping struct: client.DeleteOptions ---
//
//export client_DeleteOptions_CTor
func client_DeleteOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_DeleteOptions(&client.DeleteOptions{}))
}

//export client_DeleteOptions_Preconditions_Get
func client_DeleteOptions_Preconditions_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_DeleteOptions(handle)
	return handleFromPtr_Ptr_v1_Preconditions(op.Preconditions)
}

//export client_DeleteOptions_Preconditions_Set
func client_DeleteOptions_Preconditions_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_DeleteOptions(handle)
	op.Preconditions = ptrFromHandle_Ptr_v1_Preconditions(val)
}

//export client_DeleteOptions_Raw_Get
func client_DeleteOptions_Raw_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_DeleteOptions(handle)
	return handleFromPtr_Ptr_v1_DeleteOptions(op.Raw)
}

//export client_DeleteOptions_Raw_Set
func client_DeleteOptions_Raw_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_DeleteOptions(handle)
	op.Raw = ptrFromHandle_Ptr_v1_DeleteOptions(val)
}

//export client_DeleteOptions_DryRun_Get
func client_DeleteOptions_DryRun_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_DeleteOptions(handle)
	return handleFromPtr_Slice_string(&op.DryRun)
}

//export client_DeleteOptions_DryRun_Set
func client_DeleteOptions_DryRun_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_DeleteOptions(handle)
	op.DryRun = deptrFromHandle_Slice_string(val)
}

//export client_DeleteOptions_AsDeleteOptions
func client_DeleteOptions_AsDeleteOptions(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DeleteOptions")
	if __err != nil {
		return handleFromPtr_Ptr_v1_DeleteOptions(nil)
	}
	return handleFromPtr_Ptr_v1_DeleteOptions(gopyh.Embed(vifc, reflect.TypeOf(client.DeleteOptions{})).(*client.DeleteOptions).AsDeleteOptions())

}

//export client_DeleteOptions_ApplyOptions
func client_DeleteOptions_ApplyOptions(_handle CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DeleteOptions")
	if __err != nil {
		return handleFromPtr_Ptr_client_DeleteOptions(nil)
	}
	return handleFromPtr_Ptr_client_DeleteOptions(gopyh.Embed(vifc, reflect.TypeOf(client.DeleteOptions{})).(*client.DeleteOptions).ApplyOptions(deptrFromHandle_Slice_client_DeleteOption(opts)))

}

//export client_DeleteOptions_ApplyToDelete
func client_DeleteOptions_ApplyToDelete(_handle CGoHandle, do CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.DeleteOptions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.DeleteOptions{})).(*client.DeleteOptions).ApplyToDelete(ptrFromHandle_Ptr_client_DeleteOptions(do))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.DeleteOptions{})).(*client.DeleteOptions).ApplyToDelete(ptrFromHandle_Ptr_client_DeleteOptions(do))
	}
}

// --- wrapping struct: client.MatchingLabelsSelector ---
//
//export client_MatchingLabelsSelector_CTor
func client_MatchingLabelsSelector_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_MatchingLabelsSelector(&client.MatchingLabelsSelector{}))
}

//export client_MatchingLabelsSelector_ApplyToList
func client_MatchingLabelsSelector_ApplyToList(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.MatchingLabelsSelector")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.MatchingLabelsSelector{})).(*client.MatchingLabelsSelector).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(opts))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.MatchingLabelsSelector{})).(*client.MatchingLabelsSelector).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(opts))
	}
}

//export client_MatchingLabelsSelector_ApplyToDeleteAllOf
func client_MatchingLabelsSelector_ApplyToDeleteAllOf(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.MatchingLabelsSelector")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.MatchingLabelsSelector{})).(*client.MatchingLabelsSelector).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.MatchingLabelsSelector{})).(*client.MatchingLabelsSelector).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	}
}

// --- wrapping struct: client.Options ---
//
//export client_Options_CTor
func client_Options_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_Options(&client.Options{}))
}

//export client_Options_HTTPClient_Get
func client_Options_HTTPClient_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_Options(handle)
	return handleFromPtr_Ptr_http_Client(op.HTTPClient)
}

//export client_Options_HTTPClient_Set
func client_Options_HTTPClient_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_Options(handle)
	op.HTTPClient = ptrFromHandle_Ptr_http_Client(val)
}

//export client_Options_Scheme_Get
func client_Options_Scheme_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_Options(handle)
	return handleFromPtr_Ptr_runtime_Scheme(op.Scheme)
}

//export client_Options_Scheme_Set
func client_Options_Scheme_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_Options(handle)
	op.Scheme = ptrFromHandle_Ptr_runtime_Scheme(val)
}

//export client_Options_Mapper_Get
func client_Options_Mapper_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_Options(handle)
	return handleFromPtr_meta_RESTMapper(op.Mapper)
}

//export client_Options_Mapper_Set
func client_Options_Mapper_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_Options(handle)
	op.Mapper = ptrFromHandle_meta_RESTMapper(val)
}

//export client_Options_Cache_Get
func client_Options_Cache_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_Options(handle)
	return handleFromPtr_Ptr_client_CacheOptions(op.Cache)
}

//export client_Options_Cache_Set
func client_Options_Cache_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_Options(handle)
	op.Cache = ptrFromHandle_Ptr_client_CacheOptions(val)
}

// --- wrapping struct: client.SubResourceGetOptions ---
//
//export client_SubResourceGetOptions_CTor
func client_SubResourceGetOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_SubResourceGetOptions(&client.SubResourceGetOptions{}))
}

//export client_SubResourceGetOptions_Raw_Get
func client_SubResourceGetOptions_Raw_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_SubResourceGetOptions(handle)
	return handleFromPtr_Ptr_v1_GetOptions(op.Raw)
}

//export client_SubResourceGetOptions_Raw_Set
func client_SubResourceGetOptions_Raw_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_SubResourceGetOptions(handle)
	op.Raw = ptrFromHandle_Ptr_v1_GetOptions(val)
}

//export client_SubResourceGetOptions_ApplyToSubResourceGet
func client_SubResourceGetOptions_ApplyToSubResourceGet(_handle CGoHandle, o CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SubResourceGetOptions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.SubResourceGetOptions{})).(*client.SubResourceGetOptions).ApplyToSubResourceGet(ptrFromHandle_Ptr_client_SubResourceGetOptions(o))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.SubResourceGetOptions{})).(*client.SubResourceGetOptions).ApplyToSubResourceGet(ptrFromHandle_Ptr_client_SubResourceGetOptions(o))
	}
}

//export client_SubResourceGetOptions_ApplyOptions
func client_SubResourceGetOptions_ApplyOptions(_handle CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SubResourceGetOptions")
	if __err != nil {
		return handleFromPtr_Ptr_client_SubResourceGetOptions(nil)
	}
	return handleFromPtr_Ptr_client_SubResourceGetOptions(gopyh.Embed(vifc, reflect.TypeOf(client.SubResourceGetOptions{})).(*client.SubResourceGetOptions).ApplyOptions(deptrFromHandle_Slice_client_SubResourceGetOption(opts)))

}

//export client_SubResourceGetOptions_AsGetOptions
func client_SubResourceGetOptions_AsGetOptions(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SubResourceGetOptions")
	if __err != nil {
		return handleFromPtr_Ptr_v1_GetOptions(nil)
	}
	return handleFromPtr_Ptr_v1_GetOptions(gopyh.Embed(vifc, reflect.TypeOf(client.SubResourceGetOptions{})).(*client.SubResourceGetOptions).AsGetOptions())

}

// --- wrapping struct: client.SubResourcePatchOptions ---
//
//export client_SubResourcePatchOptions_CTor
func client_SubResourcePatchOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_SubResourcePatchOptions(&client.SubResourcePatchOptions{}))
}

//export client_SubResourcePatchOptions_SubResourceBody_Get
func client_SubResourcePatchOptions_SubResourceBody_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_SubResourcePatchOptions(handle)
	return handleFromPtr_client_Object(op.SubResourceBody)
}

//export client_SubResourcePatchOptions_SubResourceBody_Set
func client_SubResourcePatchOptions_SubResourceBody_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_SubResourcePatchOptions(handle)
	op.SubResourceBody = ptrFromHandle_client_Object(val)
}

//export client_SubResourcePatchOptions_ApplyOptions
func client_SubResourcePatchOptions_ApplyOptions(_handle CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SubResourcePatchOptions")
	if __err != nil {
		return handleFromPtr_Ptr_client_SubResourcePatchOptions(nil)
	}
	return handleFromPtr_Ptr_client_SubResourcePatchOptions(gopyh.Embed(vifc, reflect.TypeOf(client.SubResourcePatchOptions{})).(*client.SubResourcePatchOptions).ApplyOptions(deptrFromHandle_Slice_client_SubResourcePatchOption(opts)))

}

//export client_SubResourcePatchOptions_ApplyToSubResourcePatch
func client_SubResourcePatchOptions_ApplyToSubResourcePatch(_handle CGoHandle, o CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SubResourcePatchOptions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.SubResourcePatchOptions{})).(*client.SubResourcePatchOptions).ApplyToSubResourcePatch(ptrFromHandle_Ptr_client_SubResourcePatchOptions(o))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.SubResourcePatchOptions{})).(*client.SubResourcePatchOptions).ApplyToSubResourcePatch(ptrFromHandle_Ptr_client_SubResourcePatchOptions(o))
	}
}

// --- wrapping struct: client.UpdateOptions ---
//
//export client_UpdateOptions_CTor
func client_UpdateOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_UpdateOptions(&client.UpdateOptions{}))
}

//export client_UpdateOptions_DryRun_Get
func client_UpdateOptions_DryRun_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_UpdateOptions(handle)
	return handleFromPtr_Slice_string(&op.DryRun)
}

//export client_UpdateOptions_DryRun_Set
func client_UpdateOptions_DryRun_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_UpdateOptions(handle)
	op.DryRun = deptrFromHandle_Slice_string(val)
}

//export client_UpdateOptions_FieldManager_Get
func client_UpdateOptions_FieldManager_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_UpdateOptions(handle)
	return C.CString(op.FieldManager)
}

//export client_UpdateOptions_FieldManager_Set
func client_UpdateOptions_FieldManager_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_UpdateOptions(handle)
	op.FieldManager = C.GoString(val)
}

//export client_UpdateOptions_FieldValidation_Get
func client_UpdateOptions_FieldValidation_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_client_UpdateOptions(handle)
	return C.CString(op.FieldValidation)
}

//export client_UpdateOptions_FieldValidation_Set
func client_UpdateOptions_FieldValidation_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_client_UpdateOptions(handle)
	op.FieldValidation = C.GoString(val)
}

//export client_UpdateOptions_Raw_Get
func client_UpdateOptions_Raw_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_UpdateOptions(handle)
	return handleFromPtr_Ptr_v1_UpdateOptions(op.Raw)
}

//export client_UpdateOptions_Raw_Set
func client_UpdateOptions_Raw_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_UpdateOptions(handle)
	op.Raw = ptrFromHandle_Ptr_v1_UpdateOptions(val)
}

//export client_UpdateOptions_AsUpdateOptions
func client_UpdateOptions_AsUpdateOptions(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.UpdateOptions")
	if __err != nil {
		return handleFromPtr_Ptr_v1_UpdateOptions(nil)
	}
	return handleFromPtr_Ptr_v1_UpdateOptions(gopyh.Embed(vifc, reflect.TypeOf(client.UpdateOptions{})).(*client.UpdateOptions).AsUpdateOptions())

}

//export client_UpdateOptions_ApplyOptions
func client_UpdateOptions_ApplyOptions(_handle CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.UpdateOptions")
	if __err != nil {
		return handleFromPtr_Ptr_client_UpdateOptions(nil)
	}
	return handleFromPtr_Ptr_client_UpdateOptions(gopyh.Embed(vifc, reflect.TypeOf(client.UpdateOptions{})).(*client.UpdateOptions).ApplyOptions(deptrFromHandle_Slice_client_UpdateOption(opts)))

}

//export client_UpdateOptions_ApplyToUpdate
func client_UpdateOptions_ApplyToUpdate(_handle CGoHandle, uo CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.UpdateOptions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.UpdateOptions{})).(*client.UpdateOptions).ApplyToUpdate(ptrFromHandle_Ptr_client_UpdateOptions(uo))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.UpdateOptions{})).(*client.UpdateOptions).ApplyToUpdate(ptrFromHandle_Ptr_client_UpdateOptions(uo))
	}
}

// --- wrapping struct: client.SubResourceUpdateOptions ---
//
//export client_SubResourceUpdateOptions_CTor
func client_SubResourceUpdateOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_SubResourceUpdateOptions(&client.SubResourceUpdateOptions{}))
}

//export client_SubResourceUpdateOptions_SubResourceBody_Get
func client_SubResourceUpdateOptions_SubResourceBody_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_client_SubResourceUpdateOptions(handle)
	return handleFromPtr_client_Object(op.SubResourceBody)
}

//export client_SubResourceUpdateOptions_SubResourceBody_Set
func client_SubResourceUpdateOptions_SubResourceBody_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_client_SubResourceUpdateOptions(handle)
	op.SubResourceBody = ptrFromHandle_client_Object(val)
}

//export client_SubResourceUpdateOptions_ApplyToSubResourceUpdate
func client_SubResourceUpdateOptions_ApplyToSubResourceUpdate(_handle CGoHandle, o CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SubResourceUpdateOptions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.SubResourceUpdateOptions{})).(*client.SubResourceUpdateOptions).ApplyToSubResourceUpdate(ptrFromHandle_Ptr_client_SubResourceUpdateOptions(o))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.SubResourceUpdateOptions{})).(*client.SubResourceUpdateOptions).ApplyToSubResourceUpdate(ptrFromHandle_Ptr_client_SubResourceUpdateOptions(o))
	}
}

//export client_SubResourceUpdateOptions_ApplyOptions
func client_SubResourceUpdateOptions_ApplyOptions(_handle CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SubResourceUpdateOptions")
	if __err != nil {
		return handleFromPtr_Ptr_client_SubResourceUpdateOptions(nil)
	}
	return handleFromPtr_Ptr_client_SubResourceUpdateOptions(gopyh.Embed(vifc, reflect.TypeOf(client.SubResourceUpdateOptions{})).(*client.SubResourceUpdateOptions).ApplyOptions(deptrFromHandle_Slice_client_SubResourceUpdateOption(opts)))

}

// --- wrapping struct: client.SubResourceCreateOptions ---
//
//export client_SubResourceCreateOptions_CTor
func client_SubResourceCreateOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_SubResourceCreateOptions(&client.SubResourceCreateOptions{}))
}

//export client_SubResourceCreateOptions_ApplyOptions
func client_SubResourceCreateOptions_ApplyOptions(_handle CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SubResourceCreateOptions")
	if __err != nil {
		return handleFromPtr_Ptr_client_SubResourceCreateOptions(nil)
	}
	return handleFromPtr_Ptr_client_SubResourceCreateOptions(gopyh.Embed(vifc, reflect.TypeOf(client.SubResourceCreateOptions{})).(*client.SubResourceCreateOptions).ApplyOptions(deptrFromHandle_Slice_client_SubResourceCreateOption(opts)))

}

//export client_SubResourceCreateOptions_ApplyToSubResourceCreate
func client_SubResourceCreateOptions_ApplyToSubResourceCreate(_handle CGoHandle, o CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.SubResourceCreateOptions")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(client.SubResourceCreateOptions{})).(*client.SubResourceCreateOptions).ApplyToSubResourceCreate(ptrFromHandle_Ptr_client_SubResourceCreateOptions(o))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(client.SubResourceCreateOptions{})).(*client.SubResourceCreateOptions).ApplyToSubResourceCreate(ptrFromHandle_Ptr_client_SubResourceCreateOptions(o))
	}
}

// ---- Slices ---

// --- wrapping slice: client.HasLabels ---
//
//export client_HasLabels_CTor
func client_HasLabels_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_HasLabels(&client.HasLabels{}))
}

//export client_HasLabels_len
func client_HasLabels_len(handle CGoHandle) int {
	return len(deptrFromHandle_client_HasLabels(handle))
}

//export client_HasLabels_elem
func client_HasLabels_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_client_HasLabels(handle)
	return C.CString(s[_idx])
}

//export client_HasLabels_subslice
func client_HasLabels_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_client_HasLabels(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_client_HasLabels(&ss))
}

//export client_HasLabels_set
func client_HasLabels_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_client_HasLabels(handle)
	s[_idx] = C.GoString(_vl)
}

//export client_HasLabels_append
func client_HasLabels_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_client_HasLabels(handle)
	*s = append(*s, C.GoString(_vl))
}

//export client_HasLabels_ApplyToList
func client_HasLabels_ApplyToList(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.HasLabels")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*client.HasLabels).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(opts))
	} else {
		vifc.(*client.HasLabels).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(opts))
	}
}

//export client_HasLabels_ApplyToDeleteAllOf
func client_HasLabels_ApplyToDeleteAllOf(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.HasLabels")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*client.HasLabels).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	} else {
		vifc.(*client.HasLabels).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	}
}

// ---- Maps ---

// --- wrapping map: client.MatchingFields ---
//
//export client_MatchingFields_CTor
func client_MatchingFields_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_MatchingFields(&client.MatchingFields{}))
}

//export client_MatchingFields_len
func client_MatchingFields_len(handle CGoHandle) int {
	return len(deptrFromHandle_client_MatchingFields(handle))
}

//export client_MatchingFields_elem
func client_MatchingFields_elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_client_MatchingFields(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(v)
}

//export client_MatchingFields_contains
func client_MatchingFields_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_client_MatchingFields(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export client_MatchingFields_set
func client_MatchingFields_set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_client_MatchingFields(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export client_MatchingFields_delete
func client_MatchingFields_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_client_MatchingFields(handle)
	delete(s, C.GoString(_ky))
}

//export client_MatchingFields_keys
func client_MatchingFields_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_client_MatchingFields(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

//export client_MatchingFields_ApplyToList
func client_MatchingFields_ApplyToList(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.MatchingFields")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*client.MatchingFields).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(opts))
	} else {
		vifc.(*client.MatchingFields).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(opts))
	}
}

//export client_MatchingFields_ApplyToDeleteAllOf
func client_MatchingFields_ApplyToDeleteAllOf(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.MatchingFields")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*client.MatchingFields).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	} else {
		vifc.(*client.MatchingFields).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	}
}

// --- wrapping map: client.MatchingLabels ---
//
//export client_MatchingLabels_CTor
func client_MatchingLabels_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_client_MatchingLabels(&client.MatchingLabels{}))
}

//export client_MatchingLabels_len
func client_MatchingLabels_len(handle CGoHandle) int {
	return len(deptrFromHandle_client_MatchingLabels(handle))
}

//export client_MatchingLabels_elem
func client_MatchingLabels_elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_client_MatchingLabels(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(v)
}

//export client_MatchingLabels_contains
func client_MatchingLabels_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_client_MatchingLabels(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export client_MatchingLabels_set
func client_MatchingLabels_set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_client_MatchingLabels(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export client_MatchingLabels_delete
func client_MatchingLabels_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_client_MatchingLabels(handle)
	delete(s, C.GoString(_ky))
}

//export client_MatchingLabels_keys
func client_MatchingLabels_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_client_MatchingLabels(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

//export client_MatchingLabels_ApplyToList
func client_MatchingLabels_ApplyToList(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.MatchingLabels")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*client.MatchingLabels).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(opts))
	} else {
		vifc.(*client.MatchingLabels).ApplyToList(ptrFromHandle_Ptr_client_ListOptions(opts))
	}
}

//export client_MatchingLabels_ApplyToDeleteAllOf
func client_MatchingLabels_ApplyToDeleteAllOf(_handle CGoHandle, opts CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*client.MatchingLabels")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(*client.MatchingLabels).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	} else {
		vifc.(*client.MatchingLabels).ApplyToDeleteAllOf(ptrFromHandle_Ptr_client_DeleteAllOfOptions(opts))
	}
}

// ---- Constructors ---

//export client_ObjectKeyFromObject
func client_ObjectKeyFromObject(obj CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := client.ObjectKeyFromObject(ptrFromHandle_client_Object(obj))

	return handleFromPtr_types_NamespacedName(&cret)
}

// ---- Functions ---

//export client_NewNamespacedClient
func client_NewNamespacedClient(c CGoHandle, ns *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_client_Client(client.NewNamespacedClient(ptrFromHandle_client_Client(c), C.GoString(ns)))

}

//export client_NewWithWatch
func client_NewWithWatch(config CGoHandle, options CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := client.NewWithWatch(ptrFromHandle_Ptr_rest_Config(config), *ptrFromHandle_client_Options(options))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_client_WithWatch(nil)
	}
	return handleFromPtr_client_WithWatch(cret)
}

//export client_IgnoreAlreadyExists
func client_IgnoreAlreadyExists(err *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = client.IgnoreAlreadyExists(errors.New(C.GoString(err)))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_MergeFrom
func client_MergeFrom(obj CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_client_Patch(client.MergeFrom(ptrFromHandle_client_Object(obj)))

}

//export client_RawPatch
func client_RawPatch(patchType *C.char, data CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_client_Patch(client.RawPatch(types.PatchType(C.GoString(patchType)), deptrFromHandle_Slice_byte(data)))

}

//export client_StrategicMergeFrom
func client_StrategicMergeFrom(obj CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_client_Patch(client.StrategicMergeFrom(ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_MergeFromOption(opts)...))

}

//export client_WithFieldValidation
func client_WithFieldValidation(c CGoHandle, validation *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_client_Client(client.WithFieldValidation(ptrFromHandle_client_Client(c), client.FieldValidation(C.GoString(validation))))

}

//export client_WithSubResourceBody
func client_WithSubResourceBody(body CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_client_SubResourceUpdateAndPatchOption(client.WithSubResourceBody(ptrFromHandle_client_Object(body)))

}

//export client_IgnoreNotFound
func client_IgnoreNotFound(err *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = client.IgnoreNotFound(errors.New(C.GoString(err)))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export client_MergeFromWithOptions
func client_MergeFromWithOptions(obj CGoHandle, opts CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_client_Patch(client.MergeFromWithOptions(ptrFromHandle_client_Object(obj), deptrFromHandle_Slice_client_MergeFromOption(opts)...))

}

//export client_New
func client_New(config CGoHandle, options CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := client.New(ptrFromHandle_Ptr_rest_Config(config), *ptrFromHandle_client_Options(options))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_client_Client(nil)
	}
	return handleFromPtr_client_Client(cret)
}

//export client_NewDryRunClient
func client_NewDryRunClient(c CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_client_Client(client.NewDryRunClient(ptrFromHandle_client_Client(c)))

}

//export client_WithFieldOwner
func client_WithFieldOwner(c CGoHandle, fieldOwner *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_client_Client(client.WithFieldOwner(ptrFromHandle_client_Client(c), C.GoString(fieldOwner)))

}

// ---- Package: apiutil ---

// ---- Types ---

// Converters for pointer handles for type: *apiutil.ErrResourceDiscoveryFailed
func ptrFromHandle_Ptr_apiutil_ErrResourceDiscoveryFailed(h CGoHandle) *apiutil.ErrResourceDiscoveryFailed {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*apiutil.ErrResourceDiscoveryFailed")
	if p == nil {
		return nil
	}
	return p.(*apiutil.ErrResourceDiscoveryFailed)
}
func handleFromPtr_Ptr_apiutil_ErrResourceDiscoveryFailed(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*apiutil.ErrResourceDiscoveryFailed", p))
}

// Converters for implicit pointer handles for type: []runtime.SerializerInfo
func ptrFromHandle_Slice_runtime_SerializerInfo(h CGoHandle) *[]runtime.SerializerInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]runtime.SerializerInfo")
	if p == nil {
		return nil
	}
	return p.(*[]runtime.SerializerInfo)
}
func deptrFromHandle_Slice_runtime_SerializerInfo(h CGoHandle) []runtime.SerializerInfo {
	p := ptrFromHandle_Slice_runtime_SerializerInfo(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_runtime_SerializerInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]runtime.SerializerInfo", p))
}

// --- wrapping slice: []runtime.SerializerInfo ---
//
//export Slice_runtime_SerializerInfo_CTor
func Slice_runtime_SerializerInfo_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_runtime_SerializerInfo(&[]runtime.SerializerInfo{}))
}

//export Slice_runtime_SerializerInfo_len
func Slice_runtime_SerializerInfo_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_runtime_SerializerInfo(handle))
}

//export Slice_runtime_SerializerInfo_elem
func Slice_runtime_SerializerInfo_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_runtime_SerializerInfo(handle)
	return handleFromPtr_runtime_SerializerInfo(&(s[_idx]))
}

//export Slice_runtime_SerializerInfo_subslice
func Slice_runtime_SerializerInfo_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_runtime_SerializerInfo(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_runtime_SerializerInfo(&ss))
}

//export Slice_runtime_SerializerInfo_set
func Slice_runtime_SerializerInfo_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_runtime_SerializerInfo(handle)
	s[_idx] = *ptrFromHandle_runtime_SerializerInfo(_vl)
}

//export Slice_runtime_SerializerInfo_append
func Slice_runtime_SerializerInfo_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_runtime_SerializerInfo(handle)
	*s = append(*s, *ptrFromHandle_runtime_SerializerInfo(_vl))
}

// Converters for implicit pointer handles for type: apiutil.ErrResourceDiscoveryFailed
func ptrFromHandle_apiutil_ErrResourceDiscoveryFailed(h CGoHandle) *apiutil.ErrResourceDiscoveryFailed {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "apiutil.ErrResourceDiscoveryFailed")
	if p == nil {
		return nil
	}
	return p.(*apiutil.ErrResourceDiscoveryFailed)
}
func deptrFromHandle_apiutil_ErrResourceDiscoveryFailed(h CGoHandle) apiutil.ErrResourceDiscoveryFailed {
	p := ptrFromHandle_apiutil_ErrResourceDiscoveryFailed(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_apiutil_ErrResourceDiscoveryFailed(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("apiutil.ErrResourceDiscoveryFailed", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// --- wrapping map: apiutil.ErrResourceDiscoveryFailed ---
//
//export apiutil_ErrResourceDiscoveryFailed_CTor
func apiutil_ErrResourceDiscoveryFailed_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_apiutil_ErrResourceDiscoveryFailed(&apiutil.ErrResourceDiscoveryFailed{}))
}

//export apiutil_ErrResourceDiscoveryFailed_len
func apiutil_ErrResourceDiscoveryFailed_len(handle CGoHandle) int {
	return len(deptrFromHandle_apiutil_ErrResourceDiscoveryFailed(handle))
}

//export apiutil_ErrResourceDiscoveryFailed_elem
func apiutil_ErrResourceDiscoveryFailed_elem(handle CGoHandle, _ky CGoHandle) *C.char {
	s := deptrFromHandle_apiutil_ErrResourceDiscoveryFailed(handle)
	v, ok := s[*ptrFromHandle_schema_GroupVersion(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return errorGoToPy(v)
}

//export apiutil_ErrResourceDiscoveryFailed_contains
func apiutil_ErrResourceDiscoveryFailed_contains(handle CGoHandle, _ky CGoHandle) C.char {
	s := deptrFromHandle_apiutil_ErrResourceDiscoveryFailed(handle)
	_, ok := s[*ptrFromHandle_schema_GroupVersion(_ky)]
	return boolGoToPy(ok)
}

//export apiutil_ErrResourceDiscoveryFailed_set
func apiutil_ErrResourceDiscoveryFailed_set(handle CGoHandle, _ky CGoHandle, _vl *C.char) {
	s := deptrFromHandle_apiutil_ErrResourceDiscoveryFailed(handle)
	s[*ptrFromHandle_schema_GroupVersion(_ky)] = errors.New(C.GoString(_vl))
}

//export apiutil_ErrResourceDiscoveryFailed_delete
func apiutil_ErrResourceDiscoveryFailed_delete(handle CGoHandle, _ky CGoHandle) {
	s := deptrFromHandle_apiutil_ErrResourceDiscoveryFailed(handle)
	delete(s, *ptrFromHandle_schema_GroupVersion(_ky))
}

//export apiutil_ErrResourceDiscoveryFailed_keys
func apiutil_ErrResourceDiscoveryFailed_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_apiutil_ErrResourceDiscoveryFailed(handle)
	kys := make([]schema.GroupVersion, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_schema_GroupVersion(&kys)
}

//export apiutil_ErrResourceDiscoveryFailed_Error
func apiutil_ErrResourceDiscoveryFailed_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*apiutil.ErrResourceDiscoveryFailed")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(vifc.(*apiutil.ErrResourceDiscoveryFailed).Error())

}

//export apiutil_ErrResourceDiscoveryFailed_Unwrap
func apiutil_ErrResourceDiscoveryFailed_Unwrap(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*apiutil.ErrResourceDiscoveryFailed")
	if __err != nil {
		return handleFromPtr_Slice_error(nil)
	}
	cret := vifc.(*apiutil.ErrResourceDiscoveryFailed).Unwrap()

	return handleFromPtr_Slice_error(&cret)
}

// ---- Constructors ---

// ---- Functions ---

//export apiutil_IsGVKNamespaced
func apiutil_IsGVKNamespaced(gvk CGoHandle, restmapper CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := apiutil.IsGVKNamespaced(*ptrFromHandle_schema_GroupVersionKind(gvk), ptrFromHandle_meta_RESTMapper(restmapper))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return boolGoToPy(false)
	}
	return boolGoToPy(cret)
}

//export apiutil_IsObjectNamespaced
func apiutil_IsObjectNamespaced(obj CGoHandle, scheme CGoHandle, restmapper CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := apiutil.IsObjectNamespaced(ptrFromHandle_runtime_Object(obj), ptrFromHandle_Ptr_runtime_Scheme(scheme), ptrFromHandle_meta_RESTMapper(restmapper))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return boolGoToPy(false)
	}
	return boolGoToPy(cret)
}

//export apiutil_NewDynamicRESTMapper
func apiutil_NewDynamicRESTMapper(cfg CGoHandle, httpClient CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := apiutil.NewDynamicRESTMapper(ptrFromHandle_Ptr_rest_Config(cfg), ptrFromHandle_Ptr_http_Client(httpClient))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_meta_RESTMapper(nil)
	}
	return handleFromPtr_meta_RESTMapper(cret)
}

//export apiutil_RESTClientForGVK
func apiutil_RESTClientForGVK(gvk CGoHandle, isUnstructured C.char, baseConfig CGoHandle, codecs CGoHandle, httpClient CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := apiutil.RESTClientForGVK(*ptrFromHandle_schema_GroupVersionKind(gvk), boolPyToGo(isUnstructured), ptrFromHandle_Ptr_rest_Config(baseConfig), *ptrFromHandle_serializer_CodecFactory(codecs), ptrFromHandle_Ptr_http_Client(httpClient))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_rest_Interface(nil)
	}
	return handleFromPtr_rest_Interface(cret)
}

//export apiutil_GVKForObject
func apiutil_GVKForObject(obj CGoHandle, scheme CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := apiutil.GVKForObject(ptrFromHandle_runtime_Object(obj), ptrFromHandle_Ptr_runtime_Scheme(scheme))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_schema_GroupVersionKind(nil)
	}
	return handleFromPtr_schema_GroupVersionKind(&cret)
}

// ---- Package: config ---

// ---- Types ---

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export config_GetConfig
func config_GetConfig() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := config.GetConfig()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_rest_Config(nil)
	}
	return handleFromPtr_Ptr_rest_Config(cret)
}

//export config_GetConfigOrDie
func config_GetConfigOrDie() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_rest_Config(config.GetConfigOrDie())

}

//export config_GetConfigWithContext
func config_GetConfigWithContext(context *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := config.GetConfigWithContext(C.GoString(context))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_rest_Config(nil)
	}
	return handleFromPtr_Ptr_rest_Config(cret)
}

//export config_RegisterFlags
func config_RegisterFlags(fs CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go config.RegisterFlags(ptrFromHandle_Ptr_flag_FlagSet(fs))
	} else {
		config.RegisterFlags(ptrFromHandle_Ptr_flag_FlagSet(fs))
	}
}

// ---- Package: fake ---

// ---- Types ---

// Converters for pointer handles for type: *fake.ClientBuilder
func ptrFromHandle_Ptr_fake_ClientBuilder(h CGoHandle) *fake.ClientBuilder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*fake.ClientBuilder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fake.ClientBuilder{})).(*fake.ClientBuilder)
}
func handleFromPtr_Ptr_fake_ClientBuilder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*fake.ClientBuilder", p))
}

// Converters for implicit pointer handles for type: []client.ObjectList
func ptrFromHandle_Slice_client_ObjectList(h CGoHandle) *[]client.ObjectList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]client.ObjectList")
	if p == nil {
		return nil
	}
	return p.(*[]client.ObjectList)
}
func deptrFromHandle_Slice_client_ObjectList(h CGoHandle) []client.ObjectList {
	p := ptrFromHandle_Slice_client_ObjectList(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_client_ObjectList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]client.ObjectList", p))
}

// --- wrapping slice: []client.ObjectList ---
//
//export Slice_client_ObjectList_CTor
func Slice_client_ObjectList_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_client_ObjectList(&[]client.ObjectList{}))
}

//export Slice_client_ObjectList_len
func Slice_client_ObjectList_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_client_ObjectList(handle))
}

//export Slice_client_ObjectList_elem
func Slice_client_ObjectList_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_client_ObjectList(handle)
	return handleFromPtr_client_ObjectList(&(s[_idx]))
}

//export Slice_client_ObjectList_subslice
func Slice_client_ObjectList_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_client_ObjectList(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_client_ObjectList(&ss))
}

//export Slice_client_ObjectList_set
func Slice_client_ObjectList_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_client_ObjectList(handle)
	s[_idx] = ptrFromHandle_client_ObjectList(_vl)
}

//export Slice_client_ObjectList_append
func Slice_client_ObjectList_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_client_ObjectList(handle)
	*s = append(*s, ptrFromHandle_client_ObjectList(_vl))
}

// Converters for non-pointer handles for type: fake.ClientBuilder
func ptrFromHandle_fake_ClientBuilder(h CGoHandle) *fake.ClientBuilder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fake.ClientBuilder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fake.ClientBuilder{})).(*fake.ClientBuilder)
}
func handleFromPtr_fake_ClientBuilder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fake.ClientBuilder", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: fake.ClientBuilder ---
//
//export fake_ClientBuilder_CTor
func fake_ClientBuilder_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_fake_ClientBuilder(&fake.ClientBuilder{}))
}

//export fake_ClientBuilder_WithScheme
func fake_ClientBuilder_WithScheme(_handle CGoHandle, scheme CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.ClientBuilder")
	if __err != nil {
		return handleFromPtr_Ptr_fake_ClientBuilder(nil)
	}
	return handleFromPtr_Ptr_fake_ClientBuilder(gopyh.Embed(vifc, reflect.TypeOf(fake.ClientBuilder{})).(*fake.ClientBuilder).WithScheme(ptrFromHandle_Ptr_runtime_Scheme(scheme)))

}

//export fake_ClientBuilder_WithRESTMapper
func fake_ClientBuilder_WithRESTMapper(_handle CGoHandle, restMapper CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.ClientBuilder")
	if __err != nil {
		return handleFromPtr_Ptr_fake_ClientBuilder(nil)
	}
	return handleFromPtr_Ptr_fake_ClientBuilder(gopyh.Embed(vifc, reflect.TypeOf(fake.ClientBuilder{})).(*fake.ClientBuilder).WithRESTMapper(ptrFromHandle_meta_RESTMapper(restMapper)))

}

//export fake_ClientBuilder_WithObjects
func fake_ClientBuilder_WithObjects(_handle CGoHandle, initObjs CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.ClientBuilder")
	if __err != nil {
		return handleFromPtr_Ptr_fake_ClientBuilder(nil)
	}
	return handleFromPtr_Ptr_fake_ClientBuilder(gopyh.Embed(vifc, reflect.TypeOf(fake.ClientBuilder{})).(*fake.ClientBuilder).WithObjects(deptrFromHandle_Slice_client_Object(initObjs)...))

}

//export fake_ClientBuilder_WithLists
func fake_ClientBuilder_WithLists(_handle CGoHandle, initLists CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.ClientBuilder")
	if __err != nil {
		return handleFromPtr_Ptr_fake_ClientBuilder(nil)
	}
	return handleFromPtr_Ptr_fake_ClientBuilder(gopyh.Embed(vifc, reflect.TypeOf(fake.ClientBuilder{})).(*fake.ClientBuilder).WithLists(deptrFromHandle_Slice_client_ObjectList(initLists)...))

}

//export fake_ClientBuilder_WithRuntimeObjects
func fake_ClientBuilder_WithRuntimeObjects(_handle CGoHandle, initRuntimeObjs CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.ClientBuilder")
	if __err != nil {
		return handleFromPtr_Ptr_fake_ClientBuilder(nil)
	}
	return handleFromPtr_Ptr_fake_ClientBuilder(gopyh.Embed(vifc, reflect.TypeOf(fake.ClientBuilder{})).(*fake.ClientBuilder).WithRuntimeObjects(deptrFromHandle_Slice_runtime_Object(initRuntimeObjs)...))

}

//export fake_ClientBuilder_WithObjectTracker
func fake_ClientBuilder_WithObjectTracker(_handle CGoHandle, ot CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.ClientBuilder")
	if __err != nil {
		return handleFromPtr_Ptr_fake_ClientBuilder(nil)
	}
	return handleFromPtr_Ptr_fake_ClientBuilder(gopyh.Embed(vifc, reflect.TypeOf(fake.ClientBuilder{})).(*fake.ClientBuilder).WithObjectTracker(ptrFromHandle_testing_ObjectTracker(ot)))

}

//export fake_ClientBuilder_WithStatusSubresource
func fake_ClientBuilder_WithStatusSubresource(_handle CGoHandle, o CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.ClientBuilder")
	if __err != nil {
		return handleFromPtr_Ptr_fake_ClientBuilder(nil)
	}
	return handleFromPtr_Ptr_fake_ClientBuilder(gopyh.Embed(vifc, reflect.TypeOf(fake.ClientBuilder{})).(*fake.ClientBuilder).WithStatusSubresource(deptrFromHandle_Slice_client_Object(o)...))

}

//export fake_ClientBuilder_WithInterceptorFuncs
func fake_ClientBuilder_WithInterceptorFuncs(_handle CGoHandle, interceptorFuncs CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.ClientBuilder")
	if __err != nil {
		return handleFromPtr_Ptr_fake_ClientBuilder(nil)
	}
	return handleFromPtr_Ptr_fake_ClientBuilder(gopyh.Embed(vifc, reflect.TypeOf(fake.ClientBuilder{})).(*fake.ClientBuilder).WithInterceptorFuncs(*ptrFromHandle_interceptor_Funcs(interceptorFuncs)))

}

//export fake_ClientBuilder_Build
func fake_ClientBuilder_Build(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.ClientBuilder")
	if __err != nil {
		return handleFromPtr_client_WithWatch(nil)
	}
	return handleFromPtr_client_WithWatch(gopyh.Embed(vifc, reflect.TypeOf(fake.ClientBuilder{})).(*fake.ClientBuilder).Build())

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export fake_NewClientBuilder
func fake_NewClientBuilder() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_fake_ClientBuilder(fake.NewClientBuilder())

}

// ---- Functions ---

//export fake_NewFakeClient
func fake_NewFakeClient(initObjs CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_client_WithWatch(fake.NewFakeClient(deptrFromHandle_Slice_runtime_Object(initObjs)...))

}

// ---- Package: interceptor ---

// ---- Types ---

// Converters for pointer handles for type: *interceptor.Funcs
func ptrFromHandle_Ptr_interceptor_Funcs(h CGoHandle) *interceptor.Funcs {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*interceptor.Funcs")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(interceptor.Funcs{})).(*interceptor.Funcs)
}
func handleFromPtr_Ptr_interceptor_Funcs(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*interceptor.Funcs", p))
}

// Converters for non-pointer handles for type: interceptor.Funcs
func ptrFromHandle_interceptor_Funcs(h CGoHandle) *interceptor.Funcs {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "interceptor.Funcs")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(interceptor.Funcs{})).(*interceptor.Funcs)
}
func handleFromPtr_interceptor_Funcs(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("interceptor.Funcs", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: interceptor.Funcs ---
//
//export interceptor_Funcs_CTor
func interceptor_Funcs_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_interceptor_Funcs(&interceptor.Funcs{}))
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export interceptor_NewClient
func interceptor_NewClient(interceptedClient CGoHandle, funcs CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_client_WithWatch(interceptor.NewClient(ptrFromHandle_client_WithWatch(interceptedClient), *ptrFromHandle_interceptor_Funcs(funcs)))

}
