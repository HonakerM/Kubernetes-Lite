"""
Package apiutil contains utilities for working with raw Kubernetes
API machinery, such as creating RESTMappers and raw REST clients,
and extracting the GVK of an object.

"""
# python wrapper for package sigs.k8s.io/controller-runtime/pkg/client/apiutil within overall package client
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg sigs.k8s.io/controller-runtime/pkg/client

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _client
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from client import apiutil
# and then refer to everything using apiutil. prefix
# packages imported by this package listed below:

from . import client



# ---- Types ---

# Python type for slice []runtime.SerializerInfo
class Slice_runtime_SerializerInfo(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.Slice_runtime_SerializerInfo_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_runtime_SerializerInfo.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'apiutil.Slice_runtime_SerializerInfo len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'apiutil.Slice_runtime_SerializerInfo([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _client.Slice_runtime_SerializerInfo_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _client.Slice_runtime_SerializerInfo_len(self.handle)
				return Slice_runtime_SerializerInfo(handle=_client.Slice_runtime_SerializerInfo_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.runtime_SerializerInfo(handle=_client.Slice_runtime_SerializerInfo_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_client.Slice_runtime_SerializerInfo_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_runtime_SerializerInfo.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.runtime_SerializerInfo(handle=_client.Slice_runtime_SerializerInfo_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_client.Slice_runtime_SerializerInfo_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---


# ---- Slices ---


# ---- Maps ---

# Python type for map apiutil.ErrResourceDiscoveryFailed
class ErrResourceDiscoveryFailed(go.GoClass):
	"""ErrResourceDiscoveryFailed is returned if the RESTMapper cannot discover supported resources for some GroupVersions.\nIt wraps the errors encountered, except \"NotFound\" errors are replaced with meta.NoResourceMatchError, for\nbackwards compatibility with code that uses meta.IsNoMatchError() to check for unsupported APIs.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_client.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_client.IncRef(self.handle)
		else:
			self.handle = _client.apiutil_ErrResourceDiscoveryFailed_CTor()
			_client.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('apiutil_ErrResourceDiscoveryFailed.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_client.apiutil_ErrResourceDiscoveryFailed_set(self.handle, k, v)
	def __del__(self):
		_client.DecRef(self.handle)
	def __str__(self):
		s = 'client.apiutil_ErrResourceDiscoveryFailed len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'client.apiutil_ErrResourceDiscoveryFailed({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _client.apiutil_ErrResourceDiscoveryFailed_len(self.handle)
	def __getitem__(self, key):
		return _client.apiutil_ErrResourceDiscoveryFailed_elem(self.handle, key.handle)
	def __setitem__(self, key, value):
		_client.apiutil_ErrResourceDiscoveryFailed_set(self.handle, key.handle, value)
	def __delitem__(self, key):
		return _client.apiutil_ErrResourceDiscoveryFailed_delete(self.handle, key.handle)
	def keys(self):
		return client.Slice_schema_GroupVersion(handle=_client.apiutil_ErrResourceDiscoveryFailed_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _client.apiutil_ErrResourceDiscoveryFailed_contains(self.handle, key.handle)
	def Error(self):
		"""Error() str
		
		Error implements the error interface.
		"""
		return _client.apiutil_ErrResourceDiscoveryFailed_Error(self.handle)
	def Unwrap(self):
		"""Unwrap() []str"""
		return go.Slice_error(handle=_client.apiutil_ErrResourceDiscoveryFailed_Unwrap(self.handle))


# ---- Constructors ---


# ---- Functions ---
def IsGVKNamespaced(gvk, restmapper):
	"""IsGVKNamespaced(object gvk, object restmapper) bool, str
	
	IsGVKNamespaced returns true if the object having the provided
	GVK is namespace scoped.
	"""
	return _client.apiutil_IsGVKNamespaced(gvk.handle, restmapper.handle)
def IsObjectNamespaced(obj, scheme, restmapper):
	"""IsObjectNamespaced(object obj, object scheme, object restmapper) bool, str
	
	IsObjectNamespaced returns true if the object is namespace scoped.
	For unstructured objects the gvk is found from the object itself.
	"""
	return _client.apiutil_IsObjectNamespaced(obj.handle, scheme.handle, restmapper.handle)
def NewDynamicRESTMapper(cfg, httpClient):
	"""NewDynamicRESTMapper(object cfg, object httpClient) object, str
	
	NewDynamicRESTMapper returns a dynamic RESTMapper for cfg. The dynamic
	RESTMapper dynamically discovers resource types at runtime.
	"""
	return go.meta_RESTMapper(handle=_client.apiutil_NewDynamicRESTMapper(cfg.handle, httpClient.handle))
def RESTClientForGVK(gvk, isUnstructured, baseConfig, codecs, httpClient):
	"""RESTClientForGVK(object gvk, bool isUnstructured, object baseConfig, object codecs, object httpClient) object, str
	
	RESTClientForGVK constructs a new rest.Interface capable of accessing the resource associated
	with the given GroupVersionKind. The REST client will be configured to use the negotiated serializer from
	baseConfig, if set, otherwise a default serializer will be set.
	"""
	return go.rest_Interface(handle=_client.apiutil_RESTClientForGVK(gvk.handle, isUnstructured, baseConfig.handle, codecs.handle, httpClient.handle))
def GVKForObject(obj, scheme):
	"""GVKForObject(object obj, object scheme) object, str
	
	GVKForObject finds the GroupVersionKind associated with the given object, if there is only a single such GVK.
	"""
	return go.schema_GroupVersionKind(handle=_client.apiutil_GVKForObject(obj.handle, scheme.handle))


