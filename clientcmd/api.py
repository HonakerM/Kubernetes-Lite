
# python wrapper for package k8s.io/client-go/tools/clientcmd/api within overall package clientcmd
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg k8s.io/client-go/tools/clientcmd

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _clientcmd
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from clientcmd import api
# and then refer to everything using api. prefix
# packages imported by this package listed below:

from . import clientcmd



# ---- Types ---


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---
AlwaysExecInteractiveMode = "Always"
IfAvailableExecInteractiveMode = "IfAvailable"
NeverExecInteractiveMode = "Never"


# ---- Global Variables: can only use functions to access ---
def SchemeGroupVersion():
	"""
	SchemeGroupVersion Gets Go Variable: api.SchemeGroupVersion
	SchemeGroupVersion is group version used to register these objects
	TODO this should be in the "kubeconfig" group
	
	"""
	return go.schema_GroupVersion(handle=_clientcmd.api_SchemeGroupVersion())

def Set_SchemeGroupVersion(value):
	"""
	Set_SchemeGroupVersion Sets Go Variable: api.SchemeGroupVersion
	SchemeGroupVersion is group version used to register these objects
	TODO this should be in the "kubeconfig" group
	
	"""
	if isinstance(value, go.GoClass):
		_clientcmd.api_Set_SchemeGroupVersion(value.handle)
	else:
		_clientcmd.api_Set_SchemeGroupVersion(value)



# ---- Interfaces ---


# ---- Structs ---

# Python type for struct api.Config
class Config(go.GoClass):
	"""Config holds the information needed to build connect to remote kubernetes clusters as a given user\nIMPORTANT if you add fields to this struct, please update IsConfigEmpty()\n+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.api_Config_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Kind = args[0]
			if "Kind" in kwargs:
				self.Kind = kwargs["Kind"]
			if  1 < len(args):
				self.APIVersion = args[1]
			if "APIVersion" in kwargs:
				self.APIVersion = kwargs["APIVersion"]
			if  2 < len(args):
				self.Preferences = args[2]
			if "Preferences" in kwargs:
				self.Preferences = kwargs["Preferences"]
			if  3 < len(args):
				self.Clusters = args[3]
			if "Clusters" in kwargs:
				self.Clusters = kwargs["Clusters"]
			if  4 < len(args):
				self.AuthInfos = args[4]
			if "AuthInfos" in kwargs:
				self.AuthInfos = kwargs["AuthInfos"]
			if  5 < len(args):
				self.Contexts = args[5]
			if "Contexts" in kwargs:
				self.Contexts = kwargs["Contexts"]
			if  6 < len(args):
				self.CurrentContext = args[6]
			if "CurrentContext" in kwargs:
				self.CurrentContext = kwargs["CurrentContext"]
			if  7 < len(args):
				self.Extensions = args[7]
			if "Extensions" in kwargs:
				self.Extensions = kwargs["Extensions"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.Config{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.Config ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Kind(self):
		"""Legacy field from pkg/api/types.go TypeMeta.
		TODO(jlowdermilk): remove this after eliminating downstream dependencies.
		+k8s:conversion-gen=false
		+optional
		"""
		return _clientcmd.api_Config_Kind_Get(self.handle)
	@Kind.setter
	def Kind(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Config_Kind_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Config_Kind_Set(self.handle, value)
	@property
	def APIVersion(self):
		"""Legacy field from pkg/api/types.go TypeMeta.
		TODO(jlowdermilk): remove this after eliminating downstream dependencies.
		+k8s:conversion-gen=false
		+optional
		"""
		return _clientcmd.api_Config_APIVersion_Get(self.handle)
	@APIVersion.setter
	def APIVersion(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Config_APIVersion_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Config_APIVersion_Set(self.handle, value)
	@property
	def Preferences(self):
		"""Preferences holds general information to be use for cli interactions
		"""
		return Preferences(handle=_clientcmd.api_Config_Preferences_Get(self.handle))
	@Preferences.setter
	def Preferences(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Config_Preferences_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Clusters(self):
		"""Clusters is a map of referencable names to cluster configs
		"""
		return clientcmd.Map_string_Ptr_api_Cluster(handle=_clientcmd.api_Config_Clusters_Get(self.handle))
	@Clusters.setter
	def Clusters(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Config_Clusters_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AuthInfos(self):
		"""AuthInfos is a map of referencable names to user configs
		"""
		return clientcmd.Map_string_Ptr_api_AuthInfo(handle=_clientcmd.api_Config_AuthInfos_Get(self.handle))
	@AuthInfos.setter
	def AuthInfos(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Config_AuthInfos_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Contexts(self):
		"""Contexts is a map of referencable names to context configs
		"""
		return clientcmd.Map_string_Ptr_api_Context(handle=_clientcmd.api_Config_Contexts_Get(self.handle))
	@Contexts.setter
	def Contexts(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Config_Contexts_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CurrentContext(self):
		"""CurrentContext is the name of the context that you would like to use by default
		"""
		return _clientcmd.api_Config_CurrentContext_Get(self.handle)
	@CurrentContext.setter
	def CurrentContext(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Config_CurrentContext_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Config_CurrentContext_Set(self.handle, value)
	@property
	def Extensions(self):
		"""Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
		+optional
		"""
		return clientcmd.Map_string_runtime_Object(handle=_clientcmd.api_Config_Extensions_Get(self.handle))
	@Extensions.setter
	def Extensions(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Config_Extensions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def GetObjectKind(self):
		"""GetObjectKind() object"""
		return go.schema_ObjectKind(handle=_clientcmd.api_Config_GetObjectKind(self.handle))
	def SetGroupVersionKind(self, gvk, goRun=False):
		"""SetGroupVersionKind(object gvk) """
		_clientcmd.api_Config_SetGroupVersionKind(self.handle, gvk.handle, goRun)
	def GroupVersionKind(self):
		"""GroupVersionKind() object"""
		return go.schema_GroupVersionKind(handle=_clientcmd.api_Config_GroupVersionKind(self.handle))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.api_Config_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Config.
		"""
		return Config(handle=_clientcmd.api_Config_DeepCopy(self.handle))
	def DeepCopyObject(self):
		"""DeepCopyObject() object
		
		DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
		"""
		return go.runtime_Object(handle=_clientcmd.api_Config_DeepCopyObject(self.handle))

# Python type for struct api.Context
class Context(go.GoClass):
	"""Context is a tuple of references to a cluster (how do I communicate with a kubernetes cluster), a user (how do I identify myself), and a namespace (what subset of resources do I want to work with)\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.api_Context_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.LocationOfOrigin = args[0]
			if "LocationOfOrigin" in kwargs:
				self.LocationOfOrigin = kwargs["LocationOfOrigin"]
			if  1 < len(args):
				self.Cluster = args[1]
			if "Cluster" in kwargs:
				self.Cluster = kwargs["Cluster"]
			if  2 < len(args):
				self.AuthInfo = args[2]
			if "AuthInfo" in kwargs:
				self.AuthInfo = kwargs["AuthInfo"]
			if  3 < len(args):
				self.Namespace = args[3]
			if "Namespace" in kwargs:
				self.Namespace = kwargs["Namespace"]
			if  4 < len(args):
				self.Extensions = args[4]
			if "Extensions" in kwargs:
				self.Extensions = kwargs["Extensions"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.Context{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.Context ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def LocationOfOrigin(self):
		"""LocationOfOrigin indicates where this object came from.  It is used for round tripping config post-merge, but never serialized.
		+k8s:conversion-gen=false
		"""
		return _clientcmd.api_Context_LocationOfOrigin_Get(self.handle)
	@LocationOfOrigin.setter
	def LocationOfOrigin(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Context_LocationOfOrigin_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Context_LocationOfOrigin_Set(self.handle, value)
	@property
	def Cluster(self):
		"""Cluster is the name of the cluster for this context
		"""
		return _clientcmd.api_Context_Cluster_Get(self.handle)
	@Cluster.setter
	def Cluster(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Context_Cluster_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Context_Cluster_Set(self.handle, value)
	@property
	def AuthInfo(self):
		"""AuthInfo is the name of the authInfo for this context
		"""
		return _clientcmd.api_Context_AuthInfo_Get(self.handle)
	@AuthInfo.setter
	def AuthInfo(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Context_AuthInfo_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Context_AuthInfo_Set(self.handle, value)
	@property
	def Namespace(self):
		"""Namespace is the default namespace to use on unspecified requests
		+optional
		"""
		return _clientcmd.api_Context_Namespace_Get(self.handle)
	@Namespace.setter
	def Namespace(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Context_Namespace_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Context_Namespace_Set(self.handle, value)
	@property
	def Extensions(self):
		"""Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
		+optional
		"""
		return clientcmd.Map_string_runtime_Object(handle=_clientcmd.api_Context_Extensions_Get(self.handle))
	@Extensions.setter
	def Extensions(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Context_Extensions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.api_Context_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Context.
		"""
		return Context(handle=_clientcmd.api_Context_DeepCopy(self.handle))

# Python type for struct api.ExecConfig
class ExecConfig(go.GoClass):
	"""ExecConfig specifies a command to provide client credentials. The command is exec'd\nand outputs structured stdout holding credentials.\n\nSee the client.authentication.k8s.io API group for specifications of the exact input\nand output format\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.api_ExecConfig_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Command = args[0]
			if "Command" in kwargs:
				self.Command = kwargs["Command"]
			if  1 < len(args):
				self.Args = args[1]
			if "Args" in kwargs:
				self.Args = kwargs["Args"]
			if  2 < len(args):
				self.Env = args[2]
			if "Env" in kwargs:
				self.Env = kwargs["Env"]
			if  3 < len(args):
				self.APIVersion = args[3]
			if "APIVersion" in kwargs:
				self.APIVersion = kwargs["APIVersion"]
			if  4 < len(args):
				self.InstallHint = args[4]
			if "InstallHint" in kwargs:
				self.InstallHint = kwargs["InstallHint"]
			if  5 < len(args):
				self.ProvideClusterInfo = args[5]
			if "ProvideClusterInfo" in kwargs:
				self.ProvideClusterInfo = kwargs["ProvideClusterInfo"]
			if  6 < len(args):
				self.Config = args[6]
			if "Config" in kwargs:
				self.Config = kwargs["Config"]
			if  7 < len(args):
				self.InteractiveMode = args[7]
			if "InteractiveMode" in kwargs:
				self.InteractiveMode = kwargs["InteractiveMode"]
			if  8 < len(args):
				self.StdinUnavailable = args[8]
			if "StdinUnavailable" in kwargs:
				self.StdinUnavailable = kwargs["StdinUnavailable"]
			if  9 < len(args):
				self.StdinUnavailableMessage = args[9]
			if "StdinUnavailableMessage" in kwargs:
				self.StdinUnavailableMessage = kwargs["StdinUnavailableMessage"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		return self.String()
	
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.ExecConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Command(self):
		"""Command to execute.
		"""
		return _clientcmd.api_ExecConfig_Command_Get(self.handle)
	@Command.setter
	def Command(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecConfig_Command_Set(self.handle, value.handle)
		else:
			_clientcmd.api_ExecConfig_Command_Set(self.handle, value)
	@property
	def Args(self):
		"""Arguments to pass to the command when executing it.
		+optional
		"""
		return go.Slice_string(handle=_clientcmd.api_ExecConfig_Args_Get(self.handle))
	@Args.setter
	def Args(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecConfig_Args_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Env(self):
		"""Env defines additional environment variables to expose to the process. These
		are unioned with the host's environment, as well as variables client-go uses
		to pass argument to the plugin.
		+optional
		"""
		return clientcmd.Slice_api_ExecEnvVar(handle=_clientcmd.api_ExecConfig_Env_Get(self.handle))
	@Env.setter
	def Env(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecConfig_Env_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def APIVersion(self):
		"""Preferred input version of the ExecInfo. The returned ExecCredentials MUST use
		the same encoding version as the input.
		"""
		return _clientcmd.api_ExecConfig_APIVersion_Get(self.handle)
	@APIVersion.setter
	def APIVersion(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecConfig_APIVersion_Set(self.handle, value.handle)
		else:
			_clientcmd.api_ExecConfig_APIVersion_Set(self.handle, value)
	@property
	def InstallHint(self):
		"""This text is shown to the user when the executable doesn't seem to be
		present. For example, `brew install foo-cli` might be a good InstallHint for
		foo-cli on Mac OS systems.
		"""
		return _clientcmd.api_ExecConfig_InstallHint_Get(self.handle)
	@InstallHint.setter
	def InstallHint(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecConfig_InstallHint_Set(self.handle, value.handle)
		else:
			_clientcmd.api_ExecConfig_InstallHint_Set(self.handle, value)
	@property
	def ProvideClusterInfo(self):
		"""ProvideClusterInfo determines whether or not to provide cluster information,
		which could potentially contain very large CA data, to this exec plugin as a
		part of the KUBERNETES_EXEC_INFO environment variable. By default, it is set
		to false. Package k8s.io/client-go/tools/auth/exec provides helper methods for
		reading this environment variable.
		"""
		return _clientcmd.api_ExecConfig_ProvideClusterInfo_Get(self.handle)
	@ProvideClusterInfo.setter
	def ProvideClusterInfo(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecConfig_ProvideClusterInfo_Set(self.handle, value.handle)
		else:
			_clientcmd.api_ExecConfig_ProvideClusterInfo_Set(self.handle, value)
	@property
	def Config(self):
		"""Config holds additional config data that is specific to the exec
		plugin with regards to the cluster being authenticated to.
		
		This data is sourced from the clientcmd Cluster object's extensions[exec] field:
		
		clusters:
		- name: my-cluster
		  cluster:
		    ...
		    extensions:
		    - name: client.authentication.k8s.io/exec  # reserved extension name for per cluster exec config
		      extension:
		        audience: 06e3fbd18de8  # arbitrary config
		
		In some environments, the user config may be exactly the same across many clusters
		(i.e. call this exec plugin) minus some details that are specific to each cluster
		such as the audience.  This field allows the per cluster config to be directly
		specified with the cluster info.  Using this field to store secret data is not
		recommended as one of the prime benefits of exec plugins is that no secrets need
		to be stored directly in the kubeconfig.
		+k8s:conversion-gen=false
		"""
		return go.runtime_Object(handle=_clientcmd.api_ExecConfig_Config_Get(self.handle))
	@Config.setter
	def Config(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecConfig_Config_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def InteractiveMode(self):
		"""InteractiveMode determines this plugin's relationship with standard input. Valid
		values are "Never" (this exec plugin never uses standard input), "IfAvailable" (this
		exec plugin wants to use standard input if it is available), or "Always" (this exec
		plugin requires standard input to function). See ExecInteractiveMode values for more
		details.
		
		If APIVersion is client.authentication.k8s.io/v1alpha1 or
		client.authentication.k8s.io/v1beta1, then this field is optional and defaults
		to "IfAvailable" when unset. Otherwise, this field is required.
		+optional
		"""
		return _clientcmd.api_ExecConfig_InteractiveMode_Get(self.handle)
	@InteractiveMode.setter
	def InteractiveMode(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecConfig_InteractiveMode_Set(self.handle, value.handle)
		else:
			_clientcmd.api_ExecConfig_InteractiveMode_Set(self.handle, value)
	@property
	def StdinUnavailable(self):
		"""StdinUnavailable indicates whether the exec authenticator can pass standard
		input through to this exec plugin. For example, a higher level entity might be using
		standard input for something else and therefore it would not be safe for the exec
		plugin to use standard input. This is kept here in order to keep all of the exec configuration
		together, but it is never serialized.
		+k8s:conversion-gen=false
		"""
		return _clientcmd.api_ExecConfig_StdinUnavailable_Get(self.handle)
	@StdinUnavailable.setter
	def StdinUnavailable(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecConfig_StdinUnavailable_Set(self.handle, value.handle)
		else:
			_clientcmd.api_ExecConfig_StdinUnavailable_Set(self.handle, value)
	@property
	def StdinUnavailableMessage(self):
		"""StdinUnavailableMessage is an optional message to be displayed when the exec authenticator
		cannot successfully run this exec plugin because it needs to use standard input and
		StdinUnavailable is true. For example, a process that is already using standard input to
		read user instructions might set this to "used by my-program to read user instructions".
		+k8s:conversion-gen=false
		"""
		return _clientcmd.api_ExecConfig_StdinUnavailableMessage_Get(self.handle)
	@StdinUnavailableMessage.setter
	def StdinUnavailableMessage(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecConfig_StdinUnavailableMessage_Set(self.handle, value.handle)
		else:
			_clientcmd.api_ExecConfig_StdinUnavailableMessage_Set(self.handle, value)
	def GoString(self):
		"""GoString() str
		
		GoString implements fmt.GoStringer and sanitizes sensitive fields of
		ExecConfig to prevent accidental leaking via logs.
		"""
		return _clientcmd.api_ExecConfig_GoString(self.handle)
	def String(self):
		"""String() str
		
		String implements fmt.Stringer and sanitizes sensitive fields of ExecConfig
		to prevent accidental leaking via logs.
		"""
		return _clientcmd.api_ExecConfig_String(self.handle)
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.api_ExecConfig_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExecConfig.
		"""
		return ExecConfig(handle=_clientcmd.api_ExecConfig_DeepCopy(self.handle))

# Python type for struct api.ExecEnvVar
class ExecEnvVar(go.GoClass):
	"""ExecEnvVar is used for setting environment variables when executing an exec-based\ncredential plugin.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.api_ExecEnvVar_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Value = args[1]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.ExecEnvVar{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.ExecEnvVar ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _clientcmd.api_ExecEnvVar_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecEnvVar_Name_Set(self.handle, value.handle)
		else:
			_clientcmd.api_ExecEnvVar_Name_Set(self.handle, value)
	@property
	def Value(self):
		return _clientcmd.api_ExecEnvVar_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_ExecEnvVar_Value_Set(self.handle, value.handle)
		else:
			_clientcmd.api_ExecEnvVar_Value_Set(self.handle, value)
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.api_ExecEnvVar_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExecEnvVar.
		"""
		return ExecEnvVar(handle=_clientcmd.api_ExecEnvVar_DeepCopy(self.handle))

# Python type for struct api.Preferences
class Preferences(go.GoClass):
	"""IMPORTANT if you add fields to this struct, please update IsConfigEmpty()\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.api_Preferences_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Colors = args[0]
			if "Colors" in kwargs:
				self.Colors = kwargs["Colors"]
			if  1 < len(args):
				self.Extensions = args[1]
			if "Extensions" in kwargs:
				self.Extensions = kwargs["Extensions"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.Preferences{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.Preferences ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Colors(self):
		"""+optional
		"""
		return _clientcmd.api_Preferences_Colors_Get(self.handle)
	@Colors.setter
	def Colors(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Preferences_Colors_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Preferences_Colors_Set(self.handle, value)
	@property
	def Extensions(self):
		"""Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
		+optional
		"""
		return clientcmd.Map_string_runtime_Object(handle=_clientcmd.api_Preferences_Extensions_Get(self.handle))
	@Extensions.setter
	def Extensions(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Preferences_Extensions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.api_Preferences_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Preferences.
		"""
		return Preferences(handle=_clientcmd.api_Preferences_DeepCopy(self.handle))

# Python type for struct api.AuthInfo
class AuthInfo(go.GoClass):
	"""AuthInfo contains information that describes identity information.  This is use to tell the kubernetes cluster who you are.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.api_AuthInfo_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.LocationOfOrigin = args[0]
			if "LocationOfOrigin" in kwargs:
				self.LocationOfOrigin = kwargs["LocationOfOrigin"]
			if  1 < len(args):
				self.ClientCertificate = args[1]
			if "ClientCertificate" in kwargs:
				self.ClientCertificate = kwargs["ClientCertificate"]
			if  2 < len(args):
				self.ClientCertificateData = args[2]
			if "ClientCertificateData" in kwargs:
				self.ClientCertificateData = kwargs["ClientCertificateData"]
			if  3 < len(args):
				self.ClientKey = args[3]
			if "ClientKey" in kwargs:
				self.ClientKey = kwargs["ClientKey"]
			if  4 < len(args):
				self.ClientKeyData = args[4]
			if "ClientKeyData" in kwargs:
				self.ClientKeyData = kwargs["ClientKeyData"]
			if  5 < len(args):
				self.Token = args[5]
			if "Token" in kwargs:
				self.Token = kwargs["Token"]
			if  6 < len(args):
				self.TokenFile = args[6]
			if "TokenFile" in kwargs:
				self.TokenFile = kwargs["TokenFile"]
			if  7 < len(args):
				self.Impersonate = args[7]
			if "Impersonate" in kwargs:
				self.Impersonate = kwargs["Impersonate"]
			if  8 < len(args):
				self.ImpersonateUID = args[8]
			if "ImpersonateUID" in kwargs:
				self.ImpersonateUID = kwargs["ImpersonateUID"]
			if  9 < len(args):
				self.ImpersonateGroups = args[9]
			if "ImpersonateGroups" in kwargs:
				self.ImpersonateGroups = kwargs["ImpersonateGroups"]
			if  10 < len(args):
				self.ImpersonateUserExtra = args[10]
			if "ImpersonateUserExtra" in kwargs:
				self.ImpersonateUserExtra = kwargs["ImpersonateUserExtra"]
			if  11 < len(args):
				self.Username = args[11]
			if "Username" in kwargs:
				self.Username = kwargs["Username"]
			if  12 < len(args):
				self.Password = args[12]
			if "Password" in kwargs:
				self.Password = kwargs["Password"]
			if  13 < len(args):
				self.AuthProvider = args[13]
			if "AuthProvider" in kwargs:
				self.AuthProvider = kwargs["AuthProvider"]
			if  14 < len(args):
				self.Exec = args[14]
			if "Exec" in kwargs:
				self.Exec = kwargs["Exec"]
			if  15 < len(args):
				self.Extensions = args[15]
			if "Extensions" in kwargs:
				self.Extensions = kwargs["Extensions"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.AuthInfo{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.AuthInfo ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def LocationOfOrigin(self):
		"""LocationOfOrigin indicates where this object came from.  It is used for round tripping config post-merge, but never serialized.
		+k8s:conversion-gen=false
		"""
		return _clientcmd.api_AuthInfo_LocationOfOrigin_Get(self.handle)
	@LocationOfOrigin.setter
	def LocationOfOrigin(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_LocationOfOrigin_Set(self.handle, value.handle)
		else:
			_clientcmd.api_AuthInfo_LocationOfOrigin_Set(self.handle, value)
	@property
	def ClientCertificate(self):
		"""ClientCertificate is the path to a client cert file for TLS.
		+optional
		"""
		return _clientcmd.api_AuthInfo_ClientCertificate_Get(self.handle)
	@ClientCertificate.setter
	def ClientCertificate(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_ClientCertificate_Set(self.handle, value.handle)
		else:
			_clientcmd.api_AuthInfo_ClientCertificate_Set(self.handle, value)
	@property
	def ClientCertificateData(self):
		"""ClientCertificateData contains PEM-encoded data from a client cert file for TLS. Overrides ClientCertificate
		+optional
		"""
		return go.Slice_byte(handle=_clientcmd.api_AuthInfo_ClientCertificateData_Get(self.handle))
	@ClientCertificateData.setter
	def ClientCertificateData(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_ClientCertificateData_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ClientKey(self):
		"""ClientKey is the path to a client key file for TLS.
		+optional
		"""
		return _clientcmd.api_AuthInfo_ClientKey_Get(self.handle)
	@ClientKey.setter
	def ClientKey(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_ClientKey_Set(self.handle, value.handle)
		else:
			_clientcmd.api_AuthInfo_ClientKey_Set(self.handle, value)
	@property
	def ClientKeyData(self):
		"""ClientKeyData contains PEM-encoded data from a client key file for TLS. Overrides ClientKey
		+optional
		"""
		return go.Slice_byte(handle=_clientcmd.api_AuthInfo_ClientKeyData_Get(self.handle))
	@ClientKeyData.setter
	def ClientKeyData(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_ClientKeyData_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Token(self):
		"""Token is the bearer token for authentication to the kubernetes cluster.
		+optional
		"""
		return _clientcmd.api_AuthInfo_Token_Get(self.handle)
	@Token.setter
	def Token(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_Token_Set(self.handle, value.handle)
		else:
			_clientcmd.api_AuthInfo_Token_Set(self.handle, value)
	@property
	def TokenFile(self):
		"""TokenFile is a pointer to a file that contains a bearer token (as described above).  If both Token and TokenFile are present, Token takes precedence.
		+optional
		"""
		return _clientcmd.api_AuthInfo_TokenFile_Get(self.handle)
	@TokenFile.setter
	def TokenFile(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_TokenFile_Set(self.handle, value.handle)
		else:
			_clientcmd.api_AuthInfo_TokenFile_Set(self.handle, value)
	@property
	def Impersonate(self):
		"""Impersonate is the username to act-as.
		+optional
		"""
		return _clientcmd.api_AuthInfo_Impersonate_Get(self.handle)
	@Impersonate.setter
	def Impersonate(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_Impersonate_Set(self.handle, value.handle)
		else:
			_clientcmd.api_AuthInfo_Impersonate_Set(self.handle, value)
	@property
	def ImpersonateUID(self):
		"""ImpersonateUID is the uid to impersonate.
		+optional
		"""
		return _clientcmd.api_AuthInfo_ImpersonateUID_Get(self.handle)
	@ImpersonateUID.setter
	def ImpersonateUID(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_ImpersonateUID_Set(self.handle, value.handle)
		else:
			_clientcmd.api_AuthInfo_ImpersonateUID_Set(self.handle, value)
	@property
	def ImpersonateGroups(self):
		"""ImpersonateGroups is the groups to impersonate.
		+optional
		"""
		return go.Slice_string(handle=_clientcmd.api_AuthInfo_ImpersonateGroups_Get(self.handle))
	@ImpersonateGroups.setter
	def ImpersonateGroups(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_ImpersonateGroups_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ImpersonateUserExtra(self):
		"""ImpersonateUserExtra contains additional information for impersonated user.
		+optional
		"""
		return clientcmd.Map_string_Slice_string(handle=_clientcmd.api_AuthInfo_ImpersonateUserExtra_Get(self.handle))
	@ImpersonateUserExtra.setter
	def ImpersonateUserExtra(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_ImpersonateUserExtra_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Username(self):
		"""Username is the username for basic authentication to the kubernetes cluster.
		+optional
		"""
		return _clientcmd.api_AuthInfo_Username_Get(self.handle)
	@Username.setter
	def Username(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_Username_Set(self.handle, value.handle)
		else:
			_clientcmd.api_AuthInfo_Username_Set(self.handle, value)
	@property
	def Password(self):
		"""Password is the password for basic authentication to the kubernetes cluster.
		+optional
		"""
		return _clientcmd.api_AuthInfo_Password_Get(self.handle)
	@Password.setter
	def Password(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_Password_Set(self.handle, value.handle)
		else:
			_clientcmd.api_AuthInfo_Password_Set(self.handle, value)
	@property
	def AuthProvider(self):
		"""AuthProvider specifies a custom authentication plugin for the kubernetes cluster.
		+optional
		"""
		return AuthProviderConfig(handle=_clientcmd.api_AuthInfo_AuthProvider_Get(self.handle))
	@AuthProvider.setter
	def AuthProvider(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_AuthProvider_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Exec(self):
		"""Exec specifies a custom exec-based authentication plugin for the kubernetes cluster.
		+optional
		"""
		return ExecConfig(handle=_clientcmd.api_AuthInfo_Exec_Get(self.handle))
	@Exec.setter
	def Exec(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_Exec_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Extensions(self):
		"""Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
		+optional
		"""
		return clientcmd.Map_string_runtime_Object(handle=_clientcmd.api_AuthInfo_Extensions_Get(self.handle))
	@Extensions.setter
	def Extensions(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthInfo_Extensions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.api_AuthInfo_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthInfo.
		"""
		return AuthInfo(handle=_clientcmd.api_AuthInfo_DeepCopy(self.handle))

# Python type for struct api.AuthProviderConfig
class AuthProviderConfig(go.GoClass):
	"""AuthProviderConfig holds the configuration for a specified auth provider.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.api_AuthProviderConfig_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Config = args[1]
			if "Config" in kwargs:
				self.Config = kwargs["Config"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		return self.String()
	
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.AuthProviderConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _clientcmd.api_AuthProviderConfig_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthProviderConfig_Name_Set(self.handle, value.handle)
		else:
			_clientcmd.api_AuthProviderConfig_Name_Set(self.handle, value)
	@property
	def Config(self):
		"""+optional
		"""
		return clientcmd.Map_string_string(handle=_clientcmd.api_AuthProviderConfig_Config_Get(self.handle))
	@Config.setter
	def Config(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_AuthProviderConfig_Config_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def GoString(self):
		"""GoString() str
		
		GoString implements fmt.GoStringer and sanitizes sensitive fields of
		AuthProviderConfig to prevent accidental leaking via logs.
		"""
		return _clientcmd.api_AuthProviderConfig_GoString(self.handle)
	def String(self):
		"""String() str
		
		String implements fmt.Stringer and sanitizes sensitive fields of
		AuthProviderConfig to prevent accidental leaking via logs.
		"""
		return _clientcmd.api_AuthProviderConfig_String(self.handle)
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.api_AuthProviderConfig_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthProviderConfig.
		"""
		return AuthProviderConfig(handle=_clientcmd.api_AuthProviderConfig_DeepCopy(self.handle))

# Python type for struct api.Cluster
class Cluster(go.GoClass):
	"""Cluster contains information about how to communicate with a kubernetes cluster\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.api_Cluster_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.LocationOfOrigin = args[0]
			if "LocationOfOrigin" in kwargs:
				self.LocationOfOrigin = kwargs["LocationOfOrigin"]
			if  1 < len(args):
				self.Server = args[1]
			if "Server" in kwargs:
				self.Server = kwargs["Server"]
			if  2 < len(args):
				self.TLSServerName = args[2]
			if "TLSServerName" in kwargs:
				self.TLSServerName = kwargs["TLSServerName"]
			if  3 < len(args):
				self.InsecureSkipTLSVerify = args[3]
			if "InsecureSkipTLSVerify" in kwargs:
				self.InsecureSkipTLSVerify = kwargs["InsecureSkipTLSVerify"]
			if  4 < len(args):
				self.CertificateAuthority = args[4]
			if "CertificateAuthority" in kwargs:
				self.CertificateAuthority = kwargs["CertificateAuthority"]
			if  5 < len(args):
				self.CertificateAuthorityData = args[5]
			if "CertificateAuthorityData" in kwargs:
				self.CertificateAuthorityData = kwargs["CertificateAuthorityData"]
			if  6 < len(args):
				self.ProxyURL = args[6]
			if "ProxyURL" in kwargs:
				self.ProxyURL = kwargs["ProxyURL"]
			if  7 < len(args):
				self.DisableCompression = args[7]
			if "DisableCompression" in kwargs:
				self.DisableCompression = kwargs["DisableCompression"]
			if  8 < len(args):
				self.Extensions = args[8]
			if "Extensions" in kwargs:
				self.Extensions = kwargs["Extensions"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.Cluster{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.Cluster ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def LocationOfOrigin(self):
		"""LocationOfOrigin indicates where this object came from.  It is used for round tripping config post-merge, but never serialized.
		+k8s:conversion-gen=false
		"""
		return _clientcmd.api_Cluster_LocationOfOrigin_Get(self.handle)
	@LocationOfOrigin.setter
	def LocationOfOrigin(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Cluster_LocationOfOrigin_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Cluster_LocationOfOrigin_Set(self.handle, value)
	@property
	def Server(self):
		"""Server is the address of the kubernetes cluster (https://hostname:port).
		"""
		return _clientcmd.api_Cluster_Server_Get(self.handle)
	@Server.setter
	def Server(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Cluster_Server_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Cluster_Server_Set(self.handle, value)
	@property
	def TLSServerName(self):
		"""TLSServerName is used to check server certificate. If TLSServerName is empty, the hostname used to contact the server is used.
		+optional
		"""
		return _clientcmd.api_Cluster_TLSServerName_Get(self.handle)
	@TLSServerName.setter
	def TLSServerName(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Cluster_TLSServerName_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Cluster_TLSServerName_Set(self.handle, value)
	@property
	def InsecureSkipTLSVerify(self):
		"""InsecureSkipTLSVerify skips the validity check for the server's certificate. This will make your HTTPS connections insecure.
		+optional
		"""
		return _clientcmd.api_Cluster_InsecureSkipTLSVerify_Get(self.handle)
	@InsecureSkipTLSVerify.setter
	def InsecureSkipTLSVerify(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Cluster_InsecureSkipTLSVerify_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Cluster_InsecureSkipTLSVerify_Set(self.handle, value)
	@property
	def CertificateAuthority(self):
		"""CertificateAuthority is the path to a cert file for the certificate authority.
		+optional
		"""
		return _clientcmd.api_Cluster_CertificateAuthority_Get(self.handle)
	@CertificateAuthority.setter
	def CertificateAuthority(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Cluster_CertificateAuthority_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Cluster_CertificateAuthority_Set(self.handle, value)
	@property
	def CertificateAuthorityData(self):
		"""CertificateAuthorityData contains PEM-encoded certificate authority certificates. Overrides CertificateAuthority
		+optional
		"""
		return go.Slice_byte(handle=_clientcmd.api_Cluster_CertificateAuthorityData_Get(self.handle))
	@CertificateAuthorityData.setter
	def CertificateAuthorityData(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Cluster_CertificateAuthorityData_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ProxyURL(self):
		"""ProxyURL is the URL to the proxy to be used for all requests made by this
		client. URLs with "http", "https", and "socks5" schemes are supported.  If
		this configuration is not provided or the empty string, the client
		attempts to construct a proxy configuration from http_proxy and
		https_proxy environment variables. If these environment variables are not
		set, the client does not attempt to proxy requests.
		
		socks5 proxying does not currently support spdy streaming endpoints (exec,
		attach, port forward).
		+optional
		"""
		return _clientcmd.api_Cluster_ProxyURL_Get(self.handle)
	@ProxyURL.setter
	def ProxyURL(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Cluster_ProxyURL_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Cluster_ProxyURL_Set(self.handle, value)
	@property
	def DisableCompression(self):
		"""DisableCompression allows client to opt-out of response compression for all requests to the server. This is useful
		to speed up requests (specifically lists) when client-server network bandwidth is ample, by saving time on
		compression (server-side) and decompression (client-side): https://github.com/kubernetes/kubernetes/issues/112296.
		+optional
		"""
		return _clientcmd.api_Cluster_DisableCompression_Get(self.handle)
	@DisableCompression.setter
	def DisableCompression(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Cluster_DisableCompression_Set(self.handle, value.handle)
		else:
			_clientcmd.api_Cluster_DisableCompression_Set(self.handle, value)
	@property
	def Extensions(self):
		"""Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
		+optional
		"""
		return clientcmd.Map_string_runtime_Object(handle=_clientcmd.api_Cluster_Extensions_Get(self.handle))
	@Extensions.setter
	def Extensions(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.api_Cluster_Extensions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.api_Cluster_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Cluster.
		"""
		return Cluster(handle=_clientcmd.api_Cluster_DeepCopy(self.handle))


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewConfig():
	"""NewConfig() object
	
	NewConfig is a convenience function that returns a new Config object with non-nil maps
	"""
	return Config(handle=_clientcmd.api_NewConfig())
def NewContext():
	"""NewContext() object
	
	NewContext is a convenience function that returns a new Context
	object with non-nil maps
	"""
	return Context(handle=_clientcmd.api_NewContext())
def NewPreferences():
	"""NewPreferences() object
	
	NewPreferences is a convenience function that returns a new
	Preferences object with non-nil maps
	"""
	return Preferences(handle=_clientcmd.api_NewPreferences())
def NewAuthInfo():
	"""NewAuthInfo() object
	
	NewAuthInfo is a convenience function that returns a new AuthInfo
	object with non-nil maps
	"""
	return AuthInfo(handle=_clientcmd.api_NewAuthInfo())
def NewCluster():
	"""NewCluster() object
	
	NewCluster is a convenience function that returns a new Cluster
	object with non-nil maps
	"""
	return Cluster(handle=_clientcmd.api_NewCluster())


# ---- Functions ---
def FlattenConfig(config):
	"""FlattenConfig(object config) str
	
	FlattenConfig changes the config object into a self-contained config (useful for making secrets)
	"""
	return _clientcmd.api_FlattenConfig(config.handle)
def MakeAbs(path, base):
	"""MakeAbs(str path, str base) str, str"""
	return _clientcmd.api_MakeAbs(path, base)
def RedactSecrets(config):
	"""RedactSecrets(object config) str
	
	RedactSecrets replaces any sensitive values with REDACTED
	"""
	return _clientcmd.api_RedactSecrets(config.handle)
def ResolvePath(path, base):
	"""ResolvePath(str path, str base) str
	
	ResolvePath returns the path as an absolute paths, relative to the given base directory
	"""
	return _clientcmd.api_ResolvePath(path, base)
def ShortenConfig(config, goRun=False):
	"""ShortenConfig(object config) 
	
	ShortenConfig redacts raw data entries from the config object for a human-readable view.
	"""
	_clientcmd.api_ShortenConfig(config.handle, goRun)
def IsConfigEmpty(config):
	"""IsConfigEmpty(object config) bool
	
	IsConfigEmpty returns true if the config is empty.
	"""
	return _clientcmd.api_IsConfigEmpty(config.handle)
def MinifyConfig(config):
	"""MinifyConfig(object config) str
	
	MinifyConfig read the current context and uses that to keep only the relevant pieces of config
	This is useful for making secrets based on kubeconfig files
	"""
	return _clientcmd.api_MinifyConfig(config.handle)


