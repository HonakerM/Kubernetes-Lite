"""
Package clientcmd provides one stop shopping for building a working client from a fixed config,
from a .kubeconfig file, from command line flags, or from any merged combination.

Sample usage from merged .kubeconfig files (local directory, home directory)

	loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
	// if you want to change the loading rules (which files in which order), you can do so here

	configOverrides := &clientcmd.ConfigOverrides{}
	// if you want to change override values or bind them to flags, there are methods to help you

	kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
	config, err := kubeConfig.ClientConfig()
	if err != nil {
		// Do something
	}
	client, err := metav1.New(config)
	// ...

"""
# python wrapper for package k8s.io/client-go/tools/clientcmd within overall package clientcmd
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg k8s.io/client-go/tools/clientcmd

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _clientcmd
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from clientcmd import clientcmd
# and then refer to everything using clientcmd. prefix
# packages imported by this package listed below:

from . import latest
from . import api



# ---- Types ---

# Python type for slice []*string
class Slice_Ptr_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Slice_Ptr_string_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_string.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Slice_Ptr_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'clientcmd.Slice_Ptr_string([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _clientcmd.Slice_Ptr_string_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _clientcmd.Slice_Ptr_string_len(self.handle)
				return Slice_Ptr_string(handle=_clientcmd.Slice_Ptr_string_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _clientcmd.Slice_Ptr_string_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_clientcmd.Slice_Ptr_string_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_string.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _clientcmd.Slice_Ptr_string_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_clientcmd.Slice_Ptr_string_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []api.ExecEnvVar
class Slice_api_ExecEnvVar(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Slice_api_ExecEnvVar_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_api_ExecEnvVar.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Slice_api_ExecEnvVar len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'clientcmd.Slice_api_ExecEnvVar([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _clientcmd.Slice_api_ExecEnvVar_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _clientcmd.Slice_api_ExecEnvVar_len(self.handle)
				return Slice_api_ExecEnvVar(handle=_clientcmd.Slice_api_ExecEnvVar_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return api.ExecEnvVar(handle=_clientcmd.Slice_api_ExecEnvVar_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_clientcmd.Slice_api_ExecEnvVar_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_api_ExecEnvVar.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = api.ExecEnvVar(handle=_clientcmd.Slice_api_ExecEnvVar_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_clientcmd.Slice_api_ExecEnvVar_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []net.IP
class Slice_net_IP(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Slice_net_IP_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_net_IP.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Slice_net_IP len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'clientcmd.Slice_net_IP([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _clientcmd.Slice_net_IP_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _clientcmd.Slice_net_IP_len(self.handle)
				return Slice_net_IP(handle=_clientcmd.Slice_net_IP_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.net_IP(handle=_clientcmd.Slice_net_IP_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_clientcmd.Slice_net_IP_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_net_IP.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.net_IP(handle=_clientcmd.Slice_net_IP_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_clientcmd.Slice_net_IP_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []time.Duration
class Slice_time_Duration(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Slice_time_Duration_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_time_Duration.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Slice_time_Duration len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'clientcmd.Slice_time_Duration([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _clientcmd.Slice_time_Duration_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _clientcmd.Slice_time_Duration_len(self.handle)
				return Slice_time_Duration(handle=_clientcmd.Slice_time_Duration_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _clientcmd.Slice_time_Duration_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_clientcmd.Slice_time_Duration_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_time_Duration.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _clientcmd.Slice_time_Duration_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_clientcmd.Slice_time_Duration_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]*api.AuthInfo
class Map_string_Ptr_api_AuthInfo(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Map_string_Ptr_api_AuthInfo_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Ptr_api_AuthInfo.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_clientcmd.Map_string_Ptr_api_AuthInfo_set(self.handle, k, v)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Map_string_Ptr_api_AuthInfo len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'clientcmd.Map_string_Ptr_api_AuthInfo({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _clientcmd.Map_string_Ptr_api_AuthInfo_len(self.handle)
	def __getitem__(self, key):
		return api.AuthInfo(handle=_clientcmd.Map_string_Ptr_api_AuthInfo_elem(self.handle, key))
	def __setitem__(self, key, value):
		_clientcmd.Map_string_Ptr_api_AuthInfo_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _clientcmd.Map_string_Ptr_api_AuthInfo_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_clientcmd.Map_string_Ptr_api_AuthInfo_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _clientcmd.Map_string_Ptr_api_AuthInfo_contains(self.handle, key)

# Python type for map map[string]*api.Cluster
class Map_string_Ptr_api_Cluster(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Map_string_Ptr_api_Cluster_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Ptr_api_Cluster.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_clientcmd.Map_string_Ptr_api_Cluster_set(self.handle, k, v)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Map_string_Ptr_api_Cluster len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'clientcmd.Map_string_Ptr_api_Cluster({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _clientcmd.Map_string_Ptr_api_Cluster_len(self.handle)
	def __getitem__(self, key):
		return api.Cluster(handle=_clientcmd.Map_string_Ptr_api_Cluster_elem(self.handle, key))
	def __setitem__(self, key, value):
		_clientcmd.Map_string_Ptr_api_Cluster_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _clientcmd.Map_string_Ptr_api_Cluster_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_clientcmd.Map_string_Ptr_api_Cluster_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _clientcmd.Map_string_Ptr_api_Cluster_contains(self.handle, key)

# Python type for map map[string]*api.Context
class Map_string_Ptr_api_Context(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Map_string_Ptr_api_Context_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Ptr_api_Context.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_clientcmd.Map_string_Ptr_api_Context_set(self.handle, k, v)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Map_string_Ptr_api_Context len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'clientcmd.Map_string_Ptr_api_Context({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _clientcmd.Map_string_Ptr_api_Context_len(self.handle)
	def __getitem__(self, key):
		return api.Context(handle=_clientcmd.Map_string_Ptr_api_Context_elem(self.handle, key))
	def __setitem__(self, key, value):
		_clientcmd.Map_string_Ptr_api_Context_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _clientcmd.Map_string_Ptr_api_Context_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_clientcmd.Map_string_Ptr_api_Context_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _clientcmd.Map_string_Ptr_api_Context_contains(self.handle, key)

# Python type for map map[string][]string
class Map_string_Slice_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Map_string_Slice_string_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_clientcmd.Map_string_Slice_string_set(self.handle, k, v)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Map_string_Slice_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'clientcmd.Map_string_Slice_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _clientcmd.Map_string_Slice_string_len(self.handle)
	def __getitem__(self, key):
		return go.Slice_string(handle=_clientcmd.Map_string_Slice_string_elem(self.handle, key))
	def __setitem__(self, key, value):
		_clientcmd.Map_string_Slice_string_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _clientcmd.Map_string_Slice_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_clientcmd.Map_string_Slice_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _clientcmd.Map_string_Slice_string_contains(self.handle, key)

# Python type for map map[string]int
class Map_string_int(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Map_string_int_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_int.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_clientcmd.Map_string_int_set(self.handle, k, v)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Map_string_int len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'clientcmd.Map_string_int({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _clientcmd.Map_string_int_len(self.handle)
	def __getitem__(self, key):
		return _clientcmd.Map_string_int_elem(self.handle, key)
	def __setitem__(self, key, value):
		_clientcmd.Map_string_int_set(self.handle, key, value)
	def __delitem__(self, key):
		return _clientcmd.Map_string_int_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_clientcmd.Map_string_int_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _clientcmd.Map_string_int_contains(self.handle, key)

# Python type for map map[string]int64
class Map_string_int64(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Map_string_int64_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_int64.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_clientcmd.Map_string_int64_set(self.handle, k, v)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Map_string_int64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'clientcmd.Map_string_int64({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _clientcmd.Map_string_int64_len(self.handle)
	def __getitem__(self, key):
		return _clientcmd.Map_string_int64_elem(self.handle, key)
	def __setitem__(self, key, value):
		_clientcmd.Map_string_int64_set(self.handle, key, value)
	def __delitem__(self, key):
		return _clientcmd.Map_string_int64_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_clientcmd.Map_string_int64_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _clientcmd.Map_string_int64_contains(self.handle, key)

# Python type for map map[string]runtime.Object
class Map_string_runtime_Object(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Map_string_runtime_Object_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_runtime_Object.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_clientcmd.Map_string_runtime_Object_set(self.handle, k, v)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Map_string_runtime_Object len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'clientcmd.Map_string_runtime_Object({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _clientcmd.Map_string_runtime_Object_len(self.handle)
	def __getitem__(self, key):
		return go.runtime_Object(handle=_clientcmd.Map_string_runtime_Object_elem(self.handle, key))
	def __setitem__(self, key, value):
		_clientcmd.Map_string_runtime_Object_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _clientcmd.Map_string_runtime_Object_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_clientcmd.Map_string_runtime_Object_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _clientcmd.Map_string_runtime_Object_contains(self.handle, key)

# Python type for map map[string]string
class Map_string_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Map_string_string_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_clientcmd.Map_string_string_set(self.handle, k, v)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'clientcmd.Map_string_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'clientcmd.Map_string_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _clientcmd.Map_string_string_len(self.handle)
	def __getitem__(self, key):
		return _clientcmd.Map_string_string_elem(self.handle, key)
	def __setitem__(self, key, value):
		_clientcmd.Map_string_string_set(self.handle, key, value)
	def __delitem__(self, key):
		return _clientcmd.Map_string_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_clientcmd.Map_string_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _clientcmd.Map_string_string_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---
FlagAPIServer = "server"
FlagAuthInfoName = "user"
FlagBearerToken = "token"
FlagCAFile = "certificate-authority"
FlagCertFile = "client-certificate"
FlagClusterName = "cluster"
FlagContext = "context"
FlagDisableCompression = "disable-compression"
FlagEmbedCerts = "embed-certs"
FlagImpersonate = "as"
FlagImpersonateGroup = "as-group"
FlagImpersonateUID = "as-uid"
FlagInsecure = "insecure-skip-tls-verify"
FlagKeyFile = "client-key"
FlagNamespace = "namespace"
FlagPassword = "password"
FlagProxyURL = "proxy-url"
FlagTLSServerName = "tls-server-name"
FlagTimeout = "request-timeout"
FlagUsername = "username"
RecommendedConfigPathEnvVar = "KUBECONFIG"
RecommendedConfigPathFlag = "kubeconfig"
RecommendedFileName = "config"
RecommendedHomeDir = ".kube"
RecommendedSchemaName = "schema"


# ---- Global Variables: can only use functions to access ---
def ClusterDefaults():
	"""
	ClusterDefaults Gets Go Variable: clientcmd.ClusterDefaults
	
	"""
	return api.Cluster(handle=_clientcmd.clientcmd_ClusterDefaults())

def Set_ClusterDefaults(value):
	"""
	Set_ClusterDefaults Sets Go Variable: clientcmd.ClusterDefaults
	
	"""
	if isinstance(value, go.GoClass):
		_clientcmd.clientcmd_Set_ClusterDefaults(value.handle)
	else:
		_clientcmd.clientcmd_Set_ClusterDefaults(value)

def DefaultClientConfig():
	"""
	DefaultClientConfig Gets Go Variable: clientcmd.DefaultClientConfig
	
	"""
	return DirectClientConfig(handle=_clientcmd.clientcmd_DefaultClientConfig())

def Set_DefaultClientConfig(value):
	"""
	Set_DefaultClientConfig Sets Go Variable: clientcmd.DefaultClientConfig
	
	"""
	if isinstance(value, go.GoClass):
		_clientcmd.clientcmd_Set_DefaultClientConfig(value.handle)
	else:
		_clientcmd.clientcmd_Set_DefaultClientConfig(value)

def RecommendedConfigDir():
	"""
	RecommendedConfigDir Gets Go Variable: clientcmd.RecommendedConfigDir
	
	"""
	return _clientcmd.clientcmd_RecommendedConfigDir()

def Set_RecommendedConfigDir(value):
	"""
	Set_RecommendedConfigDir Sets Go Variable: clientcmd.RecommendedConfigDir
	
	"""
	if isinstance(value, go.GoClass):
		_clientcmd.clientcmd_Set_RecommendedConfigDir(value.handle)
	else:
		_clientcmd.clientcmd_Set_RecommendedConfigDir(value)

def RecommendedHomeFile():
	"""
	RecommendedHomeFile Gets Go Variable: clientcmd.RecommendedHomeFile
	
	"""
	return _clientcmd.clientcmd_RecommendedHomeFile()

def Set_RecommendedHomeFile(value):
	"""
	Set_RecommendedHomeFile Sets Go Variable: clientcmd.RecommendedHomeFile
	
	"""
	if isinstance(value, go.GoClass):
		_clientcmd.clientcmd_Set_RecommendedHomeFile(value.handle)
	else:
		_clientcmd.clientcmd_Set_RecommendedHomeFile(value)

def RecommendedSchemaFile():
	"""
	RecommendedSchemaFile Gets Go Variable: clientcmd.RecommendedSchemaFile
	
	"""
	return _clientcmd.clientcmd_RecommendedSchemaFile()

def Set_RecommendedSchemaFile(value):
	"""
	Set_RecommendedSchemaFile Sets Go Variable: clientcmd.RecommendedSchemaFile
	
	"""
	if isinstance(value, go.GoClass):
		_clientcmd.clientcmd_Set_RecommendedSchemaFile(value.handle)
	else:
		_clientcmd.clientcmd_Set_RecommendedSchemaFile(value)

def UseModifyConfigLock():
	"""
	UseModifyConfigLock Gets Go Variable: clientcmd.UseModifyConfigLock
	
	"""
	return _clientcmd.clientcmd_UseModifyConfigLock()

def Set_UseModifyConfigLock(value):
	"""
	Set_UseModifyConfigLock Sets Go Variable: clientcmd.UseModifyConfigLock
	
	"""
	if isinstance(value, go.GoClass):
		_clientcmd.clientcmd_Set_UseModifyConfigLock(value.handle)
	else:
		_clientcmd.clientcmd_Set_UseModifyConfigLock(value)



# ---- Interfaces ---

# Python type for interface clientcmd.AuthLoader
class AuthLoader(go.GoClass):
	"""AuthLoaders are used to build clientauth.Info objects.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = 0
	def LoadAuth(self, path):
		"""LoadAuth(str path) object, str"""
		return go.Ptr_auth_Info(handle=_clientcmd.clientcmd_AuthLoader_LoadAuth(self.handle, path))

# Python type for interface clientcmd.ClientConfig
class ClientConfig(go.GoClass):
	"""ClientConfig is used to make it easy to get an api server client\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = 0
	def ClientConfig(self):
		"""ClientConfig() object, str"""
		return go.Ptr_rest_Config(handle=_clientcmd.clientcmd_ClientConfig_ClientConfig(self.handle))
	def ConfigAccess(self):
		"""ConfigAccess() object"""
		return ConfigAccess(handle=_clientcmd.clientcmd_ClientConfig_ConfigAccess(self.handle))
	def RawConfig(self):
		"""RawConfig() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_ClientConfig_RawConfig(self.handle))

# Python type for interface clientcmd.ClientConfigLoader
class ClientConfigLoader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = 0
	def GetDefaultFilename(self):
		"""GetDefaultFilename() str"""
		return _clientcmd.clientcmd_ClientConfigLoader_GetDefaultFilename(self.handle)
	def GetExplicitFile(self):
		"""GetExplicitFile() str"""
		return _clientcmd.clientcmd_ClientConfigLoader_GetExplicitFile(self.handle)
	def GetLoadingPrecedence(self):
		"""GetLoadingPrecedence() []str"""
		return go.Slice_string(handle=_clientcmd.clientcmd_ClientConfigLoader_GetLoadingPrecedence(self.handle))
	def GetStartingConfig(self):
		"""GetStartingConfig() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_ClientConfigLoader_GetStartingConfig(self.handle))
	def IsDefaultConfig(self, arg_0):
		"""IsDefaultConfig(object) bool"""
		return _clientcmd.clientcmd_ClientConfigLoader_IsDefaultConfig(self.handle, arg_0.handle)
	def IsExplicitFile(self):
		"""IsExplicitFile() bool"""
		return _clientcmd.clientcmd_ClientConfigLoader_IsExplicitFile(self.handle)
	def Load(self):
		"""Load() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_ClientConfigLoader_Load(self.handle))

# Python type for interface clientcmd.ConfigAccess
class ConfigAccess(go.GoClass):
	"""ConfigAccess is used by subcommands and methods in this package to load and modify the appropriate config files\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = 0
	def GetDefaultFilename(self):
		"""GetDefaultFilename() str"""
		return _clientcmd.clientcmd_ConfigAccess_GetDefaultFilename(self.handle)
	def GetExplicitFile(self):
		"""GetExplicitFile() str"""
		return _clientcmd.clientcmd_ConfigAccess_GetExplicitFile(self.handle)
	def GetLoadingPrecedence(self):
		"""GetLoadingPrecedence() []str"""
		return go.Slice_string(handle=_clientcmd.clientcmd_ConfigAccess_GetLoadingPrecedence(self.handle))
	def GetStartingConfig(self):
		"""GetStartingConfig() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_ConfigAccess_GetStartingConfig(self.handle))
	def IsExplicitFile(self):
		"""IsExplicitFile() bool"""
		return _clientcmd.clientcmd_ConfigAccess_IsExplicitFile(self.handle)

# Python type for interface clientcmd.InClusterConfig
class InClusterConfig(go.GoClass):
	"""InClusterConfig abstracts details of whether the client is running in a cluster for testing.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = 0
	def ClientConfig(self):
		"""ClientConfig() object, str"""
		return go.Ptr_rest_Config(handle=_clientcmd.clientcmd_InClusterConfig_ClientConfig(self.handle))
	def ConfigAccess(self):
		"""ConfigAccess() object"""
		return ConfigAccess(handle=_clientcmd.clientcmd_InClusterConfig_ConfigAccess(self.handle))
	def Possible(self):
		"""Possible() bool"""
		return _clientcmd.clientcmd_InClusterConfig_Possible(self.handle)
	def RawConfig(self):
		"""RawConfig() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_InClusterConfig_RawConfig(self.handle))

# Python type for interface clientcmd.OverridingClientConfig
class OverridingClientConfig(go.GoClass):
	"""OverridingClientConfig is used to enable overrriding the raw KubeConfig\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = 0
	def ClientConfig(self):
		"""ClientConfig() object, str"""
		return go.Ptr_rest_Config(handle=_clientcmd.clientcmd_OverridingClientConfig_ClientConfig(self.handle))
	def ConfigAccess(self):
		"""ConfigAccess() object"""
		return ConfigAccess(handle=_clientcmd.clientcmd_OverridingClientConfig_ConfigAccess(self.handle))
	def MergedRawConfig(self):
		"""MergedRawConfig() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_OverridingClientConfig_MergedRawConfig(self.handle))
	def RawConfig(self):
		"""RawConfig() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_OverridingClientConfig_RawConfig(self.handle))


# ---- Structs ---

# Python type for struct clientcmd.ConfigOverrides
class ConfigOverrides(go.GoClass):
	"""ConfigOverrides holds values that should override whatever information is pulled from the actual Config object.  You can't\nsimply use an actual Config object, because Configs hold maps, but overrides are restricted to \"at most one\"\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_ConfigOverrides_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.AuthInfo = args[0]
			if "AuthInfo" in kwargs:
				self.AuthInfo = kwargs["AuthInfo"]
			if  1 < len(args):
				self.ClusterDefaults = args[1]
			if "ClusterDefaults" in kwargs:
				self.ClusterDefaults = kwargs["ClusterDefaults"]
			if  2 < len(args):
				self.ClusterInfo = args[2]
			if "ClusterInfo" in kwargs:
				self.ClusterInfo = kwargs["ClusterInfo"]
			if  3 < len(args):
				self.Context = args[3]
			if "Context" in kwargs:
				self.Context = kwargs["Context"]
			if  4 < len(args):
				self.CurrentContext = args[4]
			if "CurrentContext" in kwargs:
				self.CurrentContext = kwargs["CurrentContext"]
			if  5 < len(args):
				self.Timeout = args[5]
			if "Timeout" in kwargs:
				self.Timeout = kwargs["Timeout"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ConfigOverrides{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ConfigOverrides ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def AuthInfo(self):
		return api.AuthInfo(handle=_clientcmd.clientcmd_ConfigOverrides_AuthInfo_Get(self.handle))
	@AuthInfo.setter
	def AuthInfo(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ConfigOverrides_AuthInfo_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ClusterDefaults(self):
		"""ClusterDefaults are applied before the configured cluster info is loaded.
		"""
		return api.Cluster(handle=_clientcmd.clientcmd_ConfigOverrides_ClusterDefaults_Get(self.handle))
	@ClusterDefaults.setter
	def ClusterDefaults(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ConfigOverrides_ClusterDefaults_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ClusterInfo(self):
		return api.Cluster(handle=_clientcmd.clientcmd_ConfigOverrides_ClusterInfo_Get(self.handle))
	@ClusterInfo.setter
	def ClusterInfo(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ConfigOverrides_ClusterInfo_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Context(self):
		return api.Context(handle=_clientcmd.clientcmd_ConfigOverrides_Context_Get(self.handle))
	@Context.setter
	def Context(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ConfigOverrides_Context_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CurrentContext(self):
		return _clientcmd.clientcmd_ConfigOverrides_CurrentContext_Get(self.handle)
	@CurrentContext.setter
	def CurrentContext(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ConfigOverrides_CurrentContext_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_ConfigOverrides_CurrentContext_Set(self.handle, value)
	@property
	def Timeout(self):
		return _clientcmd.clientcmd_ConfigOverrides_Timeout_Get(self.handle)
	@Timeout.setter
	def Timeout(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ConfigOverrides_Timeout_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_ConfigOverrides_Timeout_Set(self.handle, value)

# Python type for struct clientcmd.DeferredLoadingClientConfig
class DeferredLoadingClientConfig(go.GoClass):
	"""DeferredLoadingClientConfig is a ClientConfig interface that is backed by a client config loader.\nIt is used in cases where the loading rules may change after you've instantiated them and you want to be sure that\nthe most recent rules are used.  This is useful in cases where you bind flags to loading rule parameters before\nthe parse happens and you want your calling code to be ignorant of how the values are being mutated to avoid\npassing extraneous information down a call stack\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_DeferredLoadingClientConfig_CTor()
			_clientcmd.IncRef(self.handle)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.DeferredLoadingClientConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.DeferredLoadingClientConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def RawConfig(self):
		"""RawConfig() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_DeferredLoadingClientConfig_RawConfig(self.handle))
	def ClientConfig(self):
		"""ClientConfig() object, str
		
		ClientConfig implements ClientConfig
		"""
		return go.Ptr_rest_Config(handle=_clientcmd.clientcmd_DeferredLoadingClientConfig_ClientConfig(self.handle))
	def ConfigAccess(self):
		"""ConfigAccess() object
		
		ConfigAccess implements ClientConfig
		"""
		return ConfigAccess(handle=_clientcmd.clientcmd_DeferredLoadingClientConfig_ConfigAccess(self.handle))

# Python type for struct clientcmd.MissingConfigError
class MissingConfigError(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_MissingConfigError_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Missing = args[0]
			if "Missing" in kwargs:
				self.Missing = kwargs["Missing"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.MissingConfigError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.MissingConfigError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Missing(self):
		return go.Slice_string(handle=_clientcmd.clientcmd_MissingConfigError_Missing_Get(self.handle))
	@Missing.setter
	def Missing(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_MissingConfigError_Missing_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Error(self):
		"""Error() str"""
		return _clientcmd.clientcmd_MissingConfigError_Error(self.handle)

# Python type for struct clientcmd.ClientConfigGetter
class ClientConfigGetter(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_ClientConfigGetter_CTor()
			_clientcmd.IncRef(self.handle)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ClientConfigGetter{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ClientConfigGetter ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Load(self):
		"""Load() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_ClientConfigGetter_Load(self.handle))
	def GetLoadingPrecedence(self):
		"""GetLoadingPrecedence() []str"""
		return go.Slice_string(handle=_clientcmd.clientcmd_ClientConfigGetter_GetLoadingPrecedence(self.handle))
	def GetStartingConfig(self):
		"""GetStartingConfig() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_ClientConfigGetter_GetStartingConfig(self.handle))
	def GetDefaultFilename(self):
		"""GetDefaultFilename() str"""
		return _clientcmd.clientcmd_ClientConfigGetter_GetDefaultFilename(self.handle)
	def IsExplicitFile(self):
		"""IsExplicitFile() bool"""
		return _clientcmd.clientcmd_ClientConfigGetter_IsExplicitFile(self.handle)
	def GetExplicitFile(self):
		"""GetExplicitFile() str"""
		return _clientcmd.clientcmd_ClientConfigGetter_GetExplicitFile(self.handle)
	def IsDefaultConfig(self, config):
		"""IsDefaultConfig(object config) bool"""
		return _clientcmd.clientcmd_ClientConfigGetter_IsDefaultConfig(self.handle, config.handle)

# Python type for struct clientcmd.ClientConfigLoadingRules
class ClientConfigLoadingRules(go.GoClass):
	"""ClientConfigLoadingRules is an ExplicitPath and string slice of specific locations that are used for merging together a Config\nCallers can put the chain together however they want, but we'd recommend:\nEnvVarPathFiles if set (a list of files if set) OR the HomeDirectoryPath\nExplicitPath is special, because if a user specifically requests a certain file be used and error is reported if this file is not present\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_ClientConfigLoadingRules_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.ExplicitPath = args[0]
			if "ExplicitPath" in kwargs:
				self.ExplicitPath = kwargs["ExplicitPath"]
			if  1 < len(args):
				self.Precedence = args[1]
			if "Precedence" in kwargs:
				self.Precedence = kwargs["Precedence"]
			if  2 < len(args):
				self.MigrationRules = args[2]
			if "MigrationRules" in kwargs:
				self.MigrationRules = kwargs["MigrationRules"]
			if  3 < len(args):
				self.DoNotResolvePaths = args[3]
			if "DoNotResolvePaths" in kwargs:
				self.DoNotResolvePaths = kwargs["DoNotResolvePaths"]
			if  4 < len(args):
				self.DefaultClientConfig = args[4]
			if "DefaultClientConfig" in kwargs:
				self.DefaultClientConfig = kwargs["DefaultClientConfig"]
			if  5 < len(args):
				self.WarnIfAllMissing = args[5]
			if "WarnIfAllMissing" in kwargs:
				self.WarnIfAllMissing = kwargs["WarnIfAllMissing"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ClientConfigLoadingRules{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ClientConfigLoadingRules ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ExplicitPath(self):
		return _clientcmd.clientcmd_ClientConfigLoadingRules_ExplicitPath_Get(self.handle)
	@ExplicitPath.setter
	def ExplicitPath(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClientConfigLoadingRules_ExplicitPath_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_ClientConfigLoadingRules_ExplicitPath_Set(self.handle, value)
	@property
	def Precedence(self):
		return go.Slice_string(handle=_clientcmd.clientcmd_ClientConfigLoadingRules_Precedence_Get(self.handle))
	@Precedence.setter
	def Precedence(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClientConfigLoadingRules_Precedence_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def MigrationRules(self):
		"""MigrationRules is a map of destination files to source files.  If a destination file is not present, then the source file is checked.
		If the source file is present, then it is copied to the destination file BEFORE any further loading happens.
		"""
		return Map_string_string(handle=_clientcmd.clientcmd_ClientConfigLoadingRules_MigrationRules_Get(self.handle))
	@MigrationRules.setter
	def MigrationRules(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClientConfigLoadingRules_MigrationRules_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DoNotResolvePaths(self):
		"""DoNotResolvePaths indicates whether or not to resolve paths with respect to the originating files.  This is phrased as a negative so
		that a default object that doesn't set this will usually get the behavior it wants.
		"""
		return _clientcmd.clientcmd_ClientConfigLoadingRules_DoNotResolvePaths_Get(self.handle)
	@DoNotResolvePaths.setter
	def DoNotResolvePaths(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClientConfigLoadingRules_DoNotResolvePaths_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_ClientConfigLoadingRules_DoNotResolvePaths_Set(self.handle, value)
	@property
	def DefaultClientConfig(self):
		"""DefaultClientConfig is an optional field indicating what rules to use to calculate a default configuration.
		This should match the overrides passed in to ClientConfig loader.
		"""
		return ClientConfig(handle=_clientcmd.clientcmd_ClientConfigLoadingRules_DefaultClientConfig_Get(self.handle))
	@DefaultClientConfig.setter
	def DefaultClientConfig(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClientConfigLoadingRules_DefaultClientConfig_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def WarnIfAllMissing(self):
		"""WarnIfAllMissing indicates whether the configuration files pointed by KUBECONFIG environment variable are present or not.
		In case of missing files, it warns the user about the missing files.
		"""
		return _clientcmd.clientcmd_ClientConfigLoadingRules_WarnIfAllMissing_Get(self.handle)
	@WarnIfAllMissing.setter
	def WarnIfAllMissing(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClientConfigLoadingRules_WarnIfAllMissing_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_ClientConfigLoadingRules_WarnIfAllMissing_Set(self.handle, value)
	def Load(self):
		"""Load() object, str
		
		Load starts by running the MigrationRules and then
		takes the loading rules and returns a Config object based on following rules.
		
			if the ExplicitPath, return the unmerged explicit file
			Otherwise, return a merged config based on the Precedence slice
		
		A missing ExplicitPath file produces an error. Empty filenames or other missing files are ignored.
		Read errors or files with non-deserializable content produce errors.
		The first file to set a particular map key wins and map key's value is never changed.
		BUT, if you set a struct value that is NOT contained inside of map, the value WILL be changed.
		This results in some odd looking logic to merge in one direction, merge in the other, and then merge the two.
		It also means that if two files specify a "red-user", only values from the first file's red-user are used.  Even
		non-conflicting entries from the second file's "red-user" are discarded.
		Relative paths inside of the .kubeconfig files are resolved against the .kubeconfig file's parent folder
		and only absolute file paths are returned.
		"""
		return api.Config(handle=_clientcmd.clientcmd_ClientConfigLoadingRules_Load(self.handle))
	def Migrate(self):
		"""Migrate() str
		
		Migrate uses the MigrationRules map.  If a destination file is not present, then the source file is checked.
		If the source file is present, then it is copied to the destination file BEFORE any further loading happens.
		"""
		return _clientcmd.clientcmd_ClientConfigLoadingRules_Migrate(self.handle)
	def GetLoadingPrecedence(self):
		"""GetLoadingPrecedence() []str
		
		GetLoadingPrecedence implements ConfigAccess
		"""
		return go.Slice_string(handle=_clientcmd.clientcmd_ClientConfigLoadingRules_GetLoadingPrecedence(self.handle))
	def GetStartingConfig(self):
		"""GetStartingConfig() object, str
		
		GetStartingConfig implements ConfigAccess
		"""
		return api.Config(handle=_clientcmd.clientcmd_ClientConfigLoadingRules_GetStartingConfig(self.handle))
	def GetDefaultFilename(self):
		"""GetDefaultFilename() str
		
		GetDefaultFilename implements ConfigAccess
		"""
		return _clientcmd.clientcmd_ClientConfigLoadingRules_GetDefaultFilename(self.handle)
	def IsExplicitFile(self):
		"""IsExplicitFile() bool
		
		IsExplicitFile implements ConfigAccess
		"""
		return _clientcmd.clientcmd_ClientConfigLoadingRules_IsExplicitFile(self.handle)
	def GetExplicitFile(self):
		"""GetExplicitFile() str
		
		GetExplicitFile implements ConfigAccess
		"""
		return _clientcmd.clientcmd_ClientConfigLoadingRules_GetExplicitFile(self.handle)
	def IsDefaultConfig(self, config):
		"""IsDefaultConfig(object config) bool
		
		IsDefaultConfig returns true if the provided configuration matches the default
		"""
		return _clientcmd.clientcmd_ClientConfigLoadingRules_IsDefaultConfig(self.handle, config.handle)
	def ResolvePaths(self):
		"""ResolvePaths() bool"""
		return _clientcmd.clientcmd_ClientConfigLoadingRules_ResolvePaths(self.handle)

# Python type for struct clientcmd.ClusterOverrideFlags
class ClusterOverrideFlags(go.GoClass):
	"""ClusterOverride holds the flag names to be used for binding command line flags for Cluster objects\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_ClusterOverrideFlags_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.APIServer = args[0]
			if "APIServer" in kwargs:
				self.APIServer = kwargs["APIServer"]
			if  1 < len(args):
				self.APIVersion = args[1]
			if "APIVersion" in kwargs:
				self.APIVersion = kwargs["APIVersion"]
			if  2 < len(args):
				self.CertificateAuthority = args[2]
			if "CertificateAuthority" in kwargs:
				self.CertificateAuthority = kwargs["CertificateAuthority"]
			if  3 < len(args):
				self.InsecureSkipTLSVerify = args[3]
			if "InsecureSkipTLSVerify" in kwargs:
				self.InsecureSkipTLSVerify = kwargs["InsecureSkipTLSVerify"]
			if  4 < len(args):
				self.TLSServerName = args[4]
			if "TLSServerName" in kwargs:
				self.TLSServerName = kwargs["TLSServerName"]
			if  5 < len(args):
				self.ProxyURL = args[5]
			if "ProxyURL" in kwargs:
				self.ProxyURL = kwargs["ProxyURL"]
			if  6 < len(args):
				self.DisableCompression = args[6]
			if "DisableCompression" in kwargs:
				self.DisableCompression = kwargs["DisableCompression"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ClusterOverrideFlags{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ClusterOverrideFlags ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def APIServer(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ClusterOverrideFlags_APIServer_Get(self.handle))
	@APIServer.setter
	def APIServer(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClusterOverrideFlags_APIServer_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def APIVersion(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ClusterOverrideFlags_APIVersion_Get(self.handle))
	@APIVersion.setter
	def APIVersion(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClusterOverrideFlags_APIVersion_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CertificateAuthority(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ClusterOverrideFlags_CertificateAuthority_Get(self.handle))
	@CertificateAuthority.setter
	def CertificateAuthority(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClusterOverrideFlags_CertificateAuthority_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def InsecureSkipTLSVerify(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ClusterOverrideFlags_InsecureSkipTLSVerify_Get(self.handle))
	@InsecureSkipTLSVerify.setter
	def InsecureSkipTLSVerify(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClusterOverrideFlags_InsecureSkipTLSVerify_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def TLSServerName(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ClusterOverrideFlags_TLSServerName_Get(self.handle))
	@TLSServerName.setter
	def TLSServerName(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClusterOverrideFlags_TLSServerName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ProxyURL(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ClusterOverrideFlags_ProxyURL_Get(self.handle))
	@ProxyURL.setter
	def ProxyURL(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClusterOverrideFlags_ProxyURL_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def DisableCompression(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ClusterOverrideFlags_DisableCompression_Get(self.handle))
	@DisableCompression.setter
	def DisableCompression(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ClusterOverrideFlags_DisableCompression_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct clientcmd.ConfigOverrideFlags
class ConfigOverrideFlags(go.GoClass):
	"""ConfigOverrideFlags holds the flag names to be used for binding command line flags. Notice that this structure tightly\ncorresponds to ConfigOverrides\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_ConfigOverrideFlags_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.AuthOverrideFlags = args[0]
			if "AuthOverrideFlags" in kwargs:
				self.AuthOverrideFlags = kwargs["AuthOverrideFlags"]
			if  1 < len(args):
				self.ClusterOverrideFlags = args[1]
			if "ClusterOverrideFlags" in kwargs:
				self.ClusterOverrideFlags = kwargs["ClusterOverrideFlags"]
			if  2 < len(args):
				self.ContextOverrideFlags = args[2]
			if "ContextOverrideFlags" in kwargs:
				self.ContextOverrideFlags = kwargs["ContextOverrideFlags"]
			if  3 < len(args):
				self.CurrentContext = args[3]
			if "CurrentContext" in kwargs:
				self.CurrentContext = kwargs["CurrentContext"]
			if  4 < len(args):
				self.Timeout = args[4]
			if "Timeout" in kwargs:
				self.Timeout = kwargs["Timeout"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ConfigOverrideFlags{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ConfigOverrideFlags ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def AuthOverrideFlags(self):
		return AuthOverrideFlags(handle=_clientcmd.clientcmd_ConfigOverrideFlags_AuthOverrideFlags_Get(self.handle))
	@AuthOverrideFlags.setter
	def AuthOverrideFlags(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ConfigOverrideFlags_AuthOverrideFlags_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ClusterOverrideFlags(self):
		return ClusterOverrideFlags(handle=_clientcmd.clientcmd_ConfigOverrideFlags_ClusterOverrideFlags_Get(self.handle))
	@ClusterOverrideFlags.setter
	def ClusterOverrideFlags(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ConfigOverrideFlags_ClusterOverrideFlags_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ContextOverrideFlags(self):
		return ContextOverrideFlags(handle=_clientcmd.clientcmd_ConfigOverrideFlags_ContextOverrideFlags_Get(self.handle))
	@ContextOverrideFlags.setter
	def ContextOverrideFlags(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ConfigOverrideFlags_ContextOverrideFlags_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CurrentContext(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ConfigOverrideFlags_CurrentContext_Get(self.handle))
	@CurrentContext.setter
	def CurrentContext(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ConfigOverrideFlags_CurrentContext_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Timeout(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ConfigOverrideFlags_Timeout_Get(self.handle))
	@Timeout.setter
	def Timeout(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ConfigOverrideFlags_Timeout_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct clientcmd.PathOptions
class PathOptions(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_PathOptions_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.GlobalFile = args[0]
			if "GlobalFile" in kwargs:
				self.GlobalFile = kwargs["GlobalFile"]
			if  1 < len(args):
				self.EnvVar = args[1]
			if "EnvVar" in kwargs:
				self.EnvVar = kwargs["EnvVar"]
			if  2 < len(args):
				self.ExplicitFileFlag = args[2]
			if "ExplicitFileFlag" in kwargs:
				self.ExplicitFileFlag = kwargs["ExplicitFileFlag"]
			if  3 < len(args):
				self.GlobalFileSubpath = args[3]
			if "GlobalFileSubpath" in kwargs:
				self.GlobalFileSubpath = kwargs["GlobalFileSubpath"]
			if  4 < len(args):
				self.LoadingRules = args[4]
			if "LoadingRules" in kwargs:
				self.LoadingRules = kwargs["LoadingRules"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.PathOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.PathOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def GlobalFile(self):
		"""GlobalFile is the full path to the file to load as the global (final) option
		"""
		return _clientcmd.clientcmd_PathOptions_GlobalFile_Get(self.handle)
	@GlobalFile.setter
	def GlobalFile(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_PathOptions_GlobalFile_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_PathOptions_GlobalFile_Set(self.handle, value)
	@property
	def EnvVar(self):
		"""EnvVar is the env var name that points to the list of kubeconfig files to load
		"""
		return _clientcmd.clientcmd_PathOptions_EnvVar_Get(self.handle)
	@EnvVar.setter
	def EnvVar(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_PathOptions_EnvVar_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_PathOptions_EnvVar_Set(self.handle, value)
	@property
	def ExplicitFileFlag(self):
		"""ExplicitFileFlag is the name of the flag to use for prompting for the kubeconfig file
		"""
		return _clientcmd.clientcmd_PathOptions_ExplicitFileFlag_Get(self.handle)
	@ExplicitFileFlag.setter
	def ExplicitFileFlag(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_PathOptions_ExplicitFileFlag_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_PathOptions_ExplicitFileFlag_Set(self.handle, value)
	@property
	def GlobalFileSubpath(self):
		"""GlobalFileSubpath is an optional value used for displaying help
		"""
		return _clientcmd.clientcmd_PathOptions_GlobalFileSubpath_Get(self.handle)
	@GlobalFileSubpath.setter
	def GlobalFileSubpath(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_PathOptions_GlobalFileSubpath_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_PathOptions_GlobalFileSubpath_Set(self.handle, value)
	@property
	def LoadingRules(self):
		return ClientConfigLoadingRules(handle=_clientcmd.clientcmd_PathOptions_LoadingRules_Get(self.handle))
	@LoadingRules.setter
	def LoadingRules(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_PathOptions_LoadingRules_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def GetEnvVarFiles(self):
		"""GetEnvVarFiles() []str"""
		return go.Slice_string(handle=_clientcmd.clientcmd_PathOptions_GetEnvVarFiles(self.handle))
	def GetLoadingPrecedence(self):
		"""GetLoadingPrecedence() []str"""
		return go.Slice_string(handle=_clientcmd.clientcmd_PathOptions_GetLoadingPrecedence(self.handle))
	def GetStartingConfig(self):
		"""GetStartingConfig() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_PathOptions_GetStartingConfig(self.handle))
	def GetDefaultFilename(self):
		"""GetDefaultFilename() str"""
		return _clientcmd.clientcmd_PathOptions_GetDefaultFilename(self.handle)
	def IsExplicitFile(self):
		"""IsExplicitFile() bool"""
		return _clientcmd.clientcmd_PathOptions_IsExplicitFile(self.handle)
	def GetExplicitFile(self):
		"""GetExplicitFile() str"""
		return _clientcmd.clientcmd_PathOptions_GetExplicitFile(self.handle)

# Python type for struct clientcmd.PromptingAuthLoader
class PromptingAuthLoader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_PromptingAuthLoader_CTor()
			_clientcmd.IncRef(self.handle)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.PromptingAuthLoader{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.PromptingAuthLoader ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def LoadAuth(self, path):
		"""LoadAuth(str path) object, str
		
		LoadAuth parses an AuthInfo object from a file path. It prompts user and creates file if it doesn't exist.
		"""
		return go.Ptr_auth_Info(handle=_clientcmd.clientcmd_PromptingAuthLoader_LoadAuth(self.handle, path))
	def Prompt(self):
		"""Prompt() object, str
		
		Prompt pulls the user and password from a reader
		"""
		return go.Ptr_auth_Info(handle=_clientcmd.clientcmd_PromptingAuthLoader_Prompt(self.handle))

# Python type for struct clientcmd.AuthOverrideFlags
class AuthOverrideFlags(go.GoClass):
	"""AuthOverrideFlags holds the flag names to be used for binding command line flags for AuthInfo objects\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_AuthOverrideFlags_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.ClientCertificate = args[0]
			if "ClientCertificate" in kwargs:
				self.ClientCertificate = kwargs["ClientCertificate"]
			if  1 < len(args):
				self.ClientKey = args[1]
			if "ClientKey" in kwargs:
				self.ClientKey = kwargs["ClientKey"]
			if  2 < len(args):
				self.Token = args[2]
			if "Token" in kwargs:
				self.Token = kwargs["Token"]
			if  3 < len(args):
				self.Impersonate = args[3]
			if "Impersonate" in kwargs:
				self.Impersonate = kwargs["Impersonate"]
			if  4 < len(args):
				self.ImpersonateUID = args[4]
			if "ImpersonateUID" in kwargs:
				self.ImpersonateUID = kwargs["ImpersonateUID"]
			if  5 < len(args):
				self.ImpersonateGroups = args[5]
			if "ImpersonateGroups" in kwargs:
				self.ImpersonateGroups = kwargs["ImpersonateGroups"]
			if  6 < len(args):
				self.Username = args[6]
			if "Username" in kwargs:
				self.Username = kwargs["Username"]
			if  7 < len(args):
				self.Password = args[7]
			if "Password" in kwargs:
				self.Password = kwargs["Password"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.AuthOverrideFlags{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.AuthOverrideFlags ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ClientCertificate(self):
		return FlagInfo(handle=_clientcmd.clientcmd_AuthOverrideFlags_ClientCertificate_Get(self.handle))
	@ClientCertificate.setter
	def ClientCertificate(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_AuthOverrideFlags_ClientCertificate_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ClientKey(self):
		return FlagInfo(handle=_clientcmd.clientcmd_AuthOverrideFlags_ClientKey_Get(self.handle))
	@ClientKey.setter
	def ClientKey(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_AuthOverrideFlags_ClientKey_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Token(self):
		return FlagInfo(handle=_clientcmd.clientcmd_AuthOverrideFlags_Token_Get(self.handle))
	@Token.setter
	def Token(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_AuthOverrideFlags_Token_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Impersonate(self):
		return FlagInfo(handle=_clientcmd.clientcmd_AuthOverrideFlags_Impersonate_Get(self.handle))
	@Impersonate.setter
	def Impersonate(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_AuthOverrideFlags_Impersonate_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ImpersonateUID(self):
		return FlagInfo(handle=_clientcmd.clientcmd_AuthOverrideFlags_ImpersonateUID_Get(self.handle))
	@ImpersonateUID.setter
	def ImpersonateUID(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_AuthOverrideFlags_ImpersonateUID_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ImpersonateGroups(self):
		return FlagInfo(handle=_clientcmd.clientcmd_AuthOverrideFlags_ImpersonateGroups_Get(self.handle))
	@ImpersonateGroups.setter
	def ImpersonateGroups(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_AuthOverrideFlags_ImpersonateGroups_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Username(self):
		return FlagInfo(handle=_clientcmd.clientcmd_AuthOverrideFlags_Username_Get(self.handle))
	@Username.setter
	def Username(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_AuthOverrideFlags_Username_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Password(self):
		return FlagInfo(handle=_clientcmd.clientcmd_AuthOverrideFlags_Password_Get(self.handle))
	@Password.setter
	def Password(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_AuthOverrideFlags_Password_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct clientcmd.ContextOverrideFlags
class ContextOverrideFlags(go.GoClass):
	"""ContextOverrideFlags holds the flag names to be used for binding command line flags for Cluster objects\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_ContextOverrideFlags_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.ClusterName = args[0]
			if "ClusterName" in kwargs:
				self.ClusterName = kwargs["ClusterName"]
			if  1 < len(args):
				self.AuthInfoName = args[1]
			if "AuthInfoName" in kwargs:
				self.AuthInfoName = kwargs["AuthInfoName"]
			if  2 < len(args):
				self.Namespace = args[2]
			if "Namespace" in kwargs:
				self.Namespace = kwargs["Namespace"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ContextOverrideFlags{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.ContextOverrideFlags ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ClusterName(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ContextOverrideFlags_ClusterName_Get(self.handle))
	@ClusterName.setter
	def ClusterName(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ContextOverrideFlags_ClusterName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AuthInfoName(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ContextOverrideFlags_AuthInfoName_Get(self.handle))
	@AuthInfoName.setter
	def AuthInfoName(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ContextOverrideFlags_AuthInfoName_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Namespace(self):
		return FlagInfo(handle=_clientcmd.clientcmd_ContextOverrideFlags_Namespace_Get(self.handle))
	@Namespace.setter
	def Namespace(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_ContextOverrideFlags_Namespace_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct clientcmd.DirectClientConfig
class DirectClientConfig(go.GoClass):
	"""DirectClientConfig is a ClientConfig interface that is backed by a clientcmdapi.Config, options overrides, and an optional fallbackReader for auth information\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_DirectClientConfig_CTor()
			_clientcmd.IncRef(self.handle)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.DirectClientConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.DirectClientConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def RawConfig(self):
		"""RawConfig() object, str"""
		return api.Config(handle=_clientcmd.clientcmd_DirectClientConfig_RawConfig(self.handle))
	def MergedRawConfig(self):
		"""MergedRawConfig() object, str
		
		MergedRawConfig returns the raw kube config merged with the overrides
		"""
		return api.Config(handle=_clientcmd.clientcmd_DirectClientConfig_MergedRawConfig(self.handle))
	def ClientConfig(self):
		"""ClientConfig() object, str
		
		ClientConfig implements ClientConfig
		"""
		return go.Ptr_rest_Config(handle=_clientcmd.clientcmd_DirectClientConfig_ClientConfig(self.handle))
	def ConfigAccess(self):
		"""ConfigAccess() object
		
		ConfigAccess implements ClientConfig
		"""
		return ConfigAccess(handle=_clientcmd.clientcmd_DirectClientConfig_ConfigAccess(self.handle))
	def ConfirmUsable(self):
		"""ConfirmUsable() str
		
		ConfirmUsable looks a particular context and determines if that particular part of the config is useable.  There might still be errors in the config,
		but no errors in the sections requested or referenced.  It does not return early so that it can find as many errors as possible.
		"""
		return _clientcmd.clientcmd_DirectClientConfig_ConfirmUsable(self.handle)

# Python type for struct clientcmd.FlagInfo
class FlagInfo(go.GoClass):
	"""FlagInfo contains information about how to register a flag.  This struct is useful if you want to provide a way for an extender to\nget back a set of recommended flag names, descriptions, and defaults, but allow for customization by an extender.  This makes for\ncoherent extension, without full prescription\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.clientcmd_FlagInfo_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.LongName = args[0]
			if "LongName" in kwargs:
				self.LongName = kwargs["LongName"]
			if  1 < len(args):
				self.ShortName = args[1]
			if "ShortName" in kwargs:
				self.ShortName = kwargs["ShortName"]
			if  2 < len(args):
				self.Default = args[2]
			if "Default" in kwargs:
				self.Default = kwargs["Default"]
			if  3 < len(args):
				self.Description = args[3]
			if "Description" in kwargs:
				self.Description = kwargs["Description"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.FlagInfo{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'clientcmd.FlagInfo ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def LongName(self):
		"""LongName is the long string for a flag.  If this is empty, then the flag will not be bound
		"""
		return _clientcmd.clientcmd_FlagInfo_LongName_Get(self.handle)
	@LongName.setter
	def LongName(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_FlagInfo_LongName_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_FlagInfo_LongName_Set(self.handle, value)
	@property
	def ShortName(self):
		"""ShortName is the single character for a flag.  If this is empty, then there will be no short flag
		"""
		return _clientcmd.clientcmd_FlagInfo_ShortName_Get(self.handle)
	@ShortName.setter
	def ShortName(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_FlagInfo_ShortName_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_FlagInfo_ShortName_Set(self.handle, value)
	@property
	def Default(self):
		"""Default is the default value for the flag
		"""
		return _clientcmd.clientcmd_FlagInfo_Default_Get(self.handle)
	@Default.setter
	def Default(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_FlagInfo_Default_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_FlagInfo_Default_Set(self.handle, value)
	@property
	def Description(self):
		"""Description is the description for the flag
		"""
		return _clientcmd.clientcmd_FlagInfo_Description_Get(self.handle)
	@Description.setter
	def Description(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.clientcmd_FlagInfo_Description_Set(self.handle, value.handle)
		else:
			_clientcmd.clientcmd_FlagInfo_Description_Set(self.handle, value)
	def AddSecretAnnotation(self, flags):
		"""AddSecretAnnotation(object flags) object
		
		AddSecretAnnotation add secret flag to Annotation.
		"""
		return FlagInfo(handle=_clientcmd.clientcmd_FlagInfo_AddSecretAnnotation(self.handle, flags.handle))
	def BindStringArrayFlag(self, flags, target):
		"""BindStringArrayFlag(object flags, object target) object
		
		BindStringSliceFlag binds the flag based on the provided info.  If LongName == "", nothing is registered
		"""
		return FlagInfo(handle=_clientcmd.clientcmd_FlagInfo_BindStringArrayFlag(self.handle, flags.handle, target.handle))


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewDefaultClientConfigLoadingRules():
	"""NewDefaultClientConfigLoadingRules() object
	
	NewDefaultClientConfigLoadingRules returns a ClientConfigLoadingRules object with default fields filled in.  You are not required to
	use this constructor
	"""
	return ClientConfigLoadingRules(handle=_clientcmd.clientcmd_NewDefaultClientConfigLoadingRules())
def RecommendedClusterOverrideFlags(prefix):
	"""RecommendedClusterOverrideFlags(str prefix) object
	
	RecommendedClusterOverrideFlags is a convenience method to return recommended flag names prefixed with a string of your choosing
	"""
	return ClusterOverrideFlags(handle=_clientcmd.clientcmd_RecommendedClusterOverrideFlags(prefix))
def RecommendedConfigOverrideFlags(prefix):
	"""RecommendedConfigOverrideFlags(str prefix) object
	
	RecommendedConfigOverrideFlags is a convenience method to return recommended flag names prefixed with a string of your choosing
	"""
	return ConfigOverrideFlags(handle=_clientcmd.clientcmd_RecommendedConfigOverrideFlags(prefix))
def NewDefaultPathOptions():
	"""NewDefaultPathOptions() object"""
	return PathOptions(handle=_clientcmd.clientcmd_NewDefaultPathOptions())
def NewPromptingAuthLoader(reader):
	"""NewPromptingAuthLoader(object reader) object
	
	NewPromptingAuthLoader is an AuthLoader that parses an AuthInfo object from a file path. It prompts user and creates file if it doesn't exist.
	"""
	return PromptingAuthLoader(handle=_clientcmd.clientcmd_NewPromptingAuthLoader(reader.handle))
def RecommendedAuthOverrideFlags(prefix):
	"""RecommendedAuthOverrideFlags(str prefix) object
	
	RecommendedAuthOverrideFlags is a convenience method to return recommended flag names prefixed with a string of your choosing
	"""
	return AuthOverrideFlags(handle=_clientcmd.clientcmd_RecommendedAuthOverrideFlags(prefix))
def RecommendedContextOverrideFlags(prefix):
	"""RecommendedContextOverrideFlags(str prefix) object
	
	RecommendedContextOverrideFlags is a convenience method to return recommended flag names prefixed with a string of your choosing
	"""
	return ContextOverrideFlags(handle=_clientcmd.clientcmd_RecommendedContextOverrideFlags(prefix))


# ---- Functions ---
def BindAuthInfoFlags(authInfo, flags, flagNames, goRun=False):
	"""BindAuthInfoFlags(object authInfo, object flags, object flagNames) 
	
	BindAuthInfoFlags is a convenience method to bind the specified flags to their associated variables
	"""
	_clientcmd.clientcmd_BindAuthInfoFlags(authInfo.handle, flags.handle, flagNames.handle, goRun)
def BindClusterFlags(clusterInfo, flags, flagNames, goRun=False):
	"""BindClusterFlags(object clusterInfo, object flags, object flagNames) 
	
	BindClusterFlags is a convenience method to bind the specified flags to their associated variables
	"""
	_clientcmd.clientcmd_BindClusterFlags(clusterInfo.handle, flags.handle, flagNames.handle, goRun)
def ConfirmUsable(config, passedContextName):
	"""ConfirmUsable(object config, str passedContextName) str
	
	ConfirmUsable looks a particular context and determines if that particular part of the config is useable.  There might still be errors in the config,
	but no errors in the sections requested or referenced.  It does not return early so that it can find as many errors as possible.
	"""
	return _clientcmd.clientcmd_ConfirmUsable(config.handle, passedContextName)
def RelativizePathWithNoBacksteps(refs, base):
	"""RelativizePathWithNoBacksteps([]object refs, str base) str
	
	RelativizePathWithNoBacksteps updates the given refs to be relative paths, relative to the given base directory as long as they do not require backsteps.
	Any path requiring a backstep is left as-is as long it is absolute.  Any non-absolute path that can't be relativized produces an error
	"""
	return _clientcmd.clientcmd_RelativizePathWithNoBacksteps(refs.handle, base)
def NewDefaultAuthLoader():
	"""NewDefaultAuthLoader() object
	
	NewDefaultAuthLoader returns a default implementation of an AuthLoader that only reads from a config file
	"""
	return AuthLoader(handle=_clientcmd.clientcmd_NewDefaultAuthLoader())
def IsConfigurationInvalid(err):
	"""IsConfigurationInvalid(str err) bool
	
	IsConfigurationInvalid returns true if the provided error indicates the configuration is invalid.
	"""
	return _clientcmd.clientcmd_IsConfigurationInvalid(err)
def IsContextNotFound(err):
	"""IsContextNotFound(str err) bool
	
	IsContextNotFound returns a boolean indicating whether the error is known to
	report that a context was not found
	"""
	return _clientcmd.clientcmd_IsContextNotFound(err)
def IsEmptyConfig(err):
	"""IsEmptyConfig(str err) bool
	
	IsEmptyConfig returns true if the provided error indicates the provided configuration
	is empty.
	"""
	return _clientcmd.clientcmd_IsEmptyConfig(err)
def Load(data):
	"""Load([]int data) object, str
	
	Load takes a byte slice and deserializes the contents into Config object.
	Encapsulates deserialization without assuming the source is a file.
	"""
	return api.Config(handle=_clientcmd.clientcmd_Load(data.handle))
def RelativizeConfigPaths(config, base):
	"""RelativizeConfigPaths(object config, str base) str"""
	return _clientcmd.clientcmd_RelativizeConfigPaths(config.handle, base)
def ResolveConfigPaths(config, base):
	"""ResolveConfigPaths(object config, str base) str"""
	return _clientcmd.clientcmd_ResolveConfigPaths(config.handle, base)
def ResolvePaths(refs, base):
	"""ResolvePaths([]object refs, str base) str
	
	ResolvePaths updates the given refs to be absolute paths, relative to the given base directory
	"""
	return _clientcmd.clientcmd_ResolvePaths(refs.handle, base)
def GetConfigFileReferences(config):
	"""GetConfigFileReferences(object config) []object"""
	return Slice_Ptr_string(handle=_clientcmd.clientcmd_GetConfigFileReferences(config.handle))
def GetConfigFromFileOrDie(filename):
	"""GetConfigFromFileOrDie(str filename) object
	
	GetConfigFromFileOrDie tries to read a kubeconfig file and if it can't, it calls exit.  One exception, missing files result in empty configs, not an exit
	"""
	return api.Config(handle=_clientcmd.clientcmd_GetConfigFromFileOrDie(filename))
def MakeRelative(path, base):
	"""MakeRelative(str path, str base) str, str"""
	return _clientcmd.clientcmd_MakeRelative(path, base)
def NewNonInteractiveDeferredLoadingClientConfig(loader, overrides):
	"""NewNonInteractiveDeferredLoadingClientConfig(object loader, object overrides) object
	
	NewNonInteractiveDeferredLoadingClientConfig creates a ClientConfig using the passed context name
	"""
	return ClientConfig(handle=_clientcmd.clientcmd_NewNonInteractiveDeferredLoadingClientConfig(loader.handle, overrides.handle))
def Validate(config):
	"""Validate(object config) str
	
	Validate checks for errors in the Config.  It does not return early so that it can find as many errors as possible.
	"""
	return _clientcmd.clientcmd_Validate(config.handle)
def PersisterForUser(configAccess, user):
	"""PersisterForUser(object configAccess, str user) object"""
	return go.rest_AuthProviderConfigPersister(handle=_clientcmd.clientcmd_PersisterForUser(configAccess.handle, user))
def ResolveLocalPaths(config):
	"""ResolveLocalPaths(object config) str
	
	ResolveLocalPaths resolves all relative paths in the config object with respect to the stanza's LocationOfOrigin
	this cannot be done directly inside of LoadFromFile because doing so there would make it impossible to load a file without
	modification of its contents.
	"""
	return _clientcmd.clientcmd_ResolveLocalPaths(config.handle)
def Write(config):
	"""Write(object config) []int, str
	
	Write serializes the config to yaml.
	Encapsulates serialization without assuming the destination is a file.
	"""
	return go.Slice_byte(handle=_clientcmd.clientcmd_Write(config.handle))
def NewDefaultClientConfig(config, overrides):
	"""NewDefaultClientConfig(object config, object overrides) object
	
	NewDefaultClientConfig creates a DirectClientConfig using the config.CurrentContext as the context name
	"""
	return OverridingClientConfig(handle=_clientcmd.clientcmd_NewDefaultClientConfig(config.handle, overrides.handle))
def NewInteractiveClientConfig(config, contextName, overrides, fallbackReader, configAccess):
	"""NewInteractiveClientConfig(object config, str contextName, object overrides, object fallbackReader, object configAccess) object
	
	NewInteractiveClientConfig creates a DirectClientConfig using the passed context name and a reader in case auth information is not provided via files or flags
	"""
	return OverridingClientConfig(handle=_clientcmd.clientcmd_NewInteractiveClientConfig(config.handle, contextName, overrides.handle, fallbackReader.handle, configAccess.handle))
def NewEmptyConfigError(message):
	"""NewEmptyConfigError(str message) str
	
	NewEmptyConfigError returns an error wrapping the given message which IsEmptyConfig() will recognize as an empty config error
	"""
	return _clientcmd.clientcmd_NewEmptyConfigError(message)
def NewInteractiveDeferredLoadingClientConfig(loader, overrides, fallbackReader):
	"""NewInteractiveDeferredLoadingClientConfig(object loader, object overrides, object fallbackReader) object
	
	NewInteractiveDeferredLoadingClientConfig creates a ClientConfig using the passed context name and the fallback auth reader
	"""
	return ClientConfig(handle=_clientcmd.clientcmd_NewInteractiveDeferredLoadingClientConfig(loader.handle, overrides.handle, fallbackReader.handle))
def NewNonInteractiveClientConfig(config, contextName, overrides, configAccess):
	"""NewNonInteractiveClientConfig(object config, str contextName, object overrides, object configAccess) object
	
	NewNonInteractiveClientConfig creates a DirectClientConfig using the passed context name and does not have a fallback reader for auth information
	"""
	return OverridingClientConfig(handle=_clientcmd.clientcmd_NewNonInteractiveClientConfig(config.handle, contextName, overrides.handle, configAccess.handle))
def BindContextFlags(contextInfo, flags, flagNames, goRun=False):
	"""BindContextFlags(object contextInfo, object flags, object flagNames) 
	
	BindFlags is a convenience method to bind the specified flags to their associated variables
	"""
	_clientcmd.clientcmd_BindContextFlags(contextInfo.handle, flags.handle, flagNames.handle, goRun)
def GetClusterFileReferences(cluster):
	"""GetClusterFileReferences(object cluster) []object"""
	return Slice_Ptr_string(handle=_clientcmd.clientcmd_GetClusterFileReferences(cluster.handle))
def LoadFromFile(filename):
	"""LoadFromFile(str filename) object, str
	
	LoadFromFile takes a filename and deserializes the contents into Config object
	"""
	return api.Config(handle=_clientcmd.clientcmd_LoadFromFile(filename))
def NewClientConfigFromBytes(configBytes):
	"""NewClientConfigFromBytes([]int configBytes) object, str"""
	return OverridingClientConfig(handle=_clientcmd.clientcmd_NewClientConfigFromBytes(configBytes.handle))
def RESTConfigFromKubeConfig(configBytes):
	"""RESTConfigFromKubeConfig([]int configBytes) object, str
	
	RESTConfigFromKubeConfig is a convenience method to give back a restconfig from your kubeconfig bytes.
	For programmatic access, this is what you want 80% of the time
	"""
	return go.Ptr_rest_Config(handle=_clientcmd.clientcmd_RESTConfigFromKubeConfig(configBytes.handle))
def RelativizeAuthInfoLocalPaths(authInfo):
	"""RelativizeAuthInfoLocalPaths(object authInfo) str
	
	RelativizeAuthInfoLocalPaths first absolutizes the paths by calling ResolveLocalPaths.  This assumes that any NEW path is already
	absolute, but any existing path will be resolved relative to LocationOfOrigin
	"""
	return _clientcmd.clientcmd_RelativizeAuthInfoLocalPaths(authInfo.handle)
def RemoveNamespacesPrefix(value):
	"""RemoveNamespacesPrefix(str value) str, str
	
	RemoveNamespacesPrefix is a transformer that strips "ns/", "namespace/" and "namespaces/" prefixes case-insensitively
	"""
	return _clientcmd.clientcmd_RemoveNamespacesPrefix(value)
def WriteToFile(config, filename):
	"""WriteToFile(object config, str filename) str
	
	WriteToFile serializes the config to yaml and writes it out to a file.  If not present, it creates the file with the mode 0600.  If it is present
	it stomps the contents
	"""
	return _clientcmd.clientcmd_WriteToFile(config.handle, filename)
def BindOverrideFlags(overrides, flags, flagNames, goRun=False):
	"""BindOverrideFlags(object overrides, object flags, object flagNames) 
	
	BindOverrideFlags is a convenience method to bind the specified flags to their associated variables
	"""
	_clientcmd.clientcmd_BindOverrideFlags(overrides.handle, flags.handle, flagNames.handle, goRun)
def ParseTimeout(duration):
	"""ParseTimeout(str duration) long, str
	
	ParseTimeout returns a parsed duration from a string
	A duration string value must be a positive integer, optionally followed by a corresponding time unit (s|m|h).
	"""
	return _clientcmd.clientcmd_ParseTimeout(duration)
def RelativizeClusterLocalPaths(cluster):
	"""RelativizeClusterLocalPaths(object cluster) str
	
	RelativizeClusterLocalPaths first absolutizes the paths by calling ResolveLocalPaths.  This assumes that any NEW path is already
	absolute, but any existing path will be resolved relative to LocationOfOrigin
	"""
	return _clientcmd.clientcmd_RelativizeClusterLocalPaths(cluster.handle)
def BuildConfigFromFlags(masterUrl, kubeconfigPath):
	"""BuildConfigFromFlags(str masterUrl, str kubeconfigPath) object, str
	
	BuildConfigFromFlags is a helper function that builds configs from a master
	url or a kubeconfig filepath. These are passed in as command line flags for cluster
	components. Warnings should reflect this usage. If neither masterUrl or kubeconfigPath
	are passed in we fallback to inClusterConfig. If inClusterConfig fails, we fallback
	to the default config.
	"""
	return go.Ptr_rest_Config(handle=_clientcmd.clientcmd_BuildConfigFromFlags(masterUrl, kubeconfigPath))
def GetAuthInfoFileReferences(authInfo):
	"""GetAuthInfoFileReferences(object authInfo) []object"""
	return Slice_Ptr_string(handle=_clientcmd.clientcmd_GetAuthInfoFileReferences(authInfo.handle))
def ModifyConfig(configAccess, newConfig, relativizePaths):
	"""ModifyConfig(object configAccess, object newConfig, bool relativizePaths) str
	
	ModifyConfig takes a Config object, iterates through Clusters, AuthInfos, and Contexts, uses the LocationOfOrigin if specified or
	uses the default destination file to write the results into.  This results in multiple file reads, but it's very easy to follow.
	Preferences and CurrentContext should always be set in the default destination file.  Since we can't distinguish between empty and missing values
	(no nil strings), we're forced have separate handling for them.  In the kubeconfig cases, newConfig should have at most one difference,
	that means that this code will only write into a single file.  If you want to relativizePaths, you must provide a fully qualified path in any
	modified element.
	"""
	return _clientcmd.clientcmd_ModifyConfig(configAccess.handle, newConfig.handle, relativizePaths)


