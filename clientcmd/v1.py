
# python wrapper for package k8s.io/client-go/tools/clientcmd/api/v1 within overall package clientcmd
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg k8s.io/client-go/tools/clientcmd

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _clientcmd
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from clientcmd import v1
# and then refer to everything using v1. prefix
# packages imported by this package listed below:

from . import api
from . import clientcmd



# ---- Types ---

# Python type for slice []v1.ExecEnvVar
class Slice_v1_ExecEnvVar(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Slice_v1_ExecEnvVar_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_v1_ExecEnvVar.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'v1.Slice_v1_ExecEnvVar len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'v1.Slice_v1_ExecEnvVar([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _clientcmd.Slice_v1_ExecEnvVar_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _clientcmd.Slice_v1_ExecEnvVar_len(self.handle)
				return Slice_v1_ExecEnvVar(handle=_clientcmd.Slice_v1_ExecEnvVar_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return ExecEnvVar(handle=_clientcmd.Slice_v1_ExecEnvVar_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_clientcmd.Slice_v1_ExecEnvVar_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_v1_ExecEnvVar.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = ExecEnvVar(handle=_clientcmd.Slice_v1_ExecEnvVar_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_clientcmd.Slice_v1_ExecEnvVar_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []v1.NamedAuthInfo
class Slice_v1_NamedAuthInfo(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Slice_v1_NamedAuthInfo_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_v1_NamedAuthInfo.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'v1.Slice_v1_NamedAuthInfo len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'v1.Slice_v1_NamedAuthInfo([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _clientcmd.Slice_v1_NamedAuthInfo_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _clientcmd.Slice_v1_NamedAuthInfo_len(self.handle)
				return Slice_v1_NamedAuthInfo(handle=_clientcmd.Slice_v1_NamedAuthInfo_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return NamedAuthInfo(handle=_clientcmd.Slice_v1_NamedAuthInfo_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_clientcmd.Slice_v1_NamedAuthInfo_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_v1_NamedAuthInfo.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = NamedAuthInfo(handle=_clientcmd.Slice_v1_NamedAuthInfo_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_clientcmd.Slice_v1_NamedAuthInfo_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []v1.NamedCluster
class Slice_v1_NamedCluster(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Slice_v1_NamedCluster_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_v1_NamedCluster.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'v1.Slice_v1_NamedCluster len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'v1.Slice_v1_NamedCluster([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _clientcmd.Slice_v1_NamedCluster_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _clientcmd.Slice_v1_NamedCluster_len(self.handle)
				return Slice_v1_NamedCluster(handle=_clientcmd.Slice_v1_NamedCluster_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return NamedCluster(handle=_clientcmd.Slice_v1_NamedCluster_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_clientcmd.Slice_v1_NamedCluster_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_v1_NamedCluster.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = NamedCluster(handle=_clientcmd.Slice_v1_NamedCluster_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_clientcmd.Slice_v1_NamedCluster_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []v1.NamedContext
class Slice_v1_NamedContext(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Slice_v1_NamedContext_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_v1_NamedContext.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'v1.Slice_v1_NamedContext len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'v1.Slice_v1_NamedContext([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _clientcmd.Slice_v1_NamedContext_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _clientcmd.Slice_v1_NamedContext_len(self.handle)
				return Slice_v1_NamedContext(handle=_clientcmd.Slice_v1_NamedContext_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return NamedContext(handle=_clientcmd.Slice_v1_NamedContext_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_clientcmd.Slice_v1_NamedContext_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_v1_NamedContext.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = NamedContext(handle=_clientcmd.Slice_v1_NamedContext_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_clientcmd.Slice_v1_NamedContext_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []v1.NamedExtension
class Slice_v1_NamedExtension(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.Slice_v1_NamedExtension_CTor()
			_clientcmd.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_v1_NamedExtension.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		s = 'v1.Slice_v1_NamedExtension len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'v1.Slice_v1_NamedExtension([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _clientcmd.Slice_v1_NamedExtension_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _clientcmd.Slice_v1_NamedExtension_len(self.handle)
				return Slice_v1_NamedExtension(handle=_clientcmd.Slice_v1_NamedExtension_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return NamedExtension(handle=_clientcmd.Slice_v1_NamedExtension_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_clientcmd.Slice_v1_NamedExtension_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_v1_NamedExtension.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = NamedExtension(handle=_clientcmd.Slice_v1_NamedExtension_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_clientcmd.Slice_v1_NamedExtension_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---
AlwaysExecInteractiveMode = "Always"
IfAvailableExecInteractiveMode = "IfAvailable"
NeverExecInteractiveMode = "Never"


# ---- Global Variables: can only use functions to access ---
def SchemeGroupVersion():
	"""
	SchemeGroupVersion Gets Go Variable: v1.SchemeGroupVersion
	SchemeGroupVersion is group version used to register these objects
	TODO this should be in the "kubeconfig" group
	
	"""
	return go.schema_GroupVersion(handle=_clientcmd.v1_SchemeGroupVersion())

def Set_SchemeGroupVersion(value):
	"""
	Set_SchemeGroupVersion Sets Go Variable: v1.SchemeGroupVersion
	SchemeGroupVersion is group version used to register these objects
	TODO this should be in the "kubeconfig" group
	
	"""
	if isinstance(value, go.GoClass):
		_clientcmd.v1_Set_SchemeGroupVersion(value.handle)
	else:
		_clientcmd.v1_Set_SchemeGroupVersion(value)



# ---- Interfaces ---


# ---- Structs ---

# Python type for struct v1.NamedAuthInfo
class NamedAuthInfo(go.GoClass):
	"""NamedAuthInfo relates nicknames to auth information\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_NamedAuthInfo_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.AuthInfo = args[1]
			if "AuthInfo" in kwargs:
				self.AuthInfo = kwargs["AuthInfo"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.NamedAuthInfo{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.NamedAuthInfo ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		"""Name is the nickname for this AuthInfo
		"""
		return _clientcmd.v1_NamedAuthInfo_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_NamedAuthInfo_Name_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_NamedAuthInfo_Name_Set(self.handle, value)
	@property
	def AuthInfo(self):
		"""AuthInfo holds the auth information
		"""
		return AuthInfo(handle=_clientcmd.v1_NamedAuthInfo_AuthInfo_Get(self.handle))
	@AuthInfo.setter
	def AuthInfo(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_NamedAuthInfo_AuthInfo_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_NamedAuthInfo_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamedAuthInfo.
		"""
		return NamedAuthInfo(handle=_clientcmd.v1_NamedAuthInfo_DeepCopy(self.handle))

# Python type for struct v1.NamedCluster
class NamedCluster(go.GoClass):
	"""NamedCluster relates nicknames to cluster information\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_NamedCluster_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Cluster = args[1]
			if "Cluster" in kwargs:
				self.Cluster = kwargs["Cluster"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.NamedCluster{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.NamedCluster ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		"""Name is the nickname for this Cluster
		"""
		return _clientcmd.v1_NamedCluster_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_NamedCluster_Name_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_NamedCluster_Name_Set(self.handle, value)
	@property
	def Cluster(self):
		"""Cluster holds the cluster information
		"""
		return Cluster(handle=_clientcmd.v1_NamedCluster_Cluster_Get(self.handle))
	@Cluster.setter
	def Cluster(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_NamedCluster_Cluster_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_NamedCluster_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamedCluster.
		"""
		return NamedCluster(handle=_clientcmd.v1_NamedCluster_DeepCopy(self.handle))

# Python type for struct v1.NamedExtension
class NamedExtension(go.GoClass):
	"""NamedExtension relates nicknames to extension information\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_NamedExtension_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Extension = args[1]
			if "Extension" in kwargs:
				self.Extension = kwargs["Extension"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.NamedExtension{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.NamedExtension ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		"""Name is the nickname for this Extension
		"""
		return _clientcmd.v1_NamedExtension_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_NamedExtension_Name_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_NamedExtension_Name_Set(self.handle, value)
	@property
	def Extension(self):
		"""Extension holds the extension information
		"""
		return go.runtime_RawExtension(handle=_clientcmd.v1_NamedExtension_Extension_Get(self.handle))
	@Extension.setter
	def Extension(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_NamedExtension_Extension_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_NamedExtension_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamedExtension.
		"""
		return NamedExtension(handle=_clientcmd.v1_NamedExtension_DeepCopy(self.handle))

# Python type for struct v1.Preferences
class Preferences(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_Preferences_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Colors = args[0]
			if "Colors" in kwargs:
				self.Colors = kwargs["Colors"]
			if  1 < len(args):
				self.Extensions = args[1]
			if "Extensions" in kwargs:
				self.Extensions = kwargs["Extensions"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.Preferences{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.Preferences ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Colors(self):
		"""+optional
		"""
		return _clientcmd.v1_Preferences_Colors_Get(self.handle)
	@Colors.setter
	def Colors(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Preferences_Colors_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Preferences_Colors_Set(self.handle, value)
	@property
	def Extensions(self):
		"""Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
		+optional
		"""
		return Slice_v1_NamedExtension(handle=_clientcmd.v1_Preferences_Extensions_Get(self.handle))
	@Extensions.setter
	def Extensions(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Preferences_Extensions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_Preferences_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Preferences.
		"""
		return Preferences(handle=_clientcmd.v1_Preferences_DeepCopy(self.handle))

# Python type for struct v1.AuthInfo
class AuthInfo(go.GoClass):
	"""AuthInfo contains information that describes identity information.  This is use to tell the kubernetes cluster who you are.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_AuthInfo_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.ClientCertificate = args[0]
			if "ClientCertificate" in kwargs:
				self.ClientCertificate = kwargs["ClientCertificate"]
			if  1 < len(args):
				self.ClientCertificateData = args[1]
			if "ClientCertificateData" in kwargs:
				self.ClientCertificateData = kwargs["ClientCertificateData"]
			if  2 < len(args):
				self.ClientKey = args[2]
			if "ClientKey" in kwargs:
				self.ClientKey = kwargs["ClientKey"]
			if  3 < len(args):
				self.ClientKeyData = args[3]
			if "ClientKeyData" in kwargs:
				self.ClientKeyData = kwargs["ClientKeyData"]
			if  4 < len(args):
				self.Token = args[4]
			if "Token" in kwargs:
				self.Token = kwargs["Token"]
			if  5 < len(args):
				self.TokenFile = args[5]
			if "TokenFile" in kwargs:
				self.TokenFile = kwargs["TokenFile"]
			if  6 < len(args):
				self.Impersonate = args[6]
			if "Impersonate" in kwargs:
				self.Impersonate = kwargs["Impersonate"]
			if  7 < len(args):
				self.ImpersonateUID = args[7]
			if "ImpersonateUID" in kwargs:
				self.ImpersonateUID = kwargs["ImpersonateUID"]
			if  8 < len(args):
				self.ImpersonateGroups = args[8]
			if "ImpersonateGroups" in kwargs:
				self.ImpersonateGroups = kwargs["ImpersonateGroups"]
			if  9 < len(args):
				self.ImpersonateUserExtra = args[9]
			if "ImpersonateUserExtra" in kwargs:
				self.ImpersonateUserExtra = kwargs["ImpersonateUserExtra"]
			if  10 < len(args):
				self.Username = args[10]
			if "Username" in kwargs:
				self.Username = kwargs["Username"]
			if  11 < len(args):
				self.Password = args[11]
			if "Password" in kwargs:
				self.Password = kwargs["Password"]
			if  12 < len(args):
				self.AuthProvider = args[12]
			if "AuthProvider" in kwargs:
				self.AuthProvider = kwargs["AuthProvider"]
			if  13 < len(args):
				self.Exec = args[13]
			if "Exec" in kwargs:
				self.Exec = kwargs["Exec"]
			if  14 < len(args):
				self.Extensions = args[14]
			if "Extensions" in kwargs:
				self.Extensions = kwargs["Extensions"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.AuthInfo{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.AuthInfo ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ClientCertificate(self):
		"""ClientCertificate is the path to a client cert file for TLS.
		+optional
		"""
		return _clientcmd.v1_AuthInfo_ClientCertificate_Get(self.handle)
	@ClientCertificate.setter
	def ClientCertificate(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_ClientCertificate_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_AuthInfo_ClientCertificate_Set(self.handle, value)
	@property
	def ClientCertificateData(self):
		"""ClientCertificateData contains PEM-encoded data from a client cert file for TLS. Overrides ClientCertificate
		+optional
		"""
		return go.Slice_byte(handle=_clientcmd.v1_AuthInfo_ClientCertificateData_Get(self.handle))
	@ClientCertificateData.setter
	def ClientCertificateData(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_ClientCertificateData_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ClientKey(self):
		"""ClientKey is the path to a client key file for TLS.
		+optional
		"""
		return _clientcmd.v1_AuthInfo_ClientKey_Get(self.handle)
	@ClientKey.setter
	def ClientKey(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_ClientKey_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_AuthInfo_ClientKey_Set(self.handle, value)
	@property
	def ClientKeyData(self):
		"""ClientKeyData contains PEM-encoded data from a client key file for TLS. Overrides ClientKey
		+optional
		"""
		return go.Slice_byte(handle=_clientcmd.v1_AuthInfo_ClientKeyData_Get(self.handle))
	@ClientKeyData.setter
	def ClientKeyData(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_ClientKeyData_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Token(self):
		"""Token is the bearer token for authentication to the kubernetes cluster.
		+optional
		"""
		return _clientcmd.v1_AuthInfo_Token_Get(self.handle)
	@Token.setter
	def Token(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_Token_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_AuthInfo_Token_Set(self.handle, value)
	@property
	def TokenFile(self):
		"""TokenFile is a pointer to a file that contains a bearer token (as described above).  If both Token and TokenFile are present, Token takes precedence.
		+optional
		"""
		return _clientcmd.v1_AuthInfo_TokenFile_Get(self.handle)
	@TokenFile.setter
	def TokenFile(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_TokenFile_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_AuthInfo_TokenFile_Set(self.handle, value)
	@property
	def Impersonate(self):
		"""Impersonate is the username to impersonate.  The name matches the flag.
		+optional
		"""
		return _clientcmd.v1_AuthInfo_Impersonate_Get(self.handle)
	@Impersonate.setter
	def Impersonate(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_Impersonate_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_AuthInfo_Impersonate_Set(self.handle, value)
	@property
	def ImpersonateUID(self):
		"""ImpersonateUID is the uid to impersonate.
		+optional
		"""
		return _clientcmd.v1_AuthInfo_ImpersonateUID_Get(self.handle)
	@ImpersonateUID.setter
	def ImpersonateUID(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_ImpersonateUID_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_AuthInfo_ImpersonateUID_Set(self.handle, value)
	@property
	def ImpersonateGroups(self):
		"""ImpersonateGroups is the groups to impersonate.
		+optional
		"""
		return go.Slice_string(handle=_clientcmd.v1_AuthInfo_ImpersonateGroups_Get(self.handle))
	@ImpersonateGroups.setter
	def ImpersonateGroups(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_ImpersonateGroups_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ImpersonateUserExtra(self):
		"""ImpersonateUserExtra contains additional information for impersonated user.
		+optional
		"""
		return clientcmd.Map_string_Slice_string(handle=_clientcmd.v1_AuthInfo_ImpersonateUserExtra_Get(self.handle))
	@ImpersonateUserExtra.setter
	def ImpersonateUserExtra(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_ImpersonateUserExtra_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Username(self):
		"""Username is the username for basic authentication to the kubernetes cluster.
		+optional
		"""
		return _clientcmd.v1_AuthInfo_Username_Get(self.handle)
	@Username.setter
	def Username(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_Username_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_AuthInfo_Username_Set(self.handle, value)
	@property
	def Password(self):
		"""Password is the password for basic authentication to the kubernetes cluster.
		+optional
		"""
		return _clientcmd.v1_AuthInfo_Password_Get(self.handle)
	@Password.setter
	def Password(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_Password_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_AuthInfo_Password_Set(self.handle, value)
	@property
	def AuthProvider(self):
		"""AuthProvider specifies a custom authentication plugin for the kubernetes cluster.
		+optional
		"""
		return AuthProviderConfig(handle=_clientcmd.v1_AuthInfo_AuthProvider_Get(self.handle))
	@AuthProvider.setter
	def AuthProvider(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_AuthProvider_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Exec(self):
		"""Exec specifies a custom exec-based authentication plugin for the kubernetes cluster.
		+optional
		"""
		return ExecConfig(handle=_clientcmd.v1_AuthInfo_Exec_Get(self.handle))
	@Exec.setter
	def Exec(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_Exec_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Extensions(self):
		"""Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
		+optional
		"""
		return Slice_v1_NamedExtension(handle=_clientcmd.v1_AuthInfo_Extensions_Get(self.handle))
	@Extensions.setter
	def Extensions(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthInfo_Extensions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_AuthInfo_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthInfo.
		"""
		return AuthInfo(handle=_clientcmd.v1_AuthInfo_DeepCopy(self.handle))

# Python type for struct v1.AuthProviderConfig
class AuthProviderConfig(go.GoClass):
	"""AuthProviderConfig holds the configuration for a specified auth provider.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_AuthProviderConfig_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Config = args[1]
			if "Config" in kwargs:
				self.Config = kwargs["Config"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.AuthProviderConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.AuthProviderConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _clientcmd.v1_AuthProviderConfig_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthProviderConfig_Name_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_AuthProviderConfig_Name_Set(self.handle, value)
	@property
	def Config(self):
		return clientcmd.Map_string_string(handle=_clientcmd.v1_AuthProviderConfig_Config_Get(self.handle))
	@Config.setter
	def Config(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_AuthProviderConfig_Config_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_AuthProviderConfig_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuthProviderConfig.
		"""
		return AuthProviderConfig(handle=_clientcmd.v1_AuthProviderConfig_DeepCopy(self.handle))

# Python type for struct v1.ExecConfig
class ExecConfig(go.GoClass):
	"""ExecConfig specifies a command to provide client credentials. The command is exec'd\nand outputs structured stdout holding credentials.\n\nSee the client.authentication.k8s.io API group for specifications of the exact input\nand output format\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_ExecConfig_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Command = args[0]
			if "Command" in kwargs:
				self.Command = kwargs["Command"]
			if  1 < len(args):
				self.Args = args[1]
			if "Args" in kwargs:
				self.Args = kwargs["Args"]
			if  2 < len(args):
				self.Env = args[2]
			if "Env" in kwargs:
				self.Env = kwargs["Env"]
			if  3 < len(args):
				self.APIVersion = args[3]
			if "APIVersion" in kwargs:
				self.APIVersion = kwargs["APIVersion"]
			if  4 < len(args):
				self.InstallHint = args[4]
			if "InstallHint" in kwargs:
				self.InstallHint = kwargs["InstallHint"]
			if  5 < len(args):
				self.ProvideClusterInfo = args[5]
			if "ProvideClusterInfo" in kwargs:
				self.ProvideClusterInfo = kwargs["ProvideClusterInfo"]
			if  6 < len(args):
				self.InteractiveMode = args[6]
			if "InteractiveMode" in kwargs:
				self.InteractiveMode = kwargs["InteractiveMode"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.ExecConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.ExecConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Command(self):
		"""Command to execute.
		"""
		return _clientcmd.v1_ExecConfig_Command_Get(self.handle)
	@Command.setter
	def Command(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_ExecConfig_Command_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_ExecConfig_Command_Set(self.handle, value)
	@property
	def Args(self):
		"""Arguments to pass to the command when executing it.
		+optional
		"""
		return go.Slice_string(handle=_clientcmd.v1_ExecConfig_Args_Get(self.handle))
	@Args.setter
	def Args(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_ExecConfig_Args_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Env(self):
		"""Env defines additional environment variables to expose to the process. These
		are unioned with the host's environment, as well as variables client-go uses
		to pass argument to the plugin.
		+optional
		"""
		return Slice_v1_ExecEnvVar(handle=_clientcmd.v1_ExecConfig_Env_Get(self.handle))
	@Env.setter
	def Env(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_ExecConfig_Env_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def APIVersion(self):
		"""Preferred input version of the ExecInfo. The returned ExecCredentials MUST use
		the same encoding version as the input.
		"""
		return _clientcmd.v1_ExecConfig_APIVersion_Get(self.handle)
	@APIVersion.setter
	def APIVersion(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_ExecConfig_APIVersion_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_ExecConfig_APIVersion_Set(self.handle, value)
	@property
	def InstallHint(self):
		"""This text is shown to the user when the executable doesn't seem to be
		present. For example, `brew install foo-cli` might be a good InstallHint for
		foo-cli on Mac OS systems.
		"""
		return _clientcmd.v1_ExecConfig_InstallHint_Get(self.handle)
	@InstallHint.setter
	def InstallHint(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_ExecConfig_InstallHint_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_ExecConfig_InstallHint_Set(self.handle, value)
	@property
	def ProvideClusterInfo(self):
		"""ProvideClusterInfo determines whether or not to provide cluster information,
		which could potentially contain very large CA data, to this exec plugin as a
		part of the KUBERNETES_EXEC_INFO environment variable. By default, it is set
		to false. Package k8s.io/client-go/tools/auth/exec provides helper methods for
		reading this environment variable.
		"""
		return _clientcmd.v1_ExecConfig_ProvideClusterInfo_Get(self.handle)
	@ProvideClusterInfo.setter
	def ProvideClusterInfo(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_ExecConfig_ProvideClusterInfo_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_ExecConfig_ProvideClusterInfo_Set(self.handle, value)
	@property
	def InteractiveMode(self):
		"""InteractiveMode determines this plugin's relationship with standard input. Valid
		values are "Never" (this exec plugin never uses standard input), "IfAvailable" (this
		exec plugin wants to use standard input if it is available), or "Always" (this exec
		plugin requires standard input to function). See ExecInteractiveMode values for more
		details.
		
		If APIVersion is client.authentication.k8s.io/v1alpha1 or
		client.authentication.k8s.io/v1beta1, then this field is optional and defaults
		to "IfAvailable" when unset. Otherwise, this field is required.
		+optional
		"""
		return _clientcmd.v1_ExecConfig_InteractiveMode_Get(self.handle)
	@InteractiveMode.setter
	def InteractiveMode(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_ExecConfig_InteractiveMode_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_ExecConfig_InteractiveMode_Set(self.handle, value)
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_ExecConfig_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExecConfig.
		"""
		return ExecConfig(handle=_clientcmd.v1_ExecConfig_DeepCopy(self.handle))

# Python type for struct v1.ExecEnvVar
class ExecEnvVar(go.GoClass):
	"""ExecEnvVar is used for setting environment variables when executing an exec-based\ncredential plugin.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_ExecEnvVar_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Value = args[1]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.ExecEnvVar{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.ExecEnvVar ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _clientcmd.v1_ExecEnvVar_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_ExecEnvVar_Name_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_ExecEnvVar_Name_Set(self.handle, value)
	@property
	def Value(self):
		return _clientcmd.v1_ExecEnvVar_Value_Get(self.handle)
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_ExecEnvVar_Value_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_ExecEnvVar_Value_Set(self.handle, value)
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_ExecEnvVar_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExecEnvVar.
		"""
		return ExecEnvVar(handle=_clientcmd.v1_ExecEnvVar_DeepCopy(self.handle))

# Python type for struct v1.Cluster
class Cluster(go.GoClass):
	"""Cluster contains information about how to communicate with a kubernetes cluster\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_Cluster_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Server = args[0]
			if "Server" in kwargs:
				self.Server = kwargs["Server"]
			if  1 < len(args):
				self.TLSServerName = args[1]
			if "TLSServerName" in kwargs:
				self.TLSServerName = kwargs["TLSServerName"]
			if  2 < len(args):
				self.InsecureSkipTLSVerify = args[2]
			if "InsecureSkipTLSVerify" in kwargs:
				self.InsecureSkipTLSVerify = kwargs["InsecureSkipTLSVerify"]
			if  3 < len(args):
				self.CertificateAuthority = args[3]
			if "CertificateAuthority" in kwargs:
				self.CertificateAuthority = kwargs["CertificateAuthority"]
			if  4 < len(args):
				self.CertificateAuthorityData = args[4]
			if "CertificateAuthorityData" in kwargs:
				self.CertificateAuthorityData = kwargs["CertificateAuthorityData"]
			if  5 < len(args):
				self.ProxyURL = args[5]
			if "ProxyURL" in kwargs:
				self.ProxyURL = kwargs["ProxyURL"]
			if  6 < len(args):
				self.DisableCompression = args[6]
			if "DisableCompression" in kwargs:
				self.DisableCompression = kwargs["DisableCompression"]
			if  7 < len(args):
				self.Extensions = args[7]
			if "Extensions" in kwargs:
				self.Extensions = kwargs["Extensions"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.Cluster{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.Cluster ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Server(self):
		"""Server is the address of the kubernetes cluster (https://hostname:port).
		"""
		return _clientcmd.v1_Cluster_Server_Get(self.handle)
	@Server.setter
	def Server(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Cluster_Server_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Cluster_Server_Set(self.handle, value)
	@property
	def TLSServerName(self):
		"""TLSServerName is used to check server certificate. If TLSServerName is empty, the hostname used to contact the server is used.
		+optional
		"""
		return _clientcmd.v1_Cluster_TLSServerName_Get(self.handle)
	@TLSServerName.setter
	def TLSServerName(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Cluster_TLSServerName_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Cluster_TLSServerName_Set(self.handle, value)
	@property
	def InsecureSkipTLSVerify(self):
		"""InsecureSkipTLSVerify skips the validity check for the server's certificate. This will make your HTTPS connections insecure.
		+optional
		"""
		return _clientcmd.v1_Cluster_InsecureSkipTLSVerify_Get(self.handle)
	@InsecureSkipTLSVerify.setter
	def InsecureSkipTLSVerify(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Cluster_InsecureSkipTLSVerify_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Cluster_InsecureSkipTLSVerify_Set(self.handle, value)
	@property
	def CertificateAuthority(self):
		"""CertificateAuthority is the path to a cert file for the certificate authority.
		+optional
		"""
		return _clientcmd.v1_Cluster_CertificateAuthority_Get(self.handle)
	@CertificateAuthority.setter
	def CertificateAuthority(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Cluster_CertificateAuthority_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Cluster_CertificateAuthority_Set(self.handle, value)
	@property
	def CertificateAuthorityData(self):
		"""CertificateAuthorityData contains PEM-encoded certificate authority certificates. Overrides CertificateAuthority
		+optional
		"""
		return go.Slice_byte(handle=_clientcmd.v1_Cluster_CertificateAuthorityData_Get(self.handle))
	@CertificateAuthorityData.setter
	def CertificateAuthorityData(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Cluster_CertificateAuthorityData_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ProxyURL(self):
		"""ProxyURL is the URL to the proxy to be used for all requests made by this
		client. URLs with "http", "https", and "socks5" schemes are supported.  If
		this configuration is not provided or the empty string, the client
		attempts to construct a proxy configuration from http_proxy and
		https_proxy environment variables. If these environment variables are not
		set, the client does not attempt to proxy requests.
		
		socks5 proxying does not currently support spdy streaming endpoints (exec,
		attach, port forward).
		+optional
		"""
		return _clientcmd.v1_Cluster_ProxyURL_Get(self.handle)
	@ProxyURL.setter
	def ProxyURL(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Cluster_ProxyURL_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Cluster_ProxyURL_Set(self.handle, value)
	@property
	def DisableCompression(self):
		"""DisableCompression allows client to opt-out of response compression for all requests to the server. This is useful
		to speed up requests (specifically lists) when client-server network bandwidth is ample, by saving time on
		compression (server-side) and decompression (client-side): https://github.com/kubernetes/kubernetes/issues/112296.
		+optional
		"""
		return _clientcmd.v1_Cluster_DisableCompression_Get(self.handle)
	@DisableCompression.setter
	def DisableCompression(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Cluster_DisableCompression_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Cluster_DisableCompression_Set(self.handle, value)
	@property
	def Extensions(self):
		"""Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
		+optional
		"""
		return Slice_v1_NamedExtension(handle=_clientcmd.v1_Cluster_Extensions_Get(self.handle))
	@Extensions.setter
	def Extensions(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Cluster_Extensions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_Cluster_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Cluster.
		"""
		return Cluster(handle=_clientcmd.v1_Cluster_DeepCopy(self.handle))

# Python type for struct v1.Config
class Config(go.GoClass):
	"""Config holds the information needed to build connect to remote kubernetes clusters as a given user\n+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_Config_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Kind = args[0]
			if "Kind" in kwargs:
				self.Kind = kwargs["Kind"]
			if  1 < len(args):
				self.APIVersion = args[1]
			if "APIVersion" in kwargs:
				self.APIVersion = kwargs["APIVersion"]
			if  2 < len(args):
				self.Preferences = args[2]
			if "Preferences" in kwargs:
				self.Preferences = kwargs["Preferences"]
			if  3 < len(args):
				self.Clusters = args[3]
			if "Clusters" in kwargs:
				self.Clusters = kwargs["Clusters"]
			if  4 < len(args):
				self.AuthInfos = args[4]
			if "AuthInfos" in kwargs:
				self.AuthInfos = kwargs["AuthInfos"]
			if  5 < len(args):
				self.Contexts = args[5]
			if "Contexts" in kwargs:
				self.Contexts = kwargs["Contexts"]
			if  6 < len(args):
				self.CurrentContext = args[6]
			if "CurrentContext" in kwargs:
				self.CurrentContext = kwargs["CurrentContext"]
			if  7 < len(args):
				self.Extensions = args[7]
			if "Extensions" in kwargs:
				self.Extensions = kwargs["Extensions"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.Config{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.Config ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Kind(self):
		"""Legacy field from pkg/api/types.go TypeMeta.
		TODO(jlowdermilk): remove this after eliminating downstream dependencies.
		+k8s:conversion-gen=false
		+optional
		"""
		return _clientcmd.v1_Config_Kind_Get(self.handle)
	@Kind.setter
	def Kind(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Config_Kind_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Config_Kind_Set(self.handle, value)
	@property
	def APIVersion(self):
		"""Legacy field from pkg/api/types.go TypeMeta.
		TODO(jlowdermilk): remove this after eliminating downstream dependencies.
		+k8s:conversion-gen=false
		+optional
		"""
		return _clientcmd.v1_Config_APIVersion_Get(self.handle)
	@APIVersion.setter
	def APIVersion(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Config_APIVersion_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Config_APIVersion_Set(self.handle, value)
	@property
	def Preferences(self):
		"""Preferences holds general information to be use for cli interactions
		"""
		return Preferences(handle=_clientcmd.v1_Config_Preferences_Get(self.handle))
	@Preferences.setter
	def Preferences(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Config_Preferences_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Clusters(self):
		"""Clusters is a map of referencable names to cluster configs
		"""
		return Slice_v1_NamedCluster(handle=_clientcmd.v1_Config_Clusters_Get(self.handle))
	@Clusters.setter
	def Clusters(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Config_Clusters_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AuthInfos(self):
		"""AuthInfos is a map of referencable names to user configs
		"""
		return Slice_v1_NamedAuthInfo(handle=_clientcmd.v1_Config_AuthInfos_Get(self.handle))
	@AuthInfos.setter
	def AuthInfos(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Config_AuthInfos_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Contexts(self):
		"""Contexts is a map of referencable names to context configs
		"""
		return Slice_v1_NamedContext(handle=_clientcmd.v1_Config_Contexts_Get(self.handle))
	@Contexts.setter
	def Contexts(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Config_Contexts_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CurrentContext(self):
		"""CurrentContext is the name of the context that you would like to use by default
		"""
		return _clientcmd.v1_Config_CurrentContext_Get(self.handle)
	@CurrentContext.setter
	def CurrentContext(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Config_CurrentContext_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Config_CurrentContext_Set(self.handle, value)
	@property
	def Extensions(self):
		"""Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
		+optional
		"""
		return Slice_v1_NamedExtension(handle=_clientcmd.v1_Config_Extensions_Get(self.handle))
	@Extensions.setter
	def Extensions(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Config_Extensions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def GetObjectKind(self):
		"""GetObjectKind() object"""
		return go.schema_ObjectKind(handle=_clientcmd.v1_Config_GetObjectKind(self.handle))
	def SetGroupVersionKind(self, gvk, goRun=False):
		"""SetGroupVersionKind(object gvk) """
		_clientcmd.v1_Config_SetGroupVersionKind(self.handle, gvk.handle, goRun)
	def GroupVersionKind(self):
		"""GroupVersionKind() object"""
		return go.schema_GroupVersionKind(handle=_clientcmd.v1_Config_GroupVersionKind(self.handle))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_Config_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Config.
		"""
		return Config(handle=_clientcmd.v1_Config_DeepCopy(self.handle))
	def DeepCopyObject(self):
		"""DeepCopyObject() object
		
		DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
		"""
		return go.runtime_Object(handle=_clientcmd.v1_Config_DeepCopyObject(self.handle))

# Python type for struct v1.Context
class Context(go.GoClass):
	"""Context is a tuple of references to a cluster (how do I communicate with a kubernetes cluster), a user (how do I identify myself), and a namespace (what subset of resources do I want to work with)\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_Context_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Cluster = args[0]
			if "Cluster" in kwargs:
				self.Cluster = kwargs["Cluster"]
			if  1 < len(args):
				self.AuthInfo = args[1]
			if "AuthInfo" in kwargs:
				self.AuthInfo = kwargs["AuthInfo"]
			if  2 < len(args):
				self.Namespace = args[2]
			if "Namespace" in kwargs:
				self.Namespace = kwargs["Namespace"]
			if  3 < len(args):
				self.Extensions = args[3]
			if "Extensions" in kwargs:
				self.Extensions = kwargs["Extensions"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.Context{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.Context ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Cluster(self):
		"""Cluster is the name of the cluster for this context
		"""
		return _clientcmd.v1_Context_Cluster_Get(self.handle)
	@Cluster.setter
	def Cluster(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Context_Cluster_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Context_Cluster_Set(self.handle, value)
	@property
	def AuthInfo(self):
		"""AuthInfo is the name of the authInfo for this context
		"""
		return _clientcmd.v1_Context_AuthInfo_Get(self.handle)
	@AuthInfo.setter
	def AuthInfo(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Context_AuthInfo_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Context_AuthInfo_Set(self.handle, value)
	@property
	def Namespace(self):
		"""Namespace is the default namespace to use on unspecified requests
		+optional
		"""
		return _clientcmd.v1_Context_Namespace_Get(self.handle)
	@Namespace.setter
	def Namespace(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Context_Namespace_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_Context_Namespace_Set(self.handle, value)
	@property
	def Extensions(self):
		"""Extensions holds additional information. This is useful for extenders so that reads and writes don't clobber unknown fields
		+optional
		"""
		return Slice_v1_NamedExtension(handle=_clientcmd.v1_Context_Extensions_Get(self.handle))
	@Extensions.setter
	def Extensions(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_Context_Extensions_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_Context_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Context.
		"""
		return Context(handle=_clientcmd.v1_Context_DeepCopy(self.handle))

# Python type for struct v1.NamedContext
class NamedContext(go.GoClass):
	"""NamedContext relates nicknames to context information\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_clientcmd.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_clientcmd.IncRef(self.handle)
		else:
			self.handle = _clientcmd.v1_NamedContext_CTor()
			_clientcmd.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Context = args[1]
			if "Context" in kwargs:
				self.Context = kwargs["Context"]
	def __del__(self):
		_clientcmd.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.NamedContext{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'v1.NamedContext ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		"""Name is the nickname for this Context
		"""
		return _clientcmd.v1_NamedContext_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_NamedContext_Name_Set(self.handle, value.handle)
		else:
			_clientcmd.v1_NamedContext_Name_Set(self.handle, value)
	@property
	def Context(self):
		"""Context holds the context information
		"""
		return Context(handle=_clientcmd.v1_NamedContext_Context_Get(self.handle))
	@Context.setter
	def Context(self, value):
		if isinstance(value, go.GoClass):
			_clientcmd.v1_NamedContext_Context_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_clientcmd.v1_NamedContext_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamedContext.
		"""
		return NamedContext(handle=_clientcmd.v1_NamedContext_DeepCopy(self.handle))


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---


# ---- Functions ---
def Convert_v1_ExecEnvVar_To_api_ExecEnvVar(myin, out, s):
	"""Convert_v1_ExecEnvVar_To_api_ExecEnvVar(object in, object out, object s) str
	
	Convert_v1_ExecEnvVar_To_api_ExecEnvVar is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_v1_ExecEnvVar_To_api_ExecEnvVar(myin.handle, out.handle, s.handle)
def Convert_v1_Preferences_To_api_Preferences(myin, out, s):
	"""Convert_v1_Preferences_To_api_Preferences(object in, object out, object s) str
	
	Convert_v1_Preferences_To_api_Preferences is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_v1_Preferences_To_api_Preferences(myin.handle, out.handle, s.handle)
def Convert_Slice_v1_NamedAuthInfo_To_Map_string_To_Pointer_api_AuthInfo(myin, out, s):
	"""Convert_Slice_v1_NamedAuthInfo_To_Map_string_To_Pointer_api_AuthInfo(object in, object out, object s) str"""
	return _clientcmd.v1_Convert_Slice_v1_NamedAuthInfo_To_Map_string_To_Pointer_api_AuthInfo(myin.handle, out.handle, s.handle)
def Convert_v1_Cluster_To_api_Cluster(myin, out, s):
	"""Convert_v1_Cluster_To_api_Cluster(object in, object out, object s) str
	
	Convert_v1_Cluster_To_api_Cluster is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_v1_Cluster_To_api_Cluster(myin.handle, out.handle, s.handle)
def Convert_Slice_v1_NamedContext_To_Map_string_To_Pointer_api_Context(myin, out, s):
	"""Convert_Slice_v1_NamedContext_To_Map_string_To_Pointer_api_Context(object in, object out, object s) str"""
	return _clientcmd.v1_Convert_Slice_v1_NamedContext_To_Map_string_To_Pointer_api_Context(myin.handle, out.handle, s.handle)
def Convert_api_AuthProviderConfig_To_v1_AuthProviderConfig(myin, out, s):
	"""Convert_api_AuthProviderConfig_To_v1_AuthProviderConfig(object in, object out, object s) str
	
	Convert_api_AuthProviderConfig_To_v1_AuthProviderConfig is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_api_AuthProviderConfig_To_v1_AuthProviderConfig(myin.handle, out.handle, s.handle)
def Convert_api_Cluster_To_v1_Cluster(myin, out, s):
	"""Convert_api_Cluster_To_v1_Cluster(object in, object out, object s) str
	
	Convert_api_Cluster_To_v1_Cluster is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_api_Cluster_To_v1_Cluster(myin.handle, out.handle, s.handle)
def Convert_api_Config_To_v1_Config(myin, out, s):
	"""Convert_api_Config_To_v1_Config(object in, object out, object s) str
	
	Convert_api_Config_To_v1_Config is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_api_Config_To_v1_Config(myin.handle, out.handle, s.handle)
def Convert_Map_string_To_Pointer_api_Cluster_To_Slice_v1_NamedCluster(myin, out, s):
	"""Convert_Map_string_To_Pointer_api_Cluster_To_Slice_v1_NamedCluster(object in, object out, object s) str"""
	return _clientcmd.v1_Convert_Map_string_To_Pointer_api_Cluster_To_Slice_v1_NamedCluster(myin.handle, out.handle, s.handle)
def Convert_api_AuthInfo_To_v1_AuthInfo(myin, out, s):
	"""Convert_api_AuthInfo_To_v1_AuthInfo(object in, object out, object s) str
	
	Convert_api_AuthInfo_To_v1_AuthInfo is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_api_AuthInfo_To_v1_AuthInfo(myin.handle, out.handle, s.handle)
def Convert_api_ExecConfig_To_v1_ExecConfig(myin, out, s):
	"""Convert_api_ExecConfig_To_v1_ExecConfig(object in, object out, object s) str
	
	Convert_api_ExecConfig_To_v1_ExecConfig is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_api_ExecConfig_To_v1_ExecConfig(myin.handle, out.handle, s.handle)
def Convert_api_Preferences_To_v1_Preferences(myin, out, s):
	"""Convert_api_Preferences_To_v1_Preferences(object in, object out, object s) str
	
	Convert_api_Preferences_To_v1_Preferences is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_api_Preferences_To_v1_Preferences(myin.handle, out.handle, s.handle)
def Convert_v1_ExecConfig_To_api_ExecConfig(myin, out, s):
	"""Convert_v1_ExecConfig_To_api_ExecConfig(object in, object out, object s) str
	
	Convert_v1_ExecConfig_To_api_ExecConfig is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_v1_ExecConfig_To_api_ExecConfig(myin.handle, out.handle, s.handle)
def SetObjectDefaults_Config(myin, goRun=False):
	"""SetObjectDefaults_Config(object in) """
	_clientcmd.v1_SetObjectDefaults_Config(myin.handle, goRun)
def Convert_Slice_v1_NamedExtension_To_Map_string_To_runtime_Object(myin, out, s):
	"""Convert_Slice_v1_NamedExtension_To_Map_string_To_runtime_Object(object in, object out, object s) str"""
	return _clientcmd.v1_Convert_Slice_v1_NamedExtension_To_Map_string_To_runtime_Object(myin.handle, out.handle, s.handle)
def Convert_Map_string_To_Pointer_api_Context_To_Slice_v1_NamedContext(myin, out, s):
	"""Convert_Map_string_To_Pointer_api_Context_To_Slice_v1_NamedContext(object in, object out, object s) str"""
	return _clientcmd.v1_Convert_Map_string_To_Pointer_api_Context_To_Slice_v1_NamedContext(myin.handle, out.handle, s.handle)
def Convert_Map_string_To_runtime_Object_To_Slice_v1_NamedExtension(myin, out, s):
	"""Convert_Map_string_To_runtime_Object_To_Slice_v1_NamedExtension(object in, object out, object s) str"""
	return _clientcmd.v1_Convert_Map_string_To_runtime_Object_To_Slice_v1_NamedExtension(myin.handle, out.handle, s.handle)
def Convert_v1_AuthProviderConfig_To_api_AuthProviderConfig(myin, out, s):
	"""Convert_v1_AuthProviderConfig_To_api_AuthProviderConfig(object in, object out, object s) str
	
	Convert_v1_AuthProviderConfig_To_api_AuthProviderConfig is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_v1_AuthProviderConfig_To_api_AuthProviderConfig(myin.handle, out.handle, s.handle)
def Convert_v1_Config_To_api_Config(myin, out, s):
	"""Convert_v1_Config_To_api_Config(object in, object out, object s) str
	
	Convert_v1_Config_To_api_Config is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_v1_Config_To_api_Config(myin.handle, out.handle, s.handle)
def SetDefaults_ExecConfig(exec, goRun=False):
	"""SetDefaults_ExecConfig(object exec) """
	_clientcmd.v1_SetDefaults_ExecConfig(exec.handle, goRun)
def Convert_Map_string_To_Pointer_api_AuthInfo_To_Slice_v1_NamedAuthInfo(myin, out, s):
	"""Convert_Map_string_To_Pointer_api_AuthInfo_To_Slice_v1_NamedAuthInfo(object in, object out, object s) str"""
	return _clientcmd.v1_Convert_Map_string_To_Pointer_api_AuthInfo_To_Slice_v1_NamedAuthInfo(myin.handle, out.handle, s.handle)
def Convert_Slice_v1_NamedCluster_To_Map_string_To_Pointer_api_Cluster(myin, out, s):
	"""Convert_Slice_v1_NamedCluster_To_Map_string_To_Pointer_api_Cluster(object in, object out, object s) str"""
	return _clientcmd.v1_Convert_Slice_v1_NamedCluster_To_Map_string_To_Pointer_api_Cluster(myin.handle, out.handle, s.handle)
def Convert_api_Context_To_v1_Context(myin, out, s):
	"""Convert_api_Context_To_v1_Context(object in, object out, object s) str
	
	Convert_api_Context_To_v1_Context is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_api_Context_To_v1_Context(myin.handle, out.handle, s.handle)
def Convert_api_ExecEnvVar_To_v1_ExecEnvVar(myin, out, s):
	"""Convert_api_ExecEnvVar_To_v1_ExecEnvVar(object in, object out, object s) str
	
	Convert_api_ExecEnvVar_To_v1_ExecEnvVar is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_api_ExecEnvVar_To_v1_ExecEnvVar(myin.handle, out.handle, s.handle)
def RegisterConversions(s):
	"""RegisterConversions(object s) str
	
	RegisterConversions adds conversion functions to the given scheme.
	Public to allow building arbitrary schemes.
	"""
	return _clientcmd.v1_RegisterConversions(s.handle)
def RegisterDefaults(scheme):
	"""RegisterDefaults(object scheme) str
	
	RegisterDefaults adds defaulters functions to the given scheme.
	Public to allow building arbitrary schemes.
	All generated defaulters are covering - they call all nested defaulters.
	"""
	return _clientcmd.v1_RegisterDefaults(scheme.handle)
def Convert_v1_AuthInfo_To_api_AuthInfo(myin, out, s):
	"""Convert_v1_AuthInfo_To_api_AuthInfo(object in, object out, object s) str
	
	Convert_v1_AuthInfo_To_api_AuthInfo is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_v1_AuthInfo_To_api_AuthInfo(myin.handle, out.handle, s.handle)
def Convert_v1_Context_To_api_Context(myin, out, s):
	"""Convert_v1_Context_To_api_Context(object in, object out, object s) str
	
	Convert_v1_Context_To_api_Context is an autogenerated conversion function.
	"""
	return _clientcmd.v1_Convert_v1_Context_To_api_Context(myin.handle, out.handle, s.handle)


