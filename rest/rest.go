/*
cgo stubs for package rest.
File is generated by gopy. Do not edit.
gopy pkg k8s.io/client-go/rest
*/

package main

/*

#cgo CFLAGS: "-I/usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/include/python3.11" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/lib" "-lpython3.11" -ldl  -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"context"
	"crypto"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/asn1"
	"fmt"
	"io"
	"math/big"
	"math/rand"
	"mime/multipart"
	"net"
	"net/http"
	"net/textproto"
	"net/url"
	"reflect"
	"time"

	"k8s.io/apimachinery/pkg/conversion"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/apimachinery/pkg/runtime/serializer/streaming"
	"k8s.io/apimachinery/pkg/types"
	s1_net "k8s.io/apimachinery/pkg/util/net"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/pkg/apis/clientauthentication"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/rest/fake"
	s2_watch "k8s.io/client-go/rest/watch"
	"k8s.io/client-go/tools/clientcmd/api"
	"k8s.io/client-go/transport"
	"k8s.io/client-go/util/flowcontrol"
	"k8s.io/utils/clock"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: rest below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *tls.Certificate
func ptrFromHandle_Ptr_tls_Certificate(h CGoHandle) *tls.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tls.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.Certificate{})).(*tls.Certificate)
}
func handleFromPtr_Ptr_tls_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tls.Certificate", p))
}

// Converters for pointer handles for type: *tls.Config
func ptrFromHandle_Ptr_tls_Config(h CGoHandle) *tls.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tls.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.Config{})).(*tls.Config)
}
func handleFromPtr_Ptr_tls_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tls.Config", p))
}

// Converters for pointer handles for type: *tls.ConnectionState
func ptrFromHandle_Ptr_tls_ConnectionState(h CGoHandle) *tls.ConnectionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tls.ConnectionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.ConnectionState{})).(*tls.ConnectionState)
}
func handleFromPtr_Ptr_tls_ConnectionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tls.ConnectionState", p))
}

// Converters for pointer handles for type: *tls.SessionState
func ptrFromHandle_Ptr_tls_SessionState(h CGoHandle) *tls.SessionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tls.SessionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.SessionState{})).(*tls.SessionState)
}
func handleFromPtr_Ptr_tls_SessionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tls.SessionState", p))
}

// Converters for pointer handles for type: *x509.CertPool
func ptrFromHandle_Ptr_x509_CertPool(h CGoHandle) *x509.CertPool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*x509.CertPool")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.CertPool{})).(*x509.CertPool)
}
func handleFromPtr_Ptr_x509_CertPool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*x509.CertPool", p))
}

// Converters for pointer handles for type: *x509.Certificate
func ptrFromHandle_Ptr_x509_Certificate(h CGoHandle) *x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*x509.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.Certificate{})).(*x509.Certificate)
}
func handleFromPtr_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*x509.Certificate", p))
}

// Converters for pointer handles for type: *pkix.CertificateList
func ptrFromHandle_Ptr_pkix_CertificateList(h CGoHandle) *pkix.CertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pkix.CertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.CertificateList{})).(*pkix.CertificateList)
}
func handleFromPtr_Ptr_pkix_CertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pkix.CertificateList", p))
}

// Converters for pointer handles for type: *pkix.RDNSequence
func ptrFromHandle_Ptr_pkix_RDNSequence(h CGoHandle) *pkix.RDNSequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*pkix.RDNSequence")
	if p == nil {
		return nil
	}
	return p.(*pkix.RDNSequence)
}
func handleFromPtr_Ptr_pkix_RDNSequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*pkix.RDNSequence", p))
}

// Converters for pointer handles for type: *conversion.Converter
func ptrFromHandle_Ptr_conversion_Converter(h CGoHandle) *conversion.Converter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*conversion.Converter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Converter{})).(*conversion.Converter)
}
func handleFromPtr_Ptr_conversion_Converter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*conversion.Converter", p))
}

// Converters for pointer handles for type: *conversion.Meta
func ptrFromHandle_Ptr_conversion_Meta(h CGoHandle) *conversion.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*conversion.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Meta{})).(*conversion.Meta)
}
func handleFromPtr_Ptr_conversion_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*conversion.Meta", p))
}

// Converters for pointer handles for type: *runtime.Scheme
func ptrFromHandle_Ptr_runtime_Scheme(h CGoHandle) *runtime.Scheme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*runtime.Scheme")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.Scheme{})).(*runtime.Scheme)
}
func handleFromPtr_Ptr_runtime_Scheme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*runtime.Scheme", p))
}

// Converters for pointer handles for type: *runtime.StreamSerializerInfo
func ptrFromHandle_Ptr_runtime_StreamSerializerInfo(h CGoHandle) *runtime.StreamSerializerInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*runtime.StreamSerializerInfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.StreamSerializerInfo{})).(*runtime.StreamSerializerInfo)
}
func handleFromPtr_Ptr_runtime_StreamSerializerInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*runtime.StreamSerializerInfo", p))
}

// Converters for pointer handles for type: *schema.GroupVersion
func ptrFromHandle_Ptr_schema_GroupVersion(h CGoHandle) *schema.GroupVersion {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*schema.GroupVersion")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupVersion{})).(*schema.GroupVersion)
}
func handleFromPtr_Ptr_schema_GroupVersion(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*schema.GroupVersion", p))
}

// Converters for pointer handles for type: *watch.Event
func ptrFromHandle_Ptr_watch_Event(h CGoHandle) *watch.Event {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*watch.Event")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(watch.Event{})).(*watch.Event)
}
func handleFromPtr_Ptr_watch_Event(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*watch.Event", p))
}

// Converters for pointer handles for type: *clientauthentication.Cluster
func ptrFromHandle_Ptr_clientauthentication_Cluster(h CGoHandle) *clientauthentication.Cluster {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*clientauthentication.Cluster")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clientauthentication.Cluster{})).(*clientauthentication.Cluster)
}
func handleFromPtr_Ptr_clientauthentication_Cluster(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*clientauthentication.Cluster", p))
}

// Converters for pointer handles for type: *api.AuthProviderConfig
func ptrFromHandle_Ptr_api_AuthProviderConfig(h CGoHandle) *api.AuthProviderConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.AuthProviderConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.AuthProviderConfig{})).(*api.AuthProviderConfig)
}
func handleFromPtr_Ptr_api_AuthProviderConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.AuthProviderConfig", p))
}

// Converters for pointer handles for type: *api.ExecConfig
func ptrFromHandle_Ptr_api_ExecConfig(h CGoHandle) *api.ExecConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.ExecConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecConfig{})).(*api.ExecConfig)
}
func handleFromPtr_Ptr_api_ExecConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.ExecConfig", p))
}

// Converters for pointer handles for type: *api.ExecEnvVar
func ptrFromHandle_Ptr_api_ExecEnvVar(h CGoHandle) *api.ExecEnvVar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.ExecEnvVar")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecEnvVar{})).(*api.ExecEnvVar)
}
func handleFromPtr_Ptr_api_ExecEnvVar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.ExecEnvVar", p))
}

// Converters for pointer handles for type: *transport.Config
func ptrFromHandle_Ptr_transport_Config(h CGoHandle) *transport.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*transport.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.Config{})).(*transport.Config)
}
func handleFromPtr_Ptr_transport_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*transport.Config", p))
}

// Converters for pointer handles for type: *transport.DialHolder
func ptrFromHandle_Ptr_transport_DialHolder(h CGoHandle) *transport.DialHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*transport.DialHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.DialHolder{})).(*transport.DialHolder)
}
func handleFromPtr_Ptr_transport_DialHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*transport.DialHolder", p))
}

// Converters for pointer handles for type: *transport.GetCertHolder
func ptrFromHandle_Ptr_transport_GetCertHolder(h CGoHandle) *transport.GetCertHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*transport.GetCertHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.GetCertHolder{})).(*transport.GetCertHolder)
}
func handleFromPtr_Ptr_transport_GetCertHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*transport.GetCertHolder", p))
}

// Converters for pointer handles for type: *flowcontrol.Backoff
func ptrFromHandle_Ptr_flowcontrol_Backoff(h CGoHandle) *flowcontrol.Backoff {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*flowcontrol.Backoff")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(flowcontrol.Backoff{})).(*flowcontrol.Backoff)
}
func handleFromPtr_Ptr_flowcontrol_Backoff(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*flowcontrol.Backoff", p))
}

// Converters for pointer handles for type: *big.Int
func ptrFromHandle_Ptr_big_Int(h CGoHandle) *big.Int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*big.Int")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(big.Int{})).(*big.Int)
}
func handleFromPtr_Ptr_big_Int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*big.Int", p))
}

// Converters for pointer handles for type: *rand.Rand
func ptrFromHandle_Ptr_rand_Rand(h CGoHandle) *rand.Rand {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rand.Rand")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rand.Rand{})).(*rand.Rand)
}
func handleFromPtr_Ptr_rand_Rand(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rand.Rand", p))
}

// Converters for pointer handles for type: *multipart.FileHeader
func ptrFromHandle_Ptr_multipart_FileHeader(h CGoHandle) *multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.FileHeader{})).(*multipart.FileHeader)
}
func handleFromPtr_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.FileHeader", p))
}

// Converters for pointer handles for type: *multipart.Form
func ptrFromHandle_Ptr_multipart_Form(h CGoHandle) *multipart.Form {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Form")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Form{})).(*multipart.Form)
}
func handleFromPtr_Ptr_multipart_Form(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Form", p))
}

// Converters for pointer handles for type: *multipart.Part
func ptrFromHandle_Ptr_multipart_Part(h CGoHandle) *multipart.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Part{})).(*multipart.Part)
}
func handleFromPtr_Ptr_multipart_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Part", p))
}

// Converters for pointer handles for type: *multipart.Reader
func ptrFromHandle_Ptr_multipart_Reader(h CGoHandle) *multipart.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*multipart.Reader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Reader{})).(*multipart.Reader)
}
func handleFromPtr_Ptr_multipart_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*multipart.Reader", p))
}

// Converters for pointer handles for type: *net.IPNet
func ptrFromHandle_Ptr_net_IPNet(h CGoHandle) *net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*net.IPNet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.IPNet{})).(*net.IPNet)
}
func handleFromPtr_Ptr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*net.IPNet", p))
}

// Converters for pointer handles for type: *http.Client
func ptrFromHandle_Ptr_http_Client(h CGoHandle) *http.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Client{})).(*http.Client)
}
func handleFromPtr_Ptr_http_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Client", p))
}

// Converters for pointer handles for type: *http.Cookie
func ptrFromHandle_Ptr_http_Cookie(h CGoHandle) *http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Cookie")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Cookie{})).(*http.Cookie)
}
func handleFromPtr_Ptr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Cookie", p))
}

// Converters for pointer handles for type: *http.Request
func ptrFromHandle_Ptr_http_Request(h CGoHandle) *http.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Request{})).(*http.Request)
}
func handleFromPtr_Ptr_http_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Request", p))
}

// Converters for pointer handles for type: *http.Response
func ptrFromHandle_Ptr_http_Response(h CGoHandle) *http.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*http.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Response{})).(*http.Response)
}
func handleFromPtr_Ptr_http_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*http.Response", p))
}

// Converters for pointer handles for type: *url.URL
func ptrFromHandle_Ptr_url_URL(h CGoHandle) *url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*url.URL")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.URL{})).(*url.URL)
}
func handleFromPtr_Ptr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*url.URL", p))
}

// Converters for pointer handles for type: *url.Userinfo
func ptrFromHandle_Ptr_url_Userinfo(h CGoHandle) *url.Userinfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*url.Userinfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.Userinfo{})).(*url.Userinfo)
}
func handleFromPtr_Ptr_url_Userinfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*url.Userinfo", p))
}

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for pointer handles for type: context.Context
func ptrFromHandle_context_Context(h CGoHandle) context.Context {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "context.Context")
	if p == nil {
		return nil
	}
	return p.(context.Context)
}
func handleFromPtr_context_Context(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("context.Context", p))
}

// Converters for pointer handles for type: crypto.PrivateKey
func ptrFromHandle_crypto_PrivateKey(h CGoHandle) crypto.PrivateKey {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "crypto.PrivateKey")
	if p == nil {
		return nil
	}
	return p.(crypto.PrivateKey)
}
func handleFromPtr_crypto_PrivateKey(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("crypto.PrivateKey", p))
}

// Converters for non-pointer handles for type: tls.Certificate
func ptrFromHandle_tls_Certificate(h CGoHandle) *tls.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tls.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.Certificate{})).(*tls.Certificate)
}
func handleFromPtr_tls_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tls.Certificate", p))
}

// Converters for pointer handles for type: tls.ClientSessionCache
func ptrFromHandle_tls_ClientSessionCache(h CGoHandle) tls.ClientSessionCache {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tls.ClientSessionCache")
	if p == nil {
		return nil
	}
	return p.(tls.ClientSessionCache)
}
func handleFromPtr_tls_ClientSessionCache(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tls.ClientSessionCache", p))
}

// Converters for non-pointer handles for type: tls.Config
func ptrFromHandle_tls_Config(h CGoHandle) *tls.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tls.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.Config{})).(*tls.Config)
}
func handleFromPtr_tls_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tls.Config", p))
}

// Converters for non-pointer handles for type: tls.ConnectionState
func ptrFromHandle_tls_ConnectionState(h CGoHandle) *tls.ConnectionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tls.ConnectionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.ConnectionState{})).(*tls.ConnectionState)
}
func handleFromPtr_tls_ConnectionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tls.ConnectionState", p))
}

// Converters for non-pointer handles for type: tls.SessionState
func ptrFromHandle_tls_SessionState(h CGoHandle) *tls.SessionState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tls.SessionState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tls.SessionState{})).(*tls.SessionState)
}
func handleFromPtr_tls_SessionState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tls.SessionState", p))
}

// Converters for non-pointer handles for type: x509.CertPool
func ptrFromHandle_x509_CertPool(h CGoHandle) *x509.CertPool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.CertPool")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.CertPool{})).(*x509.CertPool)
}
func handleFromPtr_x509_CertPool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.CertPool", p))
}

// Converters for non-pointer handles for type: x509.Certificate
func ptrFromHandle_x509_Certificate(h CGoHandle) *x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.Certificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.Certificate{})).(*x509.Certificate)
}
func handleFromPtr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.Certificate", p))
}

// Converters for non-pointer handles for type: x509.OID
func ptrFromHandle_x509_OID(h CGoHandle) *x509.OID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.OID")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.OID{})).(*x509.OID)
}
func handleFromPtr_x509_OID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.OID", p))
}

// Converters for non-pointer handles for type: x509.VerifyOptions
func ptrFromHandle_x509_VerifyOptions(h CGoHandle) *x509.VerifyOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "x509.VerifyOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(x509.VerifyOptions{})).(*x509.VerifyOptions)
}
func handleFromPtr_x509_VerifyOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("x509.VerifyOptions", p))
}

// Converters for non-pointer handles for type: pkix.AlgorithmIdentifier
func ptrFromHandle_pkix_AlgorithmIdentifier(h CGoHandle) *pkix.AlgorithmIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.AlgorithmIdentifier")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.AlgorithmIdentifier{})).(*pkix.AlgorithmIdentifier)
}
func handleFromPtr_pkix_AlgorithmIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.AlgorithmIdentifier", p))
}

// Converters for non-pointer handles for type: pkix.AttributeTypeAndValue
func ptrFromHandle_pkix_AttributeTypeAndValue(h CGoHandle) *pkix.AttributeTypeAndValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.AttributeTypeAndValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.AttributeTypeAndValue{})).(*pkix.AttributeTypeAndValue)
}
func handleFromPtr_pkix_AttributeTypeAndValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.AttributeTypeAndValue", p))
}

// Converters for non-pointer handles for type: pkix.CertificateList
func ptrFromHandle_pkix_CertificateList(h CGoHandle) *pkix.CertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.CertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.CertificateList{})).(*pkix.CertificateList)
}
func handleFromPtr_pkix_CertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.CertificateList", p))
}

// Converters for non-pointer handles for type: pkix.Extension
func ptrFromHandle_pkix_Extension(h CGoHandle) *pkix.Extension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.Extension")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.Extension{})).(*pkix.Extension)
}
func handleFromPtr_pkix_Extension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.Extension", p))
}

// Converters for non-pointer handles for type: pkix.Name
func ptrFromHandle_pkix_Name(h CGoHandle) *pkix.Name {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.Name")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.Name{})).(*pkix.Name)
}
func handleFromPtr_pkix_Name(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.Name", p))
}

// Converters for implicit pointer handles for type: pkix.RDNSequence
func ptrFromHandle_pkix_RDNSequence(h CGoHandle) *pkix.RDNSequence {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RDNSequence")
	if p == nil {
		return nil
	}
	return p.(*pkix.RDNSequence)
}
func deptrFromHandle_pkix_RDNSequence(h CGoHandle) pkix.RDNSequence {
	p := ptrFromHandle_pkix_RDNSequence(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_pkix_RDNSequence(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RDNSequence", p))
}

// Converters for implicit pointer handles for type: pkix.RelativeDistinguishedNameSET
func ptrFromHandle_pkix_RelativeDistinguishedNameSET(h CGoHandle) *pkix.RelativeDistinguishedNameSET {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RelativeDistinguishedNameSET")
	if p == nil {
		return nil
	}
	return p.(*pkix.RelativeDistinguishedNameSET)
}
func deptrFromHandle_pkix_RelativeDistinguishedNameSET(h CGoHandle) pkix.RelativeDistinguishedNameSET {
	p := ptrFromHandle_pkix_RelativeDistinguishedNameSET(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_pkix_RelativeDistinguishedNameSET(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RelativeDistinguishedNameSET", p))
}

// --- wrapping slice: pkix.RelativeDistinguishedNameSET ---
//
//export pkix_RelativeDistinguishedNameSET_CTor
func pkix_RelativeDistinguishedNameSET_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_pkix_RelativeDistinguishedNameSET(&pkix.RelativeDistinguishedNameSET{}))
}

//export pkix_RelativeDistinguishedNameSET_len
func pkix_RelativeDistinguishedNameSET_len(handle CGoHandle) int {
	return len(deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle))
}

//export pkix_RelativeDistinguishedNameSET_elem
func pkix_RelativeDistinguishedNameSET_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	return handleFromPtr_pkix_AttributeTypeAndValue(&(s[_idx]))
}

//export pkix_RelativeDistinguishedNameSET_subslice
func pkix_RelativeDistinguishedNameSET_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_pkix_RelativeDistinguishedNameSET(&ss))
}

//export pkix_RelativeDistinguishedNameSET_set
func pkix_RelativeDistinguishedNameSET_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	s[_idx] = *ptrFromHandle_pkix_AttributeTypeAndValue(_vl)
}

//export pkix_RelativeDistinguishedNameSET_append
func pkix_RelativeDistinguishedNameSET_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_pkix_RelativeDistinguishedNameSET(handle)
	*s = append(*s, *ptrFromHandle_pkix_AttributeTypeAndValue(_vl))
}

// Converters for non-pointer handles for type: pkix.RevokedCertificate
func ptrFromHandle_pkix_RevokedCertificate(h CGoHandle) *pkix.RevokedCertificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.RevokedCertificate")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.RevokedCertificate{})).(*pkix.RevokedCertificate)
}
func handleFromPtr_pkix_RevokedCertificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.RevokedCertificate", p))
}

// Converters for non-pointer handles for type: pkix.TBSCertificateList
func ptrFromHandle_pkix_TBSCertificateList(h CGoHandle) *pkix.TBSCertificateList {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "pkix.TBSCertificateList")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(pkix.TBSCertificateList{})).(*pkix.TBSCertificateList)
}
func handleFromPtr_pkix_TBSCertificateList(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("pkix.TBSCertificateList", p))
}

// Converters for non-pointer handles for type: asn1.BitString
func ptrFromHandle_asn1_BitString(h CGoHandle) *asn1.BitString {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.BitString")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(asn1.BitString{})).(*asn1.BitString)
}
func handleFromPtr_asn1_BitString(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.BitString", p))
}

// Converters for implicit pointer handles for type: asn1.ObjectIdentifier
func ptrFromHandle_asn1_ObjectIdentifier(h CGoHandle) *asn1.ObjectIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.ObjectIdentifier")
	if p == nil {
		return nil
	}
	return p.(*asn1.ObjectIdentifier)
}
func deptrFromHandle_asn1_ObjectIdentifier(h CGoHandle) asn1.ObjectIdentifier {
	p := ptrFromHandle_asn1_ObjectIdentifier(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_asn1_ObjectIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.ObjectIdentifier", p))
}

// --- wrapping slice: asn1.ObjectIdentifier ---
//
//export asn1_ObjectIdentifier_CTor
func asn1_ObjectIdentifier_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_asn1_ObjectIdentifier(&asn1.ObjectIdentifier{}))
}

//export asn1_ObjectIdentifier_len
func asn1_ObjectIdentifier_len(handle CGoHandle) int {
	return len(deptrFromHandle_asn1_ObjectIdentifier(handle))
}

//export asn1_ObjectIdentifier_elem
func asn1_ObjectIdentifier_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	return C.longlong(s[_idx])
}

//export asn1_ObjectIdentifier_subslice
func asn1_ObjectIdentifier_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_asn1_ObjectIdentifier(&ss))
}

//export asn1_ObjectIdentifier_set
func asn1_ObjectIdentifier_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_asn1_ObjectIdentifier(handle)
	s[_idx] = int(_vl)
}

//export asn1_ObjectIdentifier_append
func asn1_ObjectIdentifier_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_asn1_ObjectIdentifier(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: asn1.RawContent
func ptrFromHandle_asn1_RawContent(h CGoHandle) *asn1.RawContent {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.RawContent")
	if p == nil {
		return nil
	}
	return p.(*asn1.RawContent)
}
func deptrFromHandle_asn1_RawContent(h CGoHandle) asn1.RawContent {
	p := ptrFromHandle_asn1_RawContent(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_asn1_RawContent(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.RawContent", p))
}

// --- wrapping slice: asn1.RawContent ---
//
//export asn1_RawContent_CTor
func asn1_RawContent_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_asn1_RawContent(&asn1.RawContent{}))
}

//export asn1_RawContent_len
func asn1_RawContent_len(handle CGoHandle) int {
	return len(deptrFromHandle_asn1_RawContent(handle))
}

//export asn1_RawContent_elem
func asn1_RawContent_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_asn1_RawContent(handle)
	return C.char(s[_idx])
}

//export asn1_RawContent_subslice
func asn1_RawContent_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_asn1_RawContent(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_asn1_RawContent(&ss))
}

//export asn1_RawContent_set
func asn1_RawContent_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_asn1_RawContent(handle)
	s[_idx] = byte(_vl)
}

//export asn1_RawContent_append
func asn1_RawContent_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_asn1_RawContent(handle)
	*s = append(*s, byte(_vl))
}

// Converters for non-pointer handles for type: asn1.RawValue
func ptrFromHandle_asn1_RawValue(h CGoHandle) *asn1.RawValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "asn1.RawValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(asn1.RawValue{})).(*asn1.RawValue)
}
func handleFromPtr_asn1_RawValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("asn1.RawValue", p))
}

// Converters for pointer handles for type: fmt.ScanState
func ptrFromHandle_fmt_ScanState(h CGoHandle) fmt.ScanState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fmt.ScanState")
	if p == nil {
		return nil
	}
	return p.(fmt.ScanState)
}
func handleFromPtr_fmt_ScanState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fmt.ScanState", p))
}

// Converters for pointer handles for type: fmt.State
func ptrFromHandle_fmt_State(h CGoHandle) fmt.State {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fmt.State")
	if p == nil {
		return nil
	}
	return p.(fmt.State)
}
func handleFromPtr_fmt_State(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fmt.State", p))
}

// Converters for pointer handles for type: io.ReadCloser
func ptrFromHandle_io_ReadCloser(h CGoHandle) io.ReadCloser {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.ReadCloser")
	if p == nil {
		return nil
	}
	return p.(io.ReadCloser)
}
func handleFromPtr_io_ReadCloser(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.ReadCloser", p))
}

// Converters for pointer handles for type: io.Reader
func ptrFromHandle_io_Reader(h CGoHandle) io.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Reader")
	if p == nil {
		return nil
	}
	return p.(io.Reader)
}
func handleFromPtr_io_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Reader", p))
}

// Converters for pointer handles for type: io.Writer
func ptrFromHandle_io_Writer(h CGoHandle) io.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Writer")
	if p == nil {
		return nil
	}
	return p.(io.Writer)
}
func handleFromPtr_io_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Writer", p))
}

// Converters for non-pointer handles for type: conversion.ConversionFuncs
func ptrFromHandle_conversion_ConversionFuncs(h CGoHandle) *conversion.ConversionFuncs {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "conversion.ConversionFuncs")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.ConversionFuncs{})).(*conversion.ConversionFuncs)
}
func handleFromPtr_conversion_ConversionFuncs(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("conversion.ConversionFuncs", p))
}

// Converters for non-pointer handles for type: conversion.Converter
func ptrFromHandle_conversion_Converter(h CGoHandle) *conversion.Converter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "conversion.Converter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Converter{})).(*conversion.Converter)
}
func handleFromPtr_conversion_Converter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("conversion.Converter", p))
}

// Converters for non-pointer handles for type: conversion.Meta
func ptrFromHandle_conversion_Meta(h CGoHandle) *conversion.Meta {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "conversion.Meta")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(conversion.Meta{})).(*conversion.Meta)
}
func handleFromPtr_conversion_Meta(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("conversion.Meta", p))
}

// Converters for pointer handles for type: runtime.ClientNegotiator
func ptrFromHandle_runtime_ClientNegotiator(h CGoHandle) runtime.ClientNegotiator {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.ClientNegotiator")
	if p == nil {
		return nil
	}
	return p.(runtime.ClientNegotiator)
}
func handleFromPtr_runtime_ClientNegotiator(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.ClientNegotiator", p))
}

// Converters for pointer handles for type: runtime.Codec
func ptrFromHandle_runtime_Codec(h CGoHandle) runtime.Codec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Codec")
	if p == nil {
		return nil
	}
	return p.(runtime.Codec)
}
func handleFromPtr_runtime_Codec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Codec", p))
}

// Converters for pointer handles for type: runtime.Decoder
func ptrFromHandle_runtime_Decoder(h CGoHandle) runtime.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Decoder")
	if p == nil {
		return nil
	}
	return p.(runtime.Decoder)
}
func handleFromPtr_runtime_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Decoder", p))
}

// Converters for pointer handles for type: runtime.Encoder
func ptrFromHandle_runtime_Encoder(h CGoHandle) runtime.Encoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Encoder")
	if p == nil {
		return nil
	}
	return p.(runtime.Encoder)
}
func handleFromPtr_runtime_Encoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Encoder", p))
}

// Converters for pointer handles for type: runtime.GroupVersioner
func ptrFromHandle_runtime_GroupVersioner(h CGoHandle) runtime.GroupVersioner {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.GroupVersioner")
	if p == nil {
		return nil
	}
	return p.(runtime.GroupVersioner)
}
func handleFromPtr_runtime_GroupVersioner(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.GroupVersioner", p))
}

// Converters for pointer handles for type: runtime.NegotiatedSerializer
func ptrFromHandle_runtime_NegotiatedSerializer(h CGoHandle) runtime.NegotiatedSerializer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.NegotiatedSerializer")
	if p == nil {
		return nil
	}
	return p.(runtime.NegotiatedSerializer)
}
func handleFromPtr_runtime_NegotiatedSerializer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.NegotiatedSerializer", p))
}

// Converters for pointer handles for type: runtime.Object
func ptrFromHandle_runtime_Object(h CGoHandle) runtime.Object {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Object")
	if p == nil {
		return nil
	}
	return p.(runtime.Object)
}
func handleFromPtr_runtime_Object(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Object", p))
}

// Converters for pointer handles for type: runtime.ParameterCodec
func ptrFromHandle_runtime_ParameterCodec(h CGoHandle) runtime.ParameterCodec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.ParameterCodec")
	if p == nil {
		return nil
	}
	return p.(runtime.ParameterCodec)
}
func handleFromPtr_runtime_ParameterCodec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.ParameterCodec", p))
}

// Converters for non-pointer handles for type: runtime.Scheme
func ptrFromHandle_runtime_Scheme(h CGoHandle) *runtime.Scheme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Scheme")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.Scheme{})).(*runtime.Scheme)
}
func handleFromPtr_runtime_Scheme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Scheme", p))
}

// Converters for pointer handles for type: runtime.Serializer
func ptrFromHandle_runtime_Serializer(h CGoHandle) runtime.Serializer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.Serializer")
	if p == nil {
		return nil
	}
	return p.(runtime.Serializer)
}
func handleFromPtr_runtime_Serializer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.Serializer", p))
}

// Converters for non-pointer handles for type: runtime.SerializerInfo
func ptrFromHandle_runtime_SerializerInfo(h CGoHandle) *runtime.SerializerInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.SerializerInfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.SerializerInfo{})).(*runtime.SerializerInfo)
}
func handleFromPtr_runtime_SerializerInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.SerializerInfo", p))
}

// Converters for non-pointer handles for type: runtime.StreamSerializerInfo
func ptrFromHandle_runtime_StreamSerializerInfo(h CGoHandle) *runtime.StreamSerializerInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "runtime.StreamSerializerInfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(runtime.StreamSerializerInfo{})).(*runtime.StreamSerializerInfo)
}
func handleFromPtr_runtime_StreamSerializerInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("runtime.StreamSerializerInfo", p))
}

// Converters for non-pointer handles for type: schema.GroupKind
func ptrFromHandle_schema_GroupKind(h CGoHandle) *schema.GroupKind {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupKind")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupKind{})).(*schema.GroupKind)
}
func handleFromPtr_schema_GroupKind(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupKind", p))
}

// Converters for non-pointer handles for type: schema.GroupResource
func ptrFromHandle_schema_GroupResource(h CGoHandle) *schema.GroupResource {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupResource")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupResource{})).(*schema.GroupResource)
}
func handleFromPtr_schema_GroupResource(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupResource", p))
}

// Converters for non-pointer handles for type: schema.GroupVersion
func ptrFromHandle_schema_GroupVersion(h CGoHandle) *schema.GroupVersion {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupVersion")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupVersion{})).(*schema.GroupVersion)
}
func handleFromPtr_schema_GroupVersion(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupVersion", p))
}

// Converters for non-pointer handles for type: schema.GroupVersionKind
func ptrFromHandle_schema_GroupVersionKind(h CGoHandle) *schema.GroupVersionKind {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupVersionKind")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupVersionKind{})).(*schema.GroupVersionKind)
}
func handleFromPtr_schema_GroupVersionKind(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupVersionKind", p))
}

// Converters for non-pointer handles for type: schema.GroupVersionResource
func ptrFromHandle_schema_GroupVersionResource(h CGoHandle) *schema.GroupVersionResource {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "schema.GroupVersionResource")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(schema.GroupVersionResource{})).(*schema.GroupVersionResource)
}
func handleFromPtr_schema_GroupVersionResource(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("schema.GroupVersionResource", p))
}

// Converters for non-pointer handles for type: serializer.CodecFactory
func ptrFromHandle_serializer_CodecFactory(h CGoHandle) *serializer.CodecFactory {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "serializer.CodecFactory")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(serializer.CodecFactory{})).(*serializer.CodecFactory)
}
func handleFromPtr_serializer_CodecFactory(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("serializer.CodecFactory", p))
}

// Converters for pointer handles for type: streaming.Decoder
func ptrFromHandle_streaming_Decoder(h CGoHandle) streaming.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "streaming.Decoder")
	if p == nil {
		return nil
	}
	return p.(streaming.Decoder)
}
func handleFromPtr_streaming_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("streaming.Decoder", p))
}

// Converters for pointer handles for type: streaming.Encoder
func ptrFromHandle_streaming_Encoder(h CGoHandle) streaming.Encoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "streaming.Encoder")
	if p == nil {
		return nil
	}
	return p.(streaming.Encoder)
}
func handleFromPtr_streaming_Encoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("streaming.Encoder", p))
}

// Converters for non-pointer handles for type: s1_net.WarningHeader
func ptrFromHandle_s1_net_WarningHeader(h CGoHandle) *s1_net.WarningHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "s1_net.WarningHeader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(s1_net.WarningHeader{})).(*s1_net.WarningHeader)
}
func handleFromPtr_s1_net_WarningHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("s1_net.WarningHeader", p))
}

// Converters for non-pointer handles for type: watch.Event
func ptrFromHandle_watch_Event(h CGoHandle) *watch.Event {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "watch.Event")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(watch.Event{})).(*watch.Event)
}
func handleFromPtr_watch_Event(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("watch.Event", p))
}

// Converters for pointer handles for type: watch.Interface
func ptrFromHandle_watch_Interface(h CGoHandle) watch.Interface {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "watch.Interface")
	if p == nil {
		return nil
	}
	return p.(watch.Interface)
}
func handleFromPtr_watch_Interface(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("watch.Interface", p))
}

// Converters for non-pointer handles for type: clientauthentication.Cluster
func ptrFromHandle_clientauthentication_Cluster(h CGoHandle) *clientauthentication.Cluster {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "clientauthentication.Cluster")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(clientauthentication.Cluster{})).(*clientauthentication.Cluster)
}
func handleFromPtr_clientauthentication_Cluster(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("clientauthentication.Cluster", p))
}

// Converters for non-pointer handles for type: api.AuthProviderConfig
func ptrFromHandle_api_AuthProviderConfig(h CGoHandle) *api.AuthProviderConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.AuthProviderConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.AuthProviderConfig{})).(*api.AuthProviderConfig)
}
func handleFromPtr_api_AuthProviderConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.AuthProviderConfig", p))
}

// Converters for non-pointer handles for type: api.ExecConfig
func ptrFromHandle_api_ExecConfig(h CGoHandle) *api.ExecConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.ExecConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecConfig{})).(*api.ExecConfig)
}
func handleFromPtr_api_ExecConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.ExecConfig", p))
}

// Converters for non-pointer handles for type: api.ExecEnvVar
func ptrFromHandle_api_ExecEnvVar(h CGoHandle) *api.ExecEnvVar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.ExecEnvVar")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecEnvVar{})).(*api.ExecEnvVar)
}
func handleFromPtr_api_ExecEnvVar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.ExecEnvVar", p))
}

// Converters for non-pointer handles for type: transport.Config
func ptrFromHandle_transport_Config(h CGoHandle) *transport.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.Config{})).(*transport.Config)
}
func handleFromPtr_transport_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.Config", p))
}

// Converters for non-pointer handles for type: transport.DialHolder
func ptrFromHandle_transport_DialHolder(h CGoHandle) *transport.DialHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.DialHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.DialHolder{})).(*transport.DialHolder)
}
func handleFromPtr_transport_DialHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.DialHolder", p))
}

// Converters for non-pointer handles for type: transport.GetCertHolder
func ptrFromHandle_transport_GetCertHolder(h CGoHandle) *transport.GetCertHolder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.GetCertHolder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.GetCertHolder{})).(*transport.GetCertHolder)
}
func handleFromPtr_transport_GetCertHolder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.GetCertHolder", p))
}

// Converters for non-pointer handles for type: transport.ImpersonationConfig
func ptrFromHandle_transport_ImpersonationConfig(h CGoHandle) *transport.ImpersonationConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.ImpersonationConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.ImpersonationConfig{})).(*transport.ImpersonationConfig)
}
func handleFromPtr_transport_ImpersonationConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.ImpersonationConfig", p))
}

// Converters for non-pointer handles for type: transport.TLSConfig
func ptrFromHandle_transport_TLSConfig(h CGoHandle) *transport.TLSConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.TLSConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(transport.TLSConfig{})).(*transport.TLSConfig)
}
func handleFromPtr_transport_TLSConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.TLSConfig", p))
}

// Converters for non-pointer handles for type: flowcontrol.Backoff
func ptrFromHandle_flowcontrol_Backoff(h CGoHandle) *flowcontrol.Backoff {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "flowcontrol.Backoff")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(flowcontrol.Backoff{})).(*flowcontrol.Backoff)
}
func handleFromPtr_flowcontrol_Backoff(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("flowcontrol.Backoff", p))
}

// Converters for pointer handles for type: flowcontrol.RateLimiter
func ptrFromHandle_flowcontrol_RateLimiter(h CGoHandle) flowcontrol.RateLimiter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "flowcontrol.RateLimiter")
	if p == nil {
		return nil
	}
	return p.(flowcontrol.RateLimiter)
}
func handleFromPtr_flowcontrol_RateLimiter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("flowcontrol.RateLimiter", p))
}

// Converters for pointer handles for type: clock.Clock
func ptrFromHandle_clock_Clock(h CGoHandle) clock.Clock {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "clock.Clock")
	if p == nil {
		return nil
	}
	return p.(clock.Clock)
}
func handleFromPtr_clock_Clock(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("clock.Clock", p))
}

// Converters for non-pointer handles for type: big.Int
func ptrFromHandle_big_Int(h CGoHandle) *big.Int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "big.Int")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(big.Int{})).(*big.Int)
}
func handleFromPtr_big_Int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("big.Int", p))
}

// Converters for non-pointer handles for type: rand.Rand
func ptrFromHandle_rand_Rand(h CGoHandle) *rand.Rand {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rand.Rand")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rand.Rand{})).(*rand.Rand)
}
func handleFromPtr_rand_Rand(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rand.Rand", p))
}

// Converters for pointer handles for type: multipart.File
func ptrFromHandle_multipart_File(h CGoHandle) multipart.File {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.File")
	if p == nil {
		return nil
	}
	return p.(multipart.File)
}
func handleFromPtr_multipart_File(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.File", p))
}

// Converters for non-pointer handles for type: multipart.FileHeader
func ptrFromHandle_multipart_FileHeader(h CGoHandle) *multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.FileHeader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.FileHeader{})).(*multipart.FileHeader)
}
func handleFromPtr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.FileHeader", p))
}

// Converters for non-pointer handles for type: multipart.Form
func ptrFromHandle_multipart_Form(h CGoHandle) *multipart.Form {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Form")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Form{})).(*multipart.Form)
}
func handleFromPtr_multipart_Form(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Form", p))
}

// Converters for non-pointer handles for type: multipart.Part
func ptrFromHandle_multipart_Part(h CGoHandle) *multipart.Part {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Part")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Part{})).(*multipart.Part)
}
func handleFromPtr_multipart_Part(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Part", p))
}

// Converters for non-pointer handles for type: multipart.Reader
func ptrFromHandle_multipart_Reader(h CGoHandle) *multipart.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "multipart.Reader")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(multipart.Reader{})).(*multipart.Reader)
}
func handleFromPtr_multipart_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("multipart.Reader", p))
}

// Converters for implicit pointer handles for type: net.IP
func ptrFromHandle_net_IP(h CGoHandle) *net.IP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IP")
	if p == nil {
		return nil
	}
	return p.(*net.IP)
}
func deptrFromHandle_net_IP(h CGoHandle) net.IP {
	p := ptrFromHandle_net_IP(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IP", p))
}

// --- wrapping slice: net.IP ---
//
//export net_IP_CTor
func net_IP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IP(&net.IP{}))
}

//export net_IP_len
func net_IP_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IP(handle))
}

//export net_IP_elem
func net_IP_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IP(handle)
	return C.char(s[_idx])
}

//export net_IP_subslice
func net_IP_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IP(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IP(&ss))
}

//export net_IP_set
func net_IP_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IP(handle)
	s[_idx] = byte(_vl)
}

//export net_IP_append
func net_IP_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IP(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: net.IPMask
func ptrFromHandle_net_IPMask(h CGoHandle) *net.IPMask {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IPMask")
	if p == nil {
		return nil
	}
	return p.(*net.IPMask)
}
func deptrFromHandle_net_IPMask(h CGoHandle) net.IPMask {
	p := ptrFromHandle_net_IPMask(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IPMask(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IPMask", p))
}

// --- wrapping slice: net.IPMask ---
//
//export net_IPMask_CTor
func net_IPMask_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IPMask(&net.IPMask{}))
}

//export net_IPMask_len
func net_IPMask_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IPMask(handle))
}

//export net_IPMask_elem
func net_IPMask_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IPMask(handle)
	return C.char(s[_idx])
}

//export net_IPMask_subslice
func net_IPMask_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IPMask(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IPMask(&ss))
}

//export net_IPMask_set
func net_IPMask_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IPMask(handle)
	s[_idx] = byte(_vl)
}

//export net_IPMask_append
func net_IPMask_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IPMask(handle)
	*s = append(*s, byte(_vl))
}

// Converters for non-pointer handles for type: net.IPNet
func ptrFromHandle_net_IPNet(h CGoHandle) *net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IPNet")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.IPNet{})).(*net.IPNet)
}
func handleFromPtr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IPNet", p))
}

// Converters for non-pointer handles for type: http.Client
func ptrFromHandle_http_Client(h CGoHandle) *http.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Client{})).(*http.Client)
}
func handleFromPtr_http_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Client", p))
}

// Converters for non-pointer handles for type: http.Cookie
func ptrFromHandle_http_Cookie(h CGoHandle) *http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Cookie")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Cookie{})).(*http.Cookie)
}
func handleFromPtr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Cookie", p))
}

// Converters for pointer handles for type: http.CookieJar
func ptrFromHandle_http_CookieJar(h CGoHandle) http.CookieJar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.CookieJar")
	if p == nil {
		return nil
	}
	return p.(http.CookieJar)
}
func handleFromPtr_http_CookieJar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.CookieJar", p))
}

// Converters for implicit pointer handles for type: http.Header
func ptrFromHandle_http_Header(h CGoHandle) *http.Header {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Header")
	if p == nil {
		return nil
	}
	return p.(*http.Header)
}
func deptrFromHandle_http_Header(h CGoHandle) http.Header {
	p := ptrFromHandle_http_Header(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_http_Header(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Header", p))
}

// --- wrapping map: http.Header ---
//
//export http_Header_CTor
func http_Header_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_http_Header(&http.Header{}))
}

//export http_Header_len
func http_Header_len(handle CGoHandle) int {
	return len(deptrFromHandle_http_Header(handle))
}

//export http_Header_elem
func http_Header_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_http_Header(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export http_Header_contains
func http_Header_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_http_Header(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export http_Header_set
func http_Header_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_http_Header(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export http_Header_delete
func http_Header_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_http_Header(handle)
	delete(s, C.GoString(_ky))
}

//export http_Header_keys
func http_Header_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_http_Header(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: http.Request
func ptrFromHandle_http_Request(h CGoHandle) *http.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Request{})).(*http.Request)
}
func handleFromPtr_http_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Request", p))
}

// Converters for non-pointer handles for type: http.Response
func ptrFromHandle_http_Response(h CGoHandle) *http.Response {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.Response")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(http.Response{})).(*http.Response)
}
func handleFromPtr_http_Response(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.Response", p))
}

// Converters for pointer handles for type: http.RoundTripper
func ptrFromHandle_http_RoundTripper(h CGoHandle) http.RoundTripper {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "http.RoundTripper")
	if p == nil {
		return nil
	}
	return p.(http.RoundTripper)
}
func handleFromPtr_http_RoundTripper(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("http.RoundTripper", p))
}

// Converters for implicit pointer handles for type: textproto.MIMEHeader
func ptrFromHandle_textproto_MIMEHeader(h CGoHandle) *textproto.MIMEHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "textproto.MIMEHeader")
	if p == nil {
		return nil
	}
	return p.(*textproto.MIMEHeader)
}
func deptrFromHandle_textproto_MIMEHeader(h CGoHandle) textproto.MIMEHeader {
	p := ptrFromHandle_textproto_MIMEHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_textproto_MIMEHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("textproto.MIMEHeader", p))
}

// --- wrapping map: textproto.MIMEHeader ---
//
//export textproto_MIMEHeader_CTor
func textproto_MIMEHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_textproto_MIMEHeader(&textproto.MIMEHeader{}))
}

//export textproto_MIMEHeader_len
func textproto_MIMEHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_textproto_MIMEHeader(handle))
}

//export textproto_MIMEHeader_elem
func textproto_MIMEHeader_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export textproto_MIMEHeader_contains
func textproto_MIMEHeader_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export textproto_MIMEHeader_set
func textproto_MIMEHeader_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export textproto_MIMEHeader_delete
func textproto_MIMEHeader_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	delete(s, C.GoString(_ky))
}

//export textproto_MIMEHeader_keys
func textproto_MIMEHeader_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_textproto_MIMEHeader(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for non-pointer handles for type: url.URL
func ptrFromHandle_url_URL(h CGoHandle) *url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.URL")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.URL{})).(*url.URL)
}
func handleFromPtr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.URL", p))
}

// Converters for non-pointer handles for type: url.Userinfo
func ptrFromHandle_url_Userinfo(h CGoHandle) *url.Userinfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.Userinfo")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(url.Userinfo{})).(*url.Userinfo)
}
func handleFromPtr_url_Userinfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.Userinfo", p))
}

// Converters for implicit pointer handles for type: url.Values
func ptrFromHandle_url_Values(h CGoHandle) *url.Values {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "url.Values")
	if p == nil {
		return nil
	}
	return p.(*url.Values)
}
func deptrFromHandle_url_Values(h CGoHandle) url.Values {
	p := ptrFromHandle_url_Values(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_url_Values(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("url.Values", p))
}

// --- wrapping map: url.Values ---
//
//export url_Values_CTor
func url_Values_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_url_Values(&url.Values{}))
}

//export url_Values_len
func url_Values_len(handle CGoHandle) int {
	return len(deptrFromHandle_url_Values(handle))
}

//export url_Values_elem
func url_Values_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_url_Values(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export url_Values_contains
func url_Values_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_url_Values(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export url_Values_set
func url_Values_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_url_Values(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export url_Values_delete
func url_Values_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_url_Values(handle)
	delete(s, C.GoString(_ky))
}

//export url_Values_keys
func url_Values_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_url_Values(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for pointer handles for type: reflect.Type
func ptrFromHandle_reflect_Type(h CGoHandle) reflect.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "reflect.Type")
	if p == nil {
		return nil
	}
	return p.(reflect.Type)
}
func handleFromPtr_reflect_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("reflect.Type", p))
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: rest ---

// ---- Types ---

// Converters for pointer handles for type: *rest.ClientContentConfig
func ptrFromHandle_Ptr_rest_ClientContentConfig(h CGoHandle) *rest.ClientContentConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.ClientContentConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.ClientContentConfig{})).(*rest.ClientContentConfig)
}
func handleFromPtr_Ptr_rest_ClientContentConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.ClientContentConfig", p))
}

// Converters for pointer handles for type: *rest.Config
func ptrFromHandle_Ptr_rest_Config(h CGoHandle) *rest.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.Config{})).(*rest.Config)
}
func handleFromPtr_Ptr_rest_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.Config", p))
}

// Converters for pointer handles for type: *rest.ContentConfig
func ptrFromHandle_Ptr_rest_ContentConfig(h CGoHandle) *rest.ContentConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.ContentConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.ContentConfig{})).(*rest.ContentConfig)
}
func handleFromPtr_Ptr_rest_ContentConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.ContentConfig", p))
}

// Converters for pointer handles for type: *rest.ImpersonationConfig
func ptrFromHandle_Ptr_rest_ImpersonationConfig(h CGoHandle) *rest.ImpersonationConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.ImpersonationConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.ImpersonationConfig{})).(*rest.ImpersonationConfig)
}
func handleFromPtr_Ptr_rest_ImpersonationConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.ImpersonationConfig", p))
}

// Converters for pointer handles for type: *rest.NoBackoff
func ptrFromHandle_Ptr_rest_NoBackoff(h CGoHandle) *rest.NoBackoff {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.NoBackoff")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.NoBackoff{})).(*rest.NoBackoff)
}
func handleFromPtr_Ptr_rest_NoBackoff(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.NoBackoff", p))
}

// Converters for pointer handles for type: *rest.NoWarnings
func ptrFromHandle_Ptr_rest_NoWarnings(h CGoHandle) *rest.NoWarnings {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.NoWarnings")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.NoWarnings{})).(*rest.NoWarnings)
}
func handleFromPtr_Ptr_rest_NoWarnings(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.NoWarnings", p))
}

// Converters for pointer handles for type: *rest.RESTClient
func ptrFromHandle_Ptr_rest_RESTClient(h CGoHandle) *rest.RESTClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.RESTClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.RESTClient{})).(*rest.RESTClient)
}
func handleFromPtr_Ptr_rest_RESTClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.RESTClient", p))
}

// Converters for pointer handles for type: *rest.Request
func ptrFromHandle_Ptr_rest_Request(h CGoHandle) *rest.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.Request{})).(*rest.Request)
}
func handleFromPtr_Ptr_rest_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.Request", p))
}

// Converters for pointer handles for type: *rest.RequestConstructionError
func ptrFromHandle_Ptr_rest_RequestConstructionError(h CGoHandle) *rest.RequestConstructionError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.RequestConstructionError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.RequestConstructionError{})).(*rest.RequestConstructionError)
}
func handleFromPtr_Ptr_rest_RequestConstructionError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.RequestConstructionError", p))
}

// Converters for pointer handles for type: *rest.Result
func ptrFromHandle_Ptr_rest_Result(h CGoHandle) *rest.Result {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.Result")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.Result{})).(*rest.Result)
}
func handleFromPtr_Ptr_rest_Result(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.Result", p))
}

// Converters for pointer handles for type: *rest.RetryAfter
func ptrFromHandle_Ptr_rest_RetryAfter(h CGoHandle) *rest.RetryAfter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.RetryAfter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.RetryAfter{})).(*rest.RetryAfter)
}
func handleFromPtr_Ptr_rest_RetryAfter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.RetryAfter", p))
}

// Converters for pointer handles for type: *rest.TLSClientConfig
func ptrFromHandle_Ptr_rest_TLSClientConfig(h CGoHandle) *rest.TLSClientConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.TLSClientConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.TLSClientConfig{})).(*rest.TLSClientConfig)
}
func handleFromPtr_Ptr_rest_TLSClientConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.TLSClientConfig", p))
}

// Converters for pointer handles for type: *rest.URLBackoff
func ptrFromHandle_Ptr_rest_URLBackoff(h CGoHandle) *rest.URLBackoff {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.URLBackoff")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.URLBackoff{})).(*rest.URLBackoff)
}
func handleFromPtr_Ptr_rest_URLBackoff(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.URLBackoff", p))
}

// Converters for pointer handles for type: *rest.WarningLogger
func ptrFromHandle_Ptr_rest_WarningLogger(h CGoHandle) *rest.WarningLogger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.WarningLogger")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.WarningLogger{})).(*rest.WarningLogger)
}
func handleFromPtr_Ptr_rest_WarningLogger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.WarningLogger", p))
}

// Converters for pointer handles for type: *rest.WarningWriterOptions
func ptrFromHandle_Ptr_rest_WarningWriterOptions(h CGoHandle) *rest.WarningWriterOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.WarningWriterOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.WarningWriterOptions{})).(*rest.WarningWriterOptions)
}
func handleFromPtr_Ptr_rest_WarningWriterOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.WarningWriterOptions", p))
}

// Converters for pointer handles for type: *rest.WatchListResult
func ptrFromHandle_Ptr_rest_WatchListResult(h CGoHandle) *rest.WatchListResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*rest.WatchListResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.WatchListResult{})).(*rest.WatchListResult)
}
func handleFromPtr_Ptr_rest_WatchListResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*rest.WatchListResult", p))
}

// Converters for implicit pointer handles for type: [32]byte
func ptrFromHandle_Array_32_byte(h CGoHandle) *[32]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[32]byte")
	if p == nil {
		return nil
	}
	return p.(*[32]byte)
}
func deptrFromHandle_Array_32_byte(h CGoHandle) [32]byte {
	p := ptrFromHandle_Array_32_byte(h)
	return *p
}
func handleFromPtr_Array_32_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[32]byte", p))
}

// --- wrapping slice: [32]byte ---
//
//export Array_32_byte_CTor
func Array_32_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_32_byte(&[32]byte{}))
}

//export Array_32_byte_len
func Array_32_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_32_byte(handle))
}

//export Array_32_byte_elem
func Array_32_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Array_32_byte(handle)
	return C.char(s[_idx])
}

//export Array_32_byte_set
func Array_32_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Array_32_byte(handle)
	s[_idx] = byte(_vl)
}

// Converters for implicit pointer handles for type: []*x509.Certificate
func ptrFromHandle_Slice_Ptr_x509_Certificate(h CGoHandle) *[]*x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*x509.Certificate")
	if p == nil {
		return nil
	}
	return p.(*[]*x509.Certificate)
}
func deptrFromHandle_Slice_Ptr_x509_Certificate(h CGoHandle) []*x509.Certificate {
	p := ptrFromHandle_Slice_Ptr_x509_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*x509.Certificate", p))
}

// --- wrapping slice: []*x509.Certificate ---
//
//export Slice_Ptr_x509_Certificate_CTor
func Slice_Ptr_x509_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_x509_Certificate(&[]*x509.Certificate{}))
}

//export Slice_Ptr_x509_Certificate_len
func Slice_Ptr_x509_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_x509_Certificate(handle))
}

//export Slice_Ptr_x509_Certificate_elem
func Slice_Ptr_x509_Certificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	return handleFromPtr_Ptr_x509_Certificate(&(s[_idx]))
}

//export Slice_Ptr_x509_Certificate_subslice
func Slice_Ptr_x509_Certificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_x509_Certificate(&ss))
}

//export Slice_Ptr_x509_Certificate_set
func Slice_Ptr_x509_Certificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	s[_idx] = ptrFromHandle_Ptr_x509_Certificate(_vl)
}

//export Slice_Ptr_x509_Certificate_append
func Slice_Ptr_x509_Certificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_x509_Certificate(handle)
	*s = append(*s, ptrFromHandle_Ptr_x509_Certificate(_vl))
}

// Converters for implicit pointer handles for type: []*multipart.FileHeader
func ptrFromHandle_Slice_Ptr_multipart_FileHeader(h CGoHandle) *[]*multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return p.(*[]*multipart.FileHeader)
}
func deptrFromHandle_Slice_Ptr_multipart_FileHeader(h CGoHandle) []*multipart.FileHeader {
	p := ptrFromHandle_Slice_Ptr_multipart_FileHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*multipart.FileHeader", p))
}

// --- wrapping slice: []*multipart.FileHeader ---
//
//export Slice_Ptr_multipart_FileHeader_CTor
func Slice_Ptr_multipart_FileHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_multipart_FileHeader(&[]*multipart.FileHeader{}))
}

//export Slice_Ptr_multipart_FileHeader_len
func Slice_Ptr_multipart_FileHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle))
}

//export Slice_Ptr_multipart_FileHeader_elem
func Slice_Ptr_multipart_FileHeader_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	return handleFromPtr_Ptr_multipart_FileHeader(&(s[_idx]))
}

//export Slice_Ptr_multipart_FileHeader_subslice
func Slice_Ptr_multipart_FileHeader_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_multipart_FileHeader(&ss))
}

//export Slice_Ptr_multipart_FileHeader_set
func Slice_Ptr_multipart_FileHeader_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	s[_idx] = ptrFromHandle_Ptr_multipart_FileHeader(_vl)
}

//export Slice_Ptr_multipart_FileHeader_append
func Slice_Ptr_multipart_FileHeader_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_multipart_FileHeader(handle)
	*s = append(*s, ptrFromHandle_Ptr_multipart_FileHeader(_vl))
}

// Converters for implicit pointer handles for type: []*net.IPNet
func ptrFromHandle_Slice_Ptr_net_IPNet(h CGoHandle) *[]*net.IPNet {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*net.IPNet")
	if p == nil {
		return nil
	}
	return p.(*[]*net.IPNet)
}
func deptrFromHandle_Slice_Ptr_net_IPNet(h CGoHandle) []*net.IPNet {
	p := ptrFromHandle_Slice_Ptr_net_IPNet(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_net_IPNet(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*net.IPNet", p))
}

// --- wrapping slice: []*net.IPNet ---
//
//export Slice_Ptr_net_IPNet_CTor
func Slice_Ptr_net_IPNet_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_net_IPNet(&[]*net.IPNet{}))
}

//export Slice_Ptr_net_IPNet_len
func Slice_Ptr_net_IPNet_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_net_IPNet(handle))
}

//export Slice_Ptr_net_IPNet_elem
func Slice_Ptr_net_IPNet_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	return handleFromPtr_Ptr_net_IPNet(&(s[_idx]))
}

//export Slice_Ptr_net_IPNet_subslice
func Slice_Ptr_net_IPNet_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_net_IPNet(&ss))
}

//export Slice_Ptr_net_IPNet_set
func Slice_Ptr_net_IPNet_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_net_IPNet(handle)
	s[_idx] = ptrFromHandle_Ptr_net_IPNet(_vl)
}

//export Slice_Ptr_net_IPNet_append
func Slice_Ptr_net_IPNet_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_net_IPNet(handle)
	*s = append(*s, ptrFromHandle_Ptr_net_IPNet(_vl))
}

// Converters for implicit pointer handles for type: []*http.Cookie
func ptrFromHandle_Slice_Ptr_http_Cookie(h CGoHandle) *[]*http.Cookie {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*http.Cookie")
	if p == nil {
		return nil
	}
	return p.(*[]*http.Cookie)
}
func deptrFromHandle_Slice_Ptr_http_Cookie(h CGoHandle) []*http.Cookie {
	p := ptrFromHandle_Slice_Ptr_http_Cookie(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_http_Cookie(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*http.Cookie", p))
}

// --- wrapping slice: []*http.Cookie ---
//
//export Slice_Ptr_http_Cookie_CTor
func Slice_Ptr_http_Cookie_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_http_Cookie(&[]*http.Cookie{}))
}

//export Slice_Ptr_http_Cookie_len
func Slice_Ptr_http_Cookie_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_http_Cookie(handle))
}

//export Slice_Ptr_http_Cookie_elem
func Slice_Ptr_http_Cookie_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	return handleFromPtr_Ptr_http_Cookie(&(s[_idx]))
}

//export Slice_Ptr_http_Cookie_subslice
func Slice_Ptr_http_Cookie_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_http_Cookie(&ss))
}

//export Slice_Ptr_http_Cookie_set
func Slice_Ptr_http_Cookie_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_http_Cookie(handle)
	s[_idx] = ptrFromHandle_Ptr_http_Cookie(_vl)
}

//export Slice_Ptr_http_Cookie_append
func Slice_Ptr_http_Cookie_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_http_Cookie(handle)
	*s = append(*s, ptrFromHandle_Ptr_http_Cookie(_vl))
}

// Converters for implicit pointer handles for type: []*url.URL
func ptrFromHandle_Slice_Ptr_url_URL(h CGoHandle) *[]*url.URL {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*url.URL")
	if p == nil {
		return nil
	}
	return p.(*[]*url.URL)
}
func deptrFromHandle_Slice_Ptr_url_URL(h CGoHandle) []*url.URL {
	p := ptrFromHandle_Slice_Ptr_url_URL(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_url_URL(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*url.URL", p))
}

// --- wrapping slice: []*url.URL ---
//
//export Slice_Ptr_url_URL_CTor
func Slice_Ptr_url_URL_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_url_URL(&[]*url.URL{}))
}

//export Slice_Ptr_url_URL_len
func Slice_Ptr_url_URL_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_url_URL(handle))
}

//export Slice_Ptr_url_URL_elem
func Slice_Ptr_url_URL_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	return handleFromPtr_Ptr_url_URL(&(s[_idx]))
}

//export Slice_Ptr_url_URL_subslice
func Slice_Ptr_url_URL_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_url_URL(&ss))
}

//export Slice_Ptr_url_URL_set
func Slice_Ptr_url_URL_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_url_URL(handle)
	s[_idx] = ptrFromHandle_Ptr_url_URL(_vl)
}

//export Slice_Ptr_url_URL_append
func Slice_Ptr_url_URL_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_url_URL(handle)
	*s = append(*s, ptrFromHandle_Ptr_url_URL(_vl))
}

// Converters for implicit pointer handles for type: [][32]byte
func ptrFromHandle_Slice__32_byte(h CGoHandle) *[][32]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][32]byte")
	if p == nil {
		return nil
	}
	return p.(*[][32]byte)
}
func deptrFromHandle_Slice__32_byte(h CGoHandle) [][32]byte {
	p := ptrFromHandle_Slice__32_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice__32_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][32]byte", p))
}

// --- wrapping slice: [][32]byte ---
//
//export Slice__32_byte_CTor
func Slice__32_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice__32_byte(&[][32]byte{}))
}

//export Slice__32_byte_len
func Slice__32_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice__32_byte(handle))
}

//export Slice__32_byte_elem
func Slice__32_byte_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice__32_byte(handle)
	return handleFromPtr_Array_32_byte(&(s[_idx]))
}

//export Slice__32_byte_subslice
func Slice__32_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice__32_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice__32_byte(&ss))
}

//export Slice__32_byte_set
func Slice__32_byte_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice__32_byte(handle)
	s[_idx] = deptrFromHandle_Array_32_byte(_vl)
}

//export Slice__32_byte_append
func Slice__32_byte_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice__32_byte(handle)
	*s = append(*s, deptrFromHandle_Array_32_byte(_vl))
}

// Converters for implicit pointer handles for type: [][]*x509.Certificate
func ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h CGoHandle) *[][]*x509.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]*x509.Certificate")
	if p == nil {
		return nil
	}
	return p.(*[][]*x509.Certificate)
}
func deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h CGoHandle) [][]*x509.Certificate {
	p := ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_Ptr_x509_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]*x509.Certificate", p))
}

// --- wrapping slice: [][]*x509.Certificate ---
//
//export Slice_Slice_Ptr_x509_Certificate_CTor
func Slice_Slice_Ptr_x509_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_Ptr_x509_Certificate(&[][]*x509.Certificate{}))
}

//export Slice_Slice_Ptr_x509_Certificate_len
func Slice_Slice_Ptr_x509_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle))
}

//export Slice_Slice_Ptr_x509_Certificate_elem
func Slice_Slice_Ptr_x509_Certificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	return handleFromPtr_Slice_Ptr_x509_Certificate(&(s[_idx]))
}

//export Slice_Slice_Ptr_x509_Certificate_subslice
func Slice_Slice_Ptr_x509_Certificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_Ptr_x509_Certificate(&ss))
}

//export Slice_Slice_Ptr_x509_Certificate_set
func Slice_Slice_Ptr_x509_Certificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	s[_idx] = deptrFromHandle_Slice_Ptr_x509_Certificate(_vl)
}

//export Slice_Slice_Ptr_x509_Certificate_append
func Slice_Slice_Ptr_x509_Certificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_Ptr_x509_Certificate(handle)
	*s = append(*s, deptrFromHandle_Slice_Ptr_x509_Certificate(_vl))
}

// Converters for implicit pointer handles for type: [][]byte
func ptrFromHandle_Slice_Slice_byte(h CGoHandle) *[][]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[][]byte")
	if p == nil {
		return nil
	}
	return p.(*[][]byte)
}
func deptrFromHandle_Slice_Slice_byte(h CGoHandle) [][]byte {
	p := ptrFromHandle_Slice_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[][]byte", p))
}

// --- wrapping slice: [][]byte ---
//
//export Slice_Slice_byte_CTor
func Slice_Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&[][]byte{}))
}

//export Slice_Slice_byte_len
func Slice_Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Slice_byte(handle))
}

//export Slice_Slice_byte_elem
func Slice_Slice_byte_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	return handleFromPtr_Slice_byte(&(s[_idx]))
}

//export Slice_Slice_byte_subslice
func Slice_Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Slice_byte(&ss))
}

//export Slice_Slice_byte_set
func Slice_Slice_byte_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Slice_byte(handle)
	s[_idx] = deptrFromHandle_Slice_byte(_vl)
}

//export Slice_Slice_byte_append
func Slice_Slice_byte_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Slice_byte(handle)
	*s = append(*s, deptrFromHandle_Slice_byte(_vl))
}

// Converters for implicit pointer handles for type: []tls.Certificate
func ptrFromHandle_Slice_tls_Certificate(h CGoHandle) *[]tls.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]tls.Certificate")
	if p == nil {
		return nil
	}
	return p.(*[]tls.Certificate)
}
func deptrFromHandle_Slice_tls_Certificate(h CGoHandle) []tls.Certificate {
	p := ptrFromHandle_Slice_tls_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_tls_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]tls.Certificate", p))
}

// --- wrapping slice: []tls.Certificate ---
//
//export Slice_tls_Certificate_CTor
func Slice_tls_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_tls_Certificate(&[]tls.Certificate{}))
}

//export Slice_tls_Certificate_len
func Slice_tls_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_tls_Certificate(handle))
}

//export Slice_tls_Certificate_elem
func Slice_tls_Certificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_tls_Certificate(handle)
	return handleFromPtr_tls_Certificate(&(s[_idx]))
}

//export Slice_tls_Certificate_subslice
func Slice_tls_Certificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_tls_Certificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_tls_Certificate(&ss))
}

//export Slice_tls_Certificate_set
func Slice_tls_Certificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_tls_Certificate(handle)
	s[_idx] = *ptrFromHandle_tls_Certificate(_vl)
}

//export Slice_tls_Certificate_append
func Slice_tls_Certificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_tls_Certificate(handle)
	*s = append(*s, *ptrFromHandle_tls_Certificate(_vl))
}

// Converters for implicit pointer handles for type: []tls.CurveID
func ptrFromHandle_Slice_tls_CurveID(h CGoHandle) *[]tls.CurveID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]tls.CurveID")
	if p == nil {
		return nil
	}
	return p.(*[]tls.CurveID)
}
func deptrFromHandle_Slice_tls_CurveID(h CGoHandle) []tls.CurveID {
	p := ptrFromHandle_Slice_tls_CurveID(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_tls_CurveID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]tls.CurveID", p))
}

// --- wrapping slice: []tls.CurveID ---
//
//export Slice_tls_CurveID_CTor
func Slice_tls_CurveID_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_tls_CurveID(&[]tls.CurveID{}))
}

//export Slice_tls_CurveID_len
func Slice_tls_CurveID_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_tls_CurveID(handle))
}

//export Slice_tls_CurveID_elem
func Slice_tls_CurveID_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_tls_CurveID(handle)
	return C.ushort(uint16(s[_idx]))
}

//export Slice_tls_CurveID_subslice
func Slice_tls_CurveID_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_tls_CurveID(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_tls_CurveID(&ss))
}

//export Slice_tls_CurveID_set
func Slice_tls_CurveID_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_tls_CurveID(handle)
	s[_idx] = tls.CurveID(uint16(_vl))
}

//export Slice_tls_CurveID_append
func Slice_tls_CurveID_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_tls_CurveID(handle)
	*s = append(*s, tls.CurveID(uint16(_vl)))
}

// Converters for implicit pointer handles for type: []tls.SignatureScheme
func ptrFromHandle_Slice_tls_SignatureScheme(h CGoHandle) *[]tls.SignatureScheme {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]tls.SignatureScheme")
	if p == nil {
		return nil
	}
	return p.(*[]tls.SignatureScheme)
}
func deptrFromHandle_Slice_tls_SignatureScheme(h CGoHandle) []tls.SignatureScheme {
	p := ptrFromHandle_Slice_tls_SignatureScheme(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_tls_SignatureScheme(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]tls.SignatureScheme", p))
}

// --- wrapping slice: []tls.SignatureScheme ---
//
//export Slice_tls_SignatureScheme_CTor
func Slice_tls_SignatureScheme_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_tls_SignatureScheme(&[]tls.SignatureScheme{}))
}

//export Slice_tls_SignatureScheme_len
func Slice_tls_SignatureScheme_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_tls_SignatureScheme(handle))
}

//export Slice_tls_SignatureScheme_elem
func Slice_tls_SignatureScheme_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_tls_SignatureScheme(handle)
	return C.ushort(uint16(s[_idx]))
}

//export Slice_tls_SignatureScheme_subslice
func Slice_tls_SignatureScheme_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_tls_SignatureScheme(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_tls_SignatureScheme(&ss))
}

//export Slice_tls_SignatureScheme_set
func Slice_tls_SignatureScheme_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_tls_SignatureScheme(handle)
	s[_idx] = tls.SignatureScheme(uint16(_vl))
}

//export Slice_tls_SignatureScheme_append
func Slice_tls_SignatureScheme_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_tls_SignatureScheme(handle)
	*s = append(*s, tls.SignatureScheme(uint16(_vl)))
}

// Converters for implicit pointer handles for type: []x509.ExtKeyUsage
func ptrFromHandle_Slice_x509_ExtKeyUsage(h CGoHandle) *[]x509.ExtKeyUsage {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]x509.ExtKeyUsage")
	if p == nil {
		return nil
	}
	return p.(*[]x509.ExtKeyUsage)
}
func deptrFromHandle_Slice_x509_ExtKeyUsage(h CGoHandle) []x509.ExtKeyUsage {
	p := ptrFromHandle_Slice_x509_ExtKeyUsage(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_x509_ExtKeyUsage(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]x509.ExtKeyUsage", p))
}

// --- wrapping slice: []x509.ExtKeyUsage ---
//
//export Slice_x509_ExtKeyUsage_CTor
func Slice_x509_ExtKeyUsage_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_x509_ExtKeyUsage(&[]x509.ExtKeyUsage{}))
}

//export Slice_x509_ExtKeyUsage_len
func Slice_x509_ExtKeyUsage_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_x509_ExtKeyUsage(handle))
}

//export Slice_x509_ExtKeyUsage_elem
func Slice_x509_ExtKeyUsage_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	return C.longlong(int(s[_idx]))
}

//export Slice_x509_ExtKeyUsage_subslice
func Slice_x509_ExtKeyUsage_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_x509_ExtKeyUsage(&ss))
}

//export Slice_x509_ExtKeyUsage_set
func Slice_x509_ExtKeyUsage_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	s[_idx] = x509.ExtKeyUsage(int(_vl))
}

//export Slice_x509_ExtKeyUsage_append
func Slice_x509_ExtKeyUsage_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_x509_ExtKeyUsage(handle)
	*s = append(*s, x509.ExtKeyUsage(int(_vl)))
}

// Converters for implicit pointer handles for type: []x509.OID
func ptrFromHandle_Slice_x509_OID(h CGoHandle) *[]x509.OID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]x509.OID")
	if p == nil {
		return nil
	}
	return p.(*[]x509.OID)
}
func deptrFromHandle_Slice_x509_OID(h CGoHandle) []x509.OID {
	p := ptrFromHandle_Slice_x509_OID(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_x509_OID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]x509.OID", p))
}

// --- wrapping slice: []x509.OID ---
//
//export Slice_x509_OID_CTor
func Slice_x509_OID_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_x509_OID(&[]x509.OID{}))
}

//export Slice_x509_OID_len
func Slice_x509_OID_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_x509_OID(handle))
}

//export Slice_x509_OID_elem
func Slice_x509_OID_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_x509_OID(handle)
	return handleFromPtr_x509_OID(&(s[_idx]))
}

//export Slice_x509_OID_subslice
func Slice_x509_OID_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_x509_OID(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_x509_OID(&ss))
}

//export Slice_x509_OID_set
func Slice_x509_OID_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_x509_OID(handle)
	s[_idx] = *ptrFromHandle_x509_OID(_vl)
}

//export Slice_x509_OID_append
func Slice_x509_OID_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_x509_OID(handle)
	*s = append(*s, *ptrFromHandle_x509_OID(_vl))
}

// Converters for implicit pointer handles for type: []pkix.AttributeTypeAndValue
func ptrFromHandle_Slice_pkix_AttributeTypeAndValue(h CGoHandle) *[]pkix.AttributeTypeAndValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.AttributeTypeAndValue")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.AttributeTypeAndValue)
}
func deptrFromHandle_Slice_pkix_AttributeTypeAndValue(h CGoHandle) []pkix.AttributeTypeAndValue {
	p := ptrFromHandle_Slice_pkix_AttributeTypeAndValue(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_AttributeTypeAndValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.AttributeTypeAndValue", p))
}

// --- wrapping slice: []pkix.AttributeTypeAndValue ---
//
//export Slice_pkix_AttributeTypeAndValue_CTor
func Slice_pkix_AttributeTypeAndValue_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_AttributeTypeAndValue(&[]pkix.AttributeTypeAndValue{}))
}

//export Slice_pkix_AttributeTypeAndValue_len
func Slice_pkix_AttributeTypeAndValue_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle))
}

//export Slice_pkix_AttributeTypeAndValue_elem
func Slice_pkix_AttributeTypeAndValue_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	return handleFromPtr_pkix_AttributeTypeAndValue(&(s[_idx]))
}

//export Slice_pkix_AttributeTypeAndValue_subslice
func Slice_pkix_AttributeTypeAndValue_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_AttributeTypeAndValue(&ss))
}

//export Slice_pkix_AttributeTypeAndValue_set
func Slice_pkix_AttributeTypeAndValue_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	s[_idx] = *ptrFromHandle_pkix_AttributeTypeAndValue(_vl)
}

//export Slice_pkix_AttributeTypeAndValue_append
func Slice_pkix_AttributeTypeAndValue_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_AttributeTypeAndValue(handle)
	*s = append(*s, *ptrFromHandle_pkix_AttributeTypeAndValue(_vl))
}

// Converters for implicit pointer handles for type: []pkix.Extension
func ptrFromHandle_Slice_pkix_Extension(h CGoHandle) *[]pkix.Extension {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.Extension")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.Extension)
}
func deptrFromHandle_Slice_pkix_Extension(h CGoHandle) []pkix.Extension {
	p := ptrFromHandle_Slice_pkix_Extension(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_Extension(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.Extension", p))
}

// --- wrapping slice: []pkix.Extension ---
//
//export Slice_pkix_Extension_CTor
func Slice_pkix_Extension_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_Extension(&[]pkix.Extension{}))
}

//export Slice_pkix_Extension_len
func Slice_pkix_Extension_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_Extension(handle))
}

//export Slice_pkix_Extension_elem
func Slice_pkix_Extension_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	return handleFromPtr_pkix_Extension(&(s[_idx]))
}

//export Slice_pkix_Extension_subslice
func Slice_pkix_Extension_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_Extension(&ss))
}

//export Slice_pkix_Extension_set
func Slice_pkix_Extension_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_Extension(handle)
	s[_idx] = *ptrFromHandle_pkix_Extension(_vl)
}

//export Slice_pkix_Extension_append
func Slice_pkix_Extension_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_Extension(handle)
	*s = append(*s, *ptrFromHandle_pkix_Extension(_vl))
}

// Converters for implicit pointer handles for type: []pkix.RevokedCertificate
func ptrFromHandle_Slice_pkix_RevokedCertificate(h CGoHandle) *[]pkix.RevokedCertificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]pkix.RevokedCertificate")
	if p == nil {
		return nil
	}
	return p.(*[]pkix.RevokedCertificate)
}
func deptrFromHandle_Slice_pkix_RevokedCertificate(h CGoHandle) []pkix.RevokedCertificate {
	p := ptrFromHandle_Slice_pkix_RevokedCertificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_pkix_RevokedCertificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]pkix.RevokedCertificate", p))
}

// --- wrapping slice: []pkix.RevokedCertificate ---
//
//export Slice_pkix_RevokedCertificate_CTor
func Slice_pkix_RevokedCertificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_pkix_RevokedCertificate(&[]pkix.RevokedCertificate{}))
}

//export Slice_pkix_RevokedCertificate_len
func Slice_pkix_RevokedCertificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_pkix_RevokedCertificate(handle))
}

//export Slice_pkix_RevokedCertificate_elem
func Slice_pkix_RevokedCertificate_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	return handleFromPtr_pkix_RevokedCertificate(&(s[_idx]))
}

//export Slice_pkix_RevokedCertificate_subslice
func Slice_pkix_RevokedCertificate_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_pkix_RevokedCertificate(&ss))
}

//export Slice_pkix_RevokedCertificate_set
func Slice_pkix_RevokedCertificate_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	s[_idx] = *ptrFromHandle_pkix_RevokedCertificate(_vl)
}

//export Slice_pkix_RevokedCertificate_append
func Slice_pkix_RevokedCertificate_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_pkix_RevokedCertificate(handle)
	*s = append(*s, *ptrFromHandle_pkix_RevokedCertificate(_vl))
}

// Converters for implicit pointer handles for type: []asn1.ObjectIdentifier
func ptrFromHandle_Slice_asn1_ObjectIdentifier(h CGoHandle) *[]asn1.ObjectIdentifier {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]asn1.ObjectIdentifier")
	if p == nil {
		return nil
	}
	return p.(*[]asn1.ObjectIdentifier)
}
func deptrFromHandle_Slice_asn1_ObjectIdentifier(h CGoHandle) []asn1.ObjectIdentifier {
	p := ptrFromHandle_Slice_asn1_ObjectIdentifier(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_asn1_ObjectIdentifier(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]asn1.ObjectIdentifier", p))
}

// --- wrapping slice: []asn1.ObjectIdentifier ---
//
//export Slice_asn1_ObjectIdentifier_CTor
func Slice_asn1_ObjectIdentifier_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_asn1_ObjectIdentifier(&[]asn1.ObjectIdentifier{}))
}

//export Slice_asn1_ObjectIdentifier_len
func Slice_asn1_ObjectIdentifier_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_asn1_ObjectIdentifier(handle))
}

//export Slice_asn1_ObjectIdentifier_elem
func Slice_asn1_ObjectIdentifier_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	return handleFromPtr_asn1_ObjectIdentifier(&(s[_idx]))
}

//export Slice_asn1_ObjectIdentifier_subslice
func Slice_asn1_ObjectIdentifier_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_asn1_ObjectIdentifier(&ss))
}

//export Slice_asn1_ObjectIdentifier_set
func Slice_asn1_ObjectIdentifier_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	s[_idx] = deptrFromHandle_asn1_ObjectIdentifier(_vl)
}

//export Slice_asn1_ObjectIdentifier_append
func Slice_asn1_ObjectIdentifier_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_asn1_ObjectIdentifier(handle)
	*s = append(*s, deptrFromHandle_asn1_ObjectIdentifier(_vl))
}

// Converters for implicit pointer handles for type: []runtime.Object
func ptrFromHandle_Slice_runtime_Object(h CGoHandle) *[]runtime.Object {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]runtime.Object")
	if p == nil {
		return nil
	}
	return p.(*[]runtime.Object)
}
func deptrFromHandle_Slice_runtime_Object(h CGoHandle) []runtime.Object {
	p := ptrFromHandle_Slice_runtime_Object(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_runtime_Object(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]runtime.Object", p))
}

// --- wrapping slice: []runtime.Object ---
//
//export Slice_runtime_Object_CTor
func Slice_runtime_Object_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_runtime_Object(&[]runtime.Object{}))
}

//export Slice_runtime_Object_len
func Slice_runtime_Object_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_runtime_Object(handle))
}

//export Slice_runtime_Object_elem
func Slice_runtime_Object_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_runtime_Object(handle)
	return handleFromPtr_runtime_Object(&(s[_idx]))
}

//export Slice_runtime_Object_subslice
func Slice_runtime_Object_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_runtime_Object(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_runtime_Object(&ss))
}

//export Slice_runtime_Object_set
func Slice_runtime_Object_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_runtime_Object(handle)
	s[_idx] = ptrFromHandle_runtime_Object(_vl)
}

//export Slice_runtime_Object_append
func Slice_runtime_Object_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_runtime_Object(handle)
	*s = append(*s, ptrFromHandle_runtime_Object(_vl))
}

// Converters for implicit pointer handles for type: []runtime.SerializerInfo
func ptrFromHandle_Slice_runtime_SerializerInfo(h CGoHandle) *[]runtime.SerializerInfo {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]runtime.SerializerInfo")
	if p == nil {
		return nil
	}
	return p.(*[]runtime.SerializerInfo)
}
func deptrFromHandle_Slice_runtime_SerializerInfo(h CGoHandle) []runtime.SerializerInfo {
	p := ptrFromHandle_Slice_runtime_SerializerInfo(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_runtime_SerializerInfo(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]runtime.SerializerInfo", p))
}

// --- wrapping slice: []runtime.SerializerInfo ---
//
//export Slice_runtime_SerializerInfo_CTor
func Slice_runtime_SerializerInfo_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_runtime_SerializerInfo(&[]runtime.SerializerInfo{}))
}

//export Slice_runtime_SerializerInfo_len
func Slice_runtime_SerializerInfo_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_runtime_SerializerInfo(handle))
}

//export Slice_runtime_SerializerInfo_elem
func Slice_runtime_SerializerInfo_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_runtime_SerializerInfo(handle)
	return handleFromPtr_runtime_SerializerInfo(&(s[_idx]))
}

//export Slice_runtime_SerializerInfo_subslice
func Slice_runtime_SerializerInfo_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_runtime_SerializerInfo(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_runtime_SerializerInfo(&ss))
}

//export Slice_runtime_SerializerInfo_set
func Slice_runtime_SerializerInfo_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_runtime_SerializerInfo(handle)
	s[_idx] = *ptrFromHandle_runtime_SerializerInfo(_vl)
}

//export Slice_runtime_SerializerInfo_append
func Slice_runtime_SerializerInfo_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_runtime_SerializerInfo(handle)
	*s = append(*s, *ptrFromHandle_runtime_SerializerInfo(_vl))
}

// Converters for implicit pointer handles for type: []schema.GroupVersion
func ptrFromHandle_Slice_schema_GroupVersion(h CGoHandle) *[]schema.GroupVersion {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]schema.GroupVersion")
	if p == nil {
		return nil
	}
	return p.(*[]schema.GroupVersion)
}
func deptrFromHandle_Slice_schema_GroupVersion(h CGoHandle) []schema.GroupVersion {
	p := ptrFromHandle_Slice_schema_GroupVersion(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_schema_GroupVersion(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]schema.GroupVersion", p))
}

// --- wrapping slice: []schema.GroupVersion ---
//
//export Slice_schema_GroupVersion_CTor
func Slice_schema_GroupVersion_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersion(&[]schema.GroupVersion{}))
}

//export Slice_schema_GroupVersion_len
func Slice_schema_GroupVersion_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_schema_GroupVersion(handle))
}

//export Slice_schema_GroupVersion_elem
func Slice_schema_GroupVersion_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersion(handle)
	return handleFromPtr_schema_GroupVersion(&(s[_idx]))
}

//export Slice_schema_GroupVersion_subslice
func Slice_schema_GroupVersion_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersion(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersion(&ss))
}

//export Slice_schema_GroupVersion_set
func Slice_schema_GroupVersion_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_schema_GroupVersion(handle)
	s[_idx] = *ptrFromHandle_schema_GroupVersion(_vl)
}

//export Slice_schema_GroupVersion_append
func Slice_schema_GroupVersion_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_schema_GroupVersion(handle)
	*s = append(*s, *ptrFromHandle_schema_GroupVersion(_vl))
}

// Converters for implicit pointer handles for type: []schema.GroupVersionKind
func ptrFromHandle_Slice_schema_GroupVersionKind(h CGoHandle) *[]schema.GroupVersionKind {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]schema.GroupVersionKind")
	if p == nil {
		return nil
	}
	return p.(*[]schema.GroupVersionKind)
}
func deptrFromHandle_Slice_schema_GroupVersionKind(h CGoHandle) []schema.GroupVersionKind {
	p := ptrFromHandle_Slice_schema_GroupVersionKind(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_schema_GroupVersionKind(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]schema.GroupVersionKind", p))
}

// --- wrapping slice: []schema.GroupVersionKind ---
//
//export Slice_schema_GroupVersionKind_CTor
func Slice_schema_GroupVersionKind_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersionKind(&[]schema.GroupVersionKind{}))
}

//export Slice_schema_GroupVersionKind_len
func Slice_schema_GroupVersionKind_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_schema_GroupVersionKind(handle))
}

//export Slice_schema_GroupVersionKind_elem
func Slice_schema_GroupVersionKind_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersionKind(handle)
	return handleFromPtr_schema_GroupVersionKind(&(s[_idx]))
}

//export Slice_schema_GroupVersionKind_subslice
func Slice_schema_GroupVersionKind_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_schema_GroupVersionKind(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_schema_GroupVersionKind(&ss))
}

//export Slice_schema_GroupVersionKind_set
func Slice_schema_GroupVersionKind_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_schema_GroupVersionKind(handle)
	s[_idx] = *ptrFromHandle_schema_GroupVersionKind(_vl)
}

//export Slice_schema_GroupVersionKind_append
func Slice_schema_GroupVersionKind_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_schema_GroupVersionKind(handle)
	*s = append(*s, *ptrFromHandle_schema_GroupVersionKind(_vl))
}

// Converters for implicit pointer handles for type: []s1_net.WarningHeader
func ptrFromHandle_Slice_s1_net_WarningHeader(h CGoHandle) *[]s1_net.WarningHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]s1_net.WarningHeader")
	if p == nil {
		return nil
	}
	return p.(*[]s1_net.WarningHeader)
}
func deptrFromHandle_Slice_s1_net_WarningHeader(h CGoHandle) []s1_net.WarningHeader {
	p := ptrFromHandle_Slice_s1_net_WarningHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_s1_net_WarningHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]s1_net.WarningHeader", p))
}

// --- wrapping slice: []s1_net.WarningHeader ---
//
//export Slice_s1_net_WarningHeader_CTor
func Slice_s1_net_WarningHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_s1_net_WarningHeader(&[]s1_net.WarningHeader{}))
}

//export Slice_s1_net_WarningHeader_len
func Slice_s1_net_WarningHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_s1_net_WarningHeader(handle))
}

//export Slice_s1_net_WarningHeader_elem
func Slice_s1_net_WarningHeader_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_s1_net_WarningHeader(handle)
	return handleFromPtr_s1_net_WarningHeader(&(s[_idx]))
}

//export Slice_s1_net_WarningHeader_subslice
func Slice_s1_net_WarningHeader_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_s1_net_WarningHeader(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_s1_net_WarningHeader(&ss))
}

//export Slice_s1_net_WarningHeader_set
func Slice_s1_net_WarningHeader_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_s1_net_WarningHeader(handle)
	s[_idx] = *ptrFromHandle_s1_net_WarningHeader(_vl)
}

//export Slice_s1_net_WarningHeader_append
func Slice_s1_net_WarningHeader_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_s1_net_WarningHeader(handle)
	*s = append(*s, *ptrFromHandle_s1_net_WarningHeader(_vl))
}

// Converters for implicit pointer handles for type: []api.ExecEnvVar
func ptrFromHandle_Slice_api_ExecEnvVar(h CGoHandle) *[]api.ExecEnvVar {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]api.ExecEnvVar")
	if p == nil {
		return nil
	}
	return p.(*[]api.ExecEnvVar)
}
func deptrFromHandle_Slice_api_ExecEnvVar(h CGoHandle) []api.ExecEnvVar {
	p := ptrFromHandle_Slice_api_ExecEnvVar(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_api_ExecEnvVar(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]api.ExecEnvVar", p))
}

// --- wrapping slice: []api.ExecEnvVar ---
//
//export Slice_api_ExecEnvVar_CTor
func Slice_api_ExecEnvVar_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_api_ExecEnvVar(&[]api.ExecEnvVar{}))
}

//export Slice_api_ExecEnvVar_len
func Slice_api_ExecEnvVar_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_api_ExecEnvVar(handle))
}

//export Slice_api_ExecEnvVar_elem
func Slice_api_ExecEnvVar_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_api_ExecEnvVar(handle)
	return handleFromPtr_api_ExecEnvVar(&(s[_idx]))
}

//export Slice_api_ExecEnvVar_subslice
func Slice_api_ExecEnvVar_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_api_ExecEnvVar(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_api_ExecEnvVar(&ss))
}

//export Slice_api_ExecEnvVar_set
func Slice_api_ExecEnvVar_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_api_ExecEnvVar(handle)
	s[_idx] = *ptrFromHandle_api_ExecEnvVar(_vl)
}

//export Slice_api_ExecEnvVar_append
func Slice_api_ExecEnvVar_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_api_ExecEnvVar(handle)
	*s = append(*s, *ptrFromHandle_api_ExecEnvVar(_vl))
}

// Converters for implicit pointer handles for type: []big.Word
func ptrFromHandle_Slice_big_Word(h CGoHandle) *[]big.Word {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]big.Word")
	if p == nil {
		return nil
	}
	return p.(*[]big.Word)
}
func deptrFromHandle_Slice_big_Word(h CGoHandle) []big.Word {
	p := ptrFromHandle_Slice_big_Word(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_big_Word(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]big.Word", p))
}

// --- wrapping slice: []big.Word ---
//
//export Slice_big_Word_CTor
func Slice_big_Word_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_big_Word(&[]big.Word{}))
}

//export Slice_big_Word_len
func Slice_big_Word_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_big_Word(handle))
}

//export Slice_big_Word_elem
func Slice_big_Word_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_big_Word(handle)
	return C.ulonglong(uint(s[_idx]))
}

//export Slice_big_Word_subslice
func Slice_big_Word_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_big_Word(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_big_Word(&ss))
}

//export Slice_big_Word_set
func Slice_big_Word_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_big_Word(handle)
	s[_idx] = big.Word(uint(_vl))
}

//export Slice_big_Word_append
func Slice_big_Word_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_big_Word(handle)
	*s = append(*s, big.Word(uint(_vl)))
}

// Converters for implicit pointer handles for type: []net.IP
func ptrFromHandle_Slice_net_IP(h CGoHandle) *[]net.IP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]net.IP")
	if p == nil {
		return nil
	}
	return p.(*[]net.IP)
}
func deptrFromHandle_Slice_net_IP(h CGoHandle) []net.IP {
	p := ptrFromHandle_Slice_net_IP(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_net_IP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]net.IP", p))
}

// --- wrapping slice: []net.IP ---
//
//export Slice_net_IP_CTor
func Slice_net_IP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_net_IP(&[]net.IP{}))
}

//export Slice_net_IP_len
func Slice_net_IP_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_net_IP(handle))
}

//export Slice_net_IP_elem
func Slice_net_IP_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_net_IP(handle)
	return handleFromPtr_net_IP(&(s[_idx]))
}

//export Slice_net_IP_subslice
func Slice_net_IP_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_net_IP(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_net_IP(&ss))
}

//export Slice_net_IP_set
func Slice_net_IP_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_net_IP(handle)
	s[_idx] = deptrFromHandle_net_IP(_vl)
}

//export Slice_net_IP_append
func Slice_net_IP_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_net_IP(handle)
	*s = append(*s, deptrFromHandle_net_IP(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for pointer handles for type: rest.AuthProvider
func ptrFromHandle_rest_AuthProvider(h CGoHandle) rest.AuthProvider {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.AuthProvider")
	if p == nil {
		return nil
	}
	return p.(rest.AuthProvider)
}
func handleFromPtr_rest_AuthProvider(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.AuthProvider", p))
}

// Converters for pointer handles for type: rest.AuthProviderConfigPersister
func ptrFromHandle_rest_AuthProviderConfigPersister(h CGoHandle) rest.AuthProviderConfigPersister {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.AuthProviderConfigPersister")
	if p == nil {
		return nil
	}
	return p.(rest.AuthProviderConfigPersister)
}
func handleFromPtr_rest_AuthProviderConfigPersister(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.AuthProviderConfigPersister", p))
}

// Converters for pointer handles for type: rest.BackoffManager
func ptrFromHandle_rest_BackoffManager(h CGoHandle) rest.BackoffManager {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.BackoffManager")
	if p == nil {
		return nil
	}
	return p.(rest.BackoffManager)
}
func handleFromPtr_rest_BackoffManager(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.BackoffManager", p))
}

// Converters for non-pointer handles for type: rest.ClientContentConfig
func ptrFromHandle_rest_ClientContentConfig(h CGoHandle) *rest.ClientContentConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.ClientContentConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.ClientContentConfig{})).(*rest.ClientContentConfig)
}
func handleFromPtr_rest_ClientContentConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.ClientContentConfig", p))
}

// Converters for non-pointer handles for type: rest.Config
func ptrFromHandle_rest_Config(h CGoHandle) *rest.Config {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.Config")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.Config{})).(*rest.Config)
}
func handleFromPtr_rest_Config(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.Config", p))
}

// Converters for non-pointer handles for type: rest.ContentConfig
func ptrFromHandle_rest_ContentConfig(h CGoHandle) *rest.ContentConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.ContentConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.ContentConfig{})).(*rest.ContentConfig)
}
func handleFromPtr_rest_ContentConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.ContentConfig", p))
}

// Converters for pointer handles for type: rest.HTTPClient
func ptrFromHandle_rest_HTTPClient(h CGoHandle) rest.HTTPClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.HTTPClient")
	if p == nil {
		return nil
	}
	return p.(rest.HTTPClient)
}
func handleFromPtr_rest_HTTPClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.HTTPClient", p))
}

// Converters for non-pointer handles for type: rest.ImpersonationConfig
func ptrFromHandle_rest_ImpersonationConfig(h CGoHandle) *rest.ImpersonationConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.ImpersonationConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.ImpersonationConfig{})).(*rest.ImpersonationConfig)
}
func handleFromPtr_rest_ImpersonationConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.ImpersonationConfig", p))
}

// Converters for pointer handles for type: rest.Interface
func ptrFromHandle_rest_Interface(h CGoHandle) rest.Interface {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.Interface")
	if p == nil {
		return nil
	}
	return p.(rest.Interface)
}
func handleFromPtr_rest_Interface(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.Interface", p))
}

// Converters for non-pointer handles for type: rest.NoBackoff
func ptrFromHandle_rest_NoBackoff(h CGoHandle) *rest.NoBackoff {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.NoBackoff")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.NoBackoff{})).(*rest.NoBackoff)
}
func handleFromPtr_rest_NoBackoff(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.NoBackoff", p))
}

// Converters for non-pointer handles for type: rest.NoWarnings
func ptrFromHandle_rest_NoWarnings(h CGoHandle) *rest.NoWarnings {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.NoWarnings")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.NoWarnings{})).(*rest.NoWarnings)
}
func handleFromPtr_rest_NoWarnings(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.NoWarnings", p))
}

// Converters for non-pointer handles for type: rest.RESTClient
func ptrFromHandle_rest_RESTClient(h CGoHandle) *rest.RESTClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.RESTClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.RESTClient{})).(*rest.RESTClient)
}
func handleFromPtr_rest_RESTClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.RESTClient", p))
}

// Converters for non-pointer handles for type: rest.Request
func ptrFromHandle_rest_Request(h CGoHandle) *rest.Request {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.Request")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.Request{})).(*rest.Request)
}
func handleFromPtr_rest_Request(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.Request", p))
}

// Converters for non-pointer handles for type: rest.RequestConstructionError
func ptrFromHandle_rest_RequestConstructionError(h CGoHandle) *rest.RequestConstructionError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.RequestConstructionError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.RequestConstructionError{})).(*rest.RequestConstructionError)
}
func handleFromPtr_rest_RequestConstructionError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.RequestConstructionError", p))
}

// Converters for pointer handles for type: rest.ResponseWrapper
func ptrFromHandle_rest_ResponseWrapper(h CGoHandle) rest.ResponseWrapper {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.ResponseWrapper")
	if p == nil {
		return nil
	}
	return p.(rest.ResponseWrapper)
}
func handleFromPtr_rest_ResponseWrapper(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.ResponseWrapper", p))
}

// Converters for non-pointer handles for type: rest.Result
func ptrFromHandle_rest_Result(h CGoHandle) *rest.Result {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.Result")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.Result{})).(*rest.Result)
}
func handleFromPtr_rest_Result(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.Result", p))
}

// Converters for non-pointer handles for type: rest.RetryAfter
func ptrFromHandle_rest_RetryAfter(h CGoHandle) *rest.RetryAfter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.RetryAfter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.RetryAfter{})).(*rest.RetryAfter)
}
func handleFromPtr_rest_RetryAfter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.RetryAfter", p))
}

// Converters for non-pointer handles for type: rest.TLSClientConfig
func ptrFromHandle_rest_TLSClientConfig(h CGoHandle) *rest.TLSClientConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.TLSClientConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.TLSClientConfig{})).(*rest.TLSClientConfig)
}
func handleFromPtr_rest_TLSClientConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.TLSClientConfig", p))
}

// Converters for non-pointer handles for type: rest.URLBackoff
func ptrFromHandle_rest_URLBackoff(h CGoHandle) *rest.URLBackoff {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.URLBackoff")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.URLBackoff{})).(*rest.URLBackoff)
}
func handleFromPtr_rest_URLBackoff(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.URLBackoff", p))
}

// Converters for pointer handles for type: rest.WarningHandler
func ptrFromHandle_rest_WarningHandler(h CGoHandle) rest.WarningHandler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.WarningHandler")
	if p == nil {
		return nil
	}
	return p.(rest.WarningHandler)
}
func handleFromPtr_rest_WarningHandler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.WarningHandler", p))
}

// Converters for non-pointer handles for type: rest.WarningLogger
func ptrFromHandle_rest_WarningLogger(h CGoHandle) *rest.WarningLogger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.WarningLogger")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.WarningLogger{})).(*rest.WarningLogger)
}
func handleFromPtr_rest_WarningLogger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.WarningLogger", p))
}

// Converters for non-pointer handles for type: rest.WarningWriterOptions
func ptrFromHandle_rest_WarningWriterOptions(h CGoHandle) *rest.WarningWriterOptions {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.WarningWriterOptions")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.WarningWriterOptions{})).(*rest.WarningWriterOptions)
}
func handleFromPtr_rest_WarningWriterOptions(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.WarningWriterOptions", p))
}

// Converters for non-pointer handles for type: rest.WatchListResult
func ptrFromHandle_rest_WatchListResult(h CGoHandle) *rest.WatchListResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.WatchListResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(rest.WatchListResult{})).(*rest.WatchListResult)
}
func handleFromPtr_rest_WatchListResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.WatchListResult", p))
}

// Converters for pointer handles for type: rest.WithRetry
func ptrFromHandle_rest_WithRetry(h CGoHandle) rest.WithRetry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "rest.WithRetry")
	if p == nil {
		return nil
	}
	return p.(rest.WithRetry)
}
func handleFromPtr_rest_WithRetry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("rest.WithRetry", p))
}

// Converters for implicit pointer handles for type: map[schema.GroupVersionKind]reflect.Type
func ptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(h CGoHandle) *map[schema.GroupVersionKind]reflect.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[schema.GroupVersionKind]reflect.Type")
	if p == nil {
		return nil
	}
	return p.(*map[schema.GroupVersionKind]reflect.Type)
}
func deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(h CGoHandle) map[schema.GroupVersionKind]reflect.Type {
	p := ptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_schema_GroupVersionKind_reflect_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[schema.GroupVersionKind]reflect.Type", p))
}

// --- wrapping map: map[schema.GroupVersionKind]reflect.Type ---
//
//export Map_schema_GroupVersionKind_reflect_Type_CTor
func Map_schema_GroupVersionKind_reflect_Type_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_schema_GroupVersionKind_reflect_Type(&map[schema.GroupVersionKind]reflect.Type{}))
}

//export Map_schema_GroupVersionKind_reflect_Type_len
func Map_schema_GroupVersionKind_reflect_Type_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle))
}

//export Map_schema_GroupVersionKind_reflect_Type_elem
func Map_schema_GroupVersionKind_reflect_Type_elem(handle CGoHandle, _ky CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	v, ok := s[*ptrFromHandle_schema_GroupVersionKind(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_reflect_Type(&v)
}

//export Map_schema_GroupVersionKind_reflect_Type_contains
func Map_schema_GroupVersionKind_reflect_Type_contains(handle CGoHandle, _ky CGoHandle) C.char {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	_, ok := s[*ptrFromHandle_schema_GroupVersionKind(_ky)]
	return boolGoToPy(ok)
}

//export Map_schema_GroupVersionKind_reflect_Type_set
func Map_schema_GroupVersionKind_reflect_Type_set(handle CGoHandle, _ky CGoHandle, _vl CGoHandle) {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	s[*ptrFromHandle_schema_GroupVersionKind(_ky)] = ptrFromHandle_reflect_Type(_vl)
}

//export Map_schema_GroupVersionKind_reflect_Type_delete
func Map_schema_GroupVersionKind_reflect_Type_delete(handle CGoHandle, _ky CGoHandle) {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	delete(s, *ptrFromHandle_schema_GroupVersionKind(_ky))
}

//export Map_schema_GroupVersionKind_reflect_Type_keys
func Map_schema_GroupVersionKind_reflect_Type_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_schema_GroupVersionKind_reflect_Type(handle)
	kys := make([]schema.GroupVersionKind, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_schema_GroupVersionKind(&kys)
}

// Converters for implicit pointer handles for type: map[string]*tls.Certificate
func ptrFromHandle_Map_string_Ptr_tls_Certificate(h CGoHandle) *map[string]*tls.Certificate {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]*tls.Certificate")
	if p == nil {
		return nil
	}
	return p.(*map[string]*tls.Certificate)
}
func deptrFromHandle_Map_string_Ptr_tls_Certificate(h CGoHandle) map[string]*tls.Certificate {
	p := ptrFromHandle_Map_string_Ptr_tls_Certificate(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Ptr_tls_Certificate(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]*tls.Certificate", p))
}

// --- wrapping map: map[string]*tls.Certificate ---
//
//export Map_string_Ptr_tls_Certificate_CTor
func Map_string_Ptr_tls_Certificate_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Ptr_tls_Certificate(&map[string]*tls.Certificate{}))
}

//export Map_string_Ptr_tls_Certificate_len
func Map_string_Ptr_tls_Certificate_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Ptr_tls_Certificate(handle))
}

//export Map_string_Ptr_tls_Certificate_elem
func Map_string_Ptr_tls_Certificate_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_tls_Certificate(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_tls_Certificate(&v)
}

//export Map_string_Ptr_tls_Certificate_contains
func Map_string_Ptr_tls_Certificate_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Ptr_tls_Certificate(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Ptr_tls_Certificate_set
func Map_string_Ptr_tls_Certificate_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Ptr_tls_Certificate(handle)
	s[C.GoString(_ky)] = ptrFromHandle_Ptr_tls_Certificate(_vl)
}

//export Map_string_Ptr_tls_Certificate_delete
func Map_string_Ptr_tls_Certificate_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Ptr_tls_Certificate(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Ptr_tls_Certificate_keys
func Map_string_Ptr_tls_Certificate_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_tls_Certificate(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string][]*multipart.FileHeader
func ptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h CGoHandle) *map[string][]*multipart.FileHeader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]*multipart.FileHeader")
	if p == nil {
		return nil
	}
	return p.(*map[string][]*multipart.FileHeader)
}
func deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h CGoHandle) map[string][]*multipart.FileHeader {
	p := ptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_Ptr_multipart_FileHeader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]*multipart.FileHeader", p))
}

// --- wrapping map: map[string][]*multipart.FileHeader ---
//
//export Map_string_Slice_Ptr_multipart_FileHeader_CTor
func Map_string_Slice_Ptr_multipart_FileHeader_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_Ptr_multipart_FileHeader(&map[string][]*multipart.FileHeader{}))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_len
func Map_string_Slice_Ptr_multipart_FileHeader_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_elem
func Map_string_Slice_Ptr_multipart_FileHeader_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_Ptr_multipart_FileHeader(&v)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_contains
func Map_string_Slice_Ptr_multipart_FileHeader_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_set
func Map_string_Slice_Ptr_multipart_FileHeader_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_Ptr_multipart_FileHeader(_vl)
}

//export Map_string_Slice_Ptr_multipart_FileHeader_delete
func Map_string_Slice_Ptr_multipart_FileHeader_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_Ptr_multipart_FileHeader_keys
func Map_string_Slice_Ptr_multipart_FileHeader_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_Ptr_multipart_FileHeader(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string][]string
func ptrFromHandle_Map_string_Slice_string(h CGoHandle) *map[string][]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]string")
	if p == nil {
		return nil
	}
	return p.(*map[string][]string)
}
func deptrFromHandle_Map_string_Slice_string(h CGoHandle) map[string][]string {
	p := ptrFromHandle_Map_string_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]string", p))
}

// --- wrapping map: map[string][]string ---
//
//export Map_string_Slice_string_CTor
func Map_string_Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_string(&map[string][]string{}))
}

//export Map_string_Slice_string_len
func Map_string_Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_string(handle))
}

//export Map_string_Slice_string_elem
func Map_string_Slice_string_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export Map_string_Slice_string_contains
func Map_string_Slice_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_string_set
func Map_string_Slice_string_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export Map_string_Slice_string_delete
func Map_string_Slice_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_string_keys
func Map_string_Slice_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]bool
func ptrFromHandle_Map_string_bool(h CGoHandle) *map[string]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]bool")
	if p == nil {
		return nil
	}
	return p.(*map[string]bool)
}
func deptrFromHandle_Map_string_bool(h CGoHandle) map[string]bool {
	p := ptrFromHandle_Map_string_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]bool", p))
}

// --- wrapping map: map[string]bool ---
//
//export Map_string_bool_CTor
func Map_string_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_bool(&map[string]bool{}))
}

//export Map_string_bool_len
func Map_string_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_bool(handle))
}

//export Map_string_bool_elem
func Map_string_bool_elem(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_bool(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return boolGoToPy(v)
}

//export Map_string_bool_contains
func Map_string_bool_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_bool(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_bool_set
func Map_string_bool_set(handle CGoHandle, _ky *C.char, _vl C.char) {
	s := deptrFromHandle_Map_string_bool(handle)
	s[C.GoString(_ky)] = boolPyToGo(_vl)
}

//export Map_string_bool_delete
func Map_string_bool_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_bool(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_bool_keys
func Map_string_bool_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_bool(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]reflect.Type
func ptrFromHandle_Map_string_reflect_Type(h CGoHandle) *map[string]reflect.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]reflect.Type")
	if p == nil {
		return nil
	}
	return p.(*map[string]reflect.Type)
}
func deptrFromHandle_Map_string_reflect_Type(h CGoHandle) map[string]reflect.Type {
	p := ptrFromHandle_Map_string_reflect_Type(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_reflect_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]reflect.Type", p))
}

// --- wrapping map: map[string]reflect.Type ---
//
//export Map_string_reflect_Type_CTor
func Map_string_reflect_Type_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_reflect_Type(&map[string]reflect.Type{}))
}

//export Map_string_reflect_Type_len
func Map_string_reflect_Type_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_reflect_Type(handle))
}

//export Map_string_reflect_Type_elem
func Map_string_reflect_Type_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_reflect_Type(&v)
}

//export Map_string_reflect_Type_contains
func Map_string_reflect_Type_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_reflect_Type_set
func Map_string_reflect_Type_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	s[C.GoString(_ky)] = ptrFromHandle_reflect_Type(_vl)
}

//export Map_string_reflect_Type_delete
func Map_string_reflect_Type_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_reflect_Type_keys
func Map_string_reflect_Type_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_reflect_Type(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]string
func ptrFromHandle_Map_string_string(h CGoHandle) *map[string]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]string")
	if p == nil {
		return nil
	}
	return p.(*map[string]string)
}
func deptrFromHandle_Map_string_string(h CGoHandle) map[string]string {
	p := ptrFromHandle_Map_string_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]string", p))
}

// --- wrapping map: map[string]string ---
//
//export Map_string_string_CTor
func Map_string_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_string(&map[string]string{}))
}

//export Map_string_string_len
func Map_string_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_string(handle))
}

//export Map_string_string_elem
func Map_string_string_elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_Map_string_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(v)
}

//export Map_string_string_contains
func Map_string_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_string_set
func Map_string_string_set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export Map_string_string_delete
func Map_string_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_string_keys
func Map_string_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---
//
//export rest_NameMayNotBe
func rest_NameMayNotBe() CGoHandle {
	return handleFromPtr_Slice_string(&rest.NameMayNotBe)
}

//export rest_Set_NameMayNotBe
func rest_Set_NameMayNotBe(val CGoHandle) {
	rest.NameMayNotBe = deptrFromHandle_Slice_string(val)
}

//export rest_NameMayNotContain
func rest_NameMayNotContain() CGoHandle {
	return handleFromPtr_Slice_string(&rest.NameMayNotContain)
}

//export rest_Set_NameMayNotContain
func rest_Set_NameMayNotContain(val CGoHandle) {
	rest.NameMayNotContain = deptrFromHandle_Slice_string(val)
}

// ---- Interfaces ---

//export rest_WarningHandler_HandleWarningHeader
func rest_WarningHandler_HandleWarningHeader(_handle CGoHandle, code C.longlong, agent *C.char, text *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.WarningHandler")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(rest.WarningHandler).HandleWarningHeader(int(code), C.GoString(agent), C.GoString(text))
	} else {
		vifc.(rest.WarningHandler).HandleWarningHeader(int(code), C.GoString(agent), C.GoString(text))
	}
}

//export rest_WithRetry_After
func rest_WithRetry_After(_handle CGoHandle, ctx CGoHandle, r CGoHandle, resp CGoHandle, err *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.WithRetry")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(rest.WithRetry).After(ptrFromHandle_context_Context(ctx), ptrFromHandle_Ptr_rest_Request(r), ptrFromHandle_Ptr_http_Response(resp), errors.New(C.GoString(err)))
	} else {
		vifc.(rest.WithRetry).After(ptrFromHandle_context_Context(ctx), ptrFromHandle_Ptr_rest_Request(r), ptrFromHandle_Ptr_http_Response(resp), errors.New(C.GoString(err)))
	}
}

//export rest_WithRetry_Before
func rest_WithRetry_Before(_handle CGoHandle, ctx CGoHandle, r CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.WithRetry")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(rest.WithRetry).Before(ptrFromHandle_context_Context(ctx), ptrFromHandle_Ptr_rest_Request(r))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export rest_WithRetry_WrapPreviousError
func rest_WithRetry_WrapPreviousError(_handle CGoHandle, finalErr *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.WithRetry")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(rest.WithRetry).WrapPreviousError(errors.New(C.GoString(finalErr)))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export rest_AuthProvider_Login
func rest_AuthProvider_Login(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.AuthProvider")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(rest.AuthProvider).Login()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export rest_AuthProvider_WrapTransport
func rest_AuthProvider_WrapTransport(_handle CGoHandle, arg_0 CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.AuthProvider")
	if __err != nil {
		return handleFromPtr_http_RoundTripper(nil)
	}
	return handleFromPtr_http_RoundTripper(vifc.(rest.AuthProvider).WrapTransport(ptrFromHandle_http_RoundTripper(arg_0)))

}

//export rest_AuthProviderConfigPersister_Persist
func rest_AuthProviderConfigPersister_Persist(_handle CGoHandle, arg_0 CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.AuthProviderConfigPersister")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(rest.AuthProviderConfigPersister).Persist(deptrFromHandle_Map_string_string(arg_0))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export rest_BackoffManager_CalculateBackoff
func rest_BackoffManager_CalculateBackoff(_handle CGoHandle, actualUrl CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.BackoffManager")
	if __err != nil {
		return C.longlong(int64(0))
	}
	return C.longlong(int64(vifc.(rest.BackoffManager).CalculateBackoff(ptrFromHandle_Ptr_url_URL(actualUrl))))

}

//export rest_BackoffManager_Sleep
func rest_BackoffManager_Sleep(_handle CGoHandle, d C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.BackoffManager")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(rest.BackoffManager).Sleep(time.Duration(int64(d)))
	} else {
		vifc.(rest.BackoffManager).Sleep(time.Duration(int64(d)))
	}
}

//export rest_BackoffManager_UpdateBackoff
func rest_BackoffManager_UpdateBackoff(_handle CGoHandle, actualUrl CGoHandle, err *C.char, responseCode C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.BackoffManager")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go vifc.(rest.BackoffManager).UpdateBackoff(ptrFromHandle_Ptr_url_URL(actualUrl), errors.New(C.GoString(err)), int(responseCode))
	} else {
		vifc.(rest.BackoffManager).UpdateBackoff(ptrFromHandle_Ptr_url_URL(actualUrl), errors.New(C.GoString(err)), int(responseCode))
	}
}

//export rest_HTTPClient_Do
func rest_HTTPClient_Do(_handle CGoHandle, req CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.HTTPClient")
	if __err != nil {
		return handleFromPtr_Ptr_http_Response(nil)
	}
	cret, __err := vifc.(rest.HTTPClient).Do(ptrFromHandle_Ptr_http_Request(req))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_http_Response(nil)
	}
	return handleFromPtr_Ptr_http_Response(cret)
}

//export rest_Interface_APIVersion
func rest_Interface_APIVersion(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.Interface")
	if __err != nil {
		return handleFromPtr_schema_GroupVersion(nil)
	}
	cret := vifc.(rest.Interface).APIVersion()

	return handleFromPtr_schema_GroupVersion(&cret)
}

//export rest_Interface_Delete
func rest_Interface_Delete(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.Interface")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(vifc.(rest.Interface).Delete())

}

//export rest_Interface_Get
func rest_Interface_Get(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.Interface")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(vifc.(rest.Interface).Get())

}

//export rest_Interface_GetRateLimiter
func rest_Interface_GetRateLimiter(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.Interface")
	if __err != nil {
		return handleFromPtr_flowcontrol_RateLimiter(nil)
	}
	return handleFromPtr_flowcontrol_RateLimiter(vifc.(rest.Interface).GetRateLimiter())

}

//export rest_Interface_Patch
func rest_Interface_Patch(_handle CGoHandle, pt *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.Interface")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(vifc.(rest.Interface).Patch(types.PatchType(C.GoString(pt))))

}

//export rest_Interface_Post
func rest_Interface_Post(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.Interface")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(vifc.(rest.Interface).Post())

}

//export rest_Interface_Put
func rest_Interface_Put(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.Interface")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(vifc.(rest.Interface).Put())

}

//export rest_Interface_Verb
func rest_Interface_Verb(_handle CGoHandle, verb *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.Interface")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(vifc.(rest.Interface).Verb(C.GoString(verb)))

}

//export rest_ResponseWrapper_DoRaw
func rest_ResponseWrapper_DoRaw(_handle CGoHandle, arg_0 CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.ResponseWrapper")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := vifc.(rest.ResponseWrapper).DoRaw(ptrFromHandle_context_Context(arg_0))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export rest_ResponseWrapper_Stream
func rest_ResponseWrapper_Stream(_handle CGoHandle, arg_0 CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "rest.ResponseWrapper")
	if __err != nil {
		return handleFromPtr_io_ReadCloser(nil)
	}
	cret, __err := vifc.(rest.ResponseWrapper).Stream(ptrFromHandle_context_Context(arg_0))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_io_ReadCloser(nil)
	}
	return handleFromPtr_io_ReadCloser(cret)
}

// ---- Structs ---

// --- wrapping struct: rest.Config ---
//
//export rest_Config_CTor
func rest_Config_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_Config(&rest.Config{}))
}

//export rest_Config_Host_Get
func rest_Config_Host_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_Config(handle)
	return C.CString(op.Host)
}

//export rest_Config_Host_Set
func rest_Config_Host_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_Config(handle)
	op.Host = C.GoString(val)
}

//export rest_Config_APIPath_Get
func rest_Config_APIPath_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_Config(handle)
	return C.CString(op.APIPath)
}

//export rest_Config_APIPath_Set
func rest_Config_APIPath_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_Config(handle)
	op.APIPath = C.GoString(val)
}

//export rest_Config_Username_Get
func rest_Config_Username_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_Config(handle)
	return C.CString(op.Username)
}

//export rest_Config_Username_Set
func rest_Config_Username_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_Config(handle)
	op.Username = C.GoString(val)
}

//export rest_Config_Password_Get
func rest_Config_Password_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_Config(handle)
	return C.CString(op.Password)
}

//export rest_Config_Password_Set
func rest_Config_Password_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_Config(handle)
	op.Password = C.GoString(val)
}

//export rest_Config_BearerToken_Get
func rest_Config_BearerToken_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_Config(handle)
	return C.CString(op.BearerToken)
}

//export rest_Config_BearerToken_Set
func rest_Config_BearerToken_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_Config(handle)
	op.BearerToken = C.GoString(val)
}

//export rest_Config_BearerTokenFile_Get
func rest_Config_BearerTokenFile_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_Config(handle)
	return C.CString(op.BearerTokenFile)
}

//export rest_Config_BearerTokenFile_Set
func rest_Config_BearerTokenFile_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_Config(handle)
	op.BearerTokenFile = C.GoString(val)
}

//export rest_Config_Impersonate_Get
func rest_Config_Impersonate_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_Config(handle)
	return handleFromPtr_rest_ImpersonationConfig(&op.Impersonate)
}

//export rest_Config_Impersonate_Set
func rest_Config_Impersonate_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_Config(handle)
	op.Impersonate = *ptrFromHandle_rest_ImpersonationConfig(val)
}

//export rest_Config_AuthProvider_Get
func rest_Config_AuthProvider_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_Config(handle)
	return handleFromPtr_Ptr_api_AuthProviderConfig(op.AuthProvider)
}

//export rest_Config_AuthProvider_Set
func rest_Config_AuthProvider_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_Config(handle)
	op.AuthProvider = ptrFromHandle_Ptr_api_AuthProviderConfig(val)
}

//export rest_Config_AuthConfigPersister_Get
func rest_Config_AuthConfigPersister_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_Config(handle)
	return handleFromPtr_rest_AuthProviderConfigPersister(op.AuthConfigPersister)
}

//export rest_Config_AuthConfigPersister_Set
func rest_Config_AuthConfigPersister_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_Config(handle)
	op.AuthConfigPersister = ptrFromHandle_rest_AuthProviderConfigPersister(val)
}

//export rest_Config_ExecProvider_Get
func rest_Config_ExecProvider_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_Config(handle)
	return handleFromPtr_Ptr_api_ExecConfig(op.ExecProvider)
}

//export rest_Config_ExecProvider_Set
func rest_Config_ExecProvider_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_Config(handle)
	op.ExecProvider = ptrFromHandle_Ptr_api_ExecConfig(val)
}

//export rest_Config_UserAgent_Get
func rest_Config_UserAgent_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_Config(handle)
	return C.CString(op.UserAgent)
}

//export rest_Config_UserAgent_Set
func rest_Config_UserAgent_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_Config(handle)
	op.UserAgent = C.GoString(val)
}

//export rest_Config_DisableCompression_Get
func rest_Config_DisableCompression_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_rest_Config(handle)
	return boolGoToPy(op.DisableCompression)
}

//export rest_Config_DisableCompression_Set
func rest_Config_DisableCompression_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_rest_Config(handle)
	op.DisableCompression = boolPyToGo(val)
}

//export rest_Config_Transport_Get
func rest_Config_Transport_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_Config(handle)
	return handleFromPtr_http_RoundTripper(op.Transport)
}

//export rest_Config_Transport_Set
func rest_Config_Transport_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_Config(handle)
	op.Transport = ptrFromHandle_http_RoundTripper(val)
}

//export rest_Config_QPS_Get
func rest_Config_QPS_Get(handle CGoHandle) C.float {
	op := ptrFromHandle_rest_Config(handle)
	return C.float(op.QPS)
}

//export rest_Config_QPS_Set
func rest_Config_QPS_Set(handle CGoHandle, val C.float) {
	op := ptrFromHandle_rest_Config(handle)
	op.QPS = float32(val)
}

//export rest_Config_Burst_Get
func rest_Config_Burst_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_rest_Config(handle)
	return C.longlong(op.Burst)
}

//export rest_Config_Burst_Set
func rest_Config_Burst_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_rest_Config(handle)
	op.Burst = int(val)
}

//export rest_Config_RateLimiter_Get
func rest_Config_RateLimiter_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_Config(handle)
	return handleFromPtr_flowcontrol_RateLimiter(op.RateLimiter)
}

//export rest_Config_RateLimiter_Set
func rest_Config_RateLimiter_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_Config(handle)
	op.RateLimiter = ptrFromHandle_flowcontrol_RateLimiter(val)
}

//export rest_Config_WarningHandler_Get
func rest_Config_WarningHandler_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_Config(handle)
	return handleFromPtr_rest_WarningHandler(op.WarningHandler)
}

//export rest_Config_WarningHandler_Set
func rest_Config_WarningHandler_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_Config(handle)
	op.WarningHandler = ptrFromHandle_rest_WarningHandler(val)
}

//export rest_Config_Timeout_Get
func rest_Config_Timeout_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_rest_Config(handle)
	return C.longlong(int64(op.Timeout))
}

//export rest_Config_Timeout_Set
func rest_Config_Timeout_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_rest_Config(handle)
	op.Timeout = time.Duration(int64(val))
}

//export rest_Config_GoString
func rest_Config_GoString(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Config")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(rest.Config{})).(*rest.Config).GoString())

}

//export rest_Config_String
func rest_Config_String(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Config")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(rest.Config{})).(*rest.Config).String())

}

//export rest_Config_TransportConfig
func rest_Config_TransportConfig(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Config")
	if __err != nil {
		return handleFromPtr_Ptr_transport_Config(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(rest.Config{})).(*rest.Config).TransportConfig()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_transport_Config(nil)
	}
	return handleFromPtr_Ptr_transport_Config(cret)
}

// --- wrapping struct: rest.RESTClient ---
//
//export rest_RESTClient_CTor
func rest_RESTClient_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_RESTClient(&rest.RESTClient{}))
}

//export rest_RESTClient_Client_Get
func rest_RESTClient_Client_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_RESTClient(handle)
	return handleFromPtr_Ptr_http_Client(op.Client)
}

//export rest_RESTClient_Client_Set
func rest_RESTClient_Client_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_RESTClient(handle)
	op.Client = ptrFromHandle_Ptr_http_Client(val)
}

//export rest_RESTClient_GetRateLimiter
func rest_RESTClient_GetRateLimiter(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.RESTClient")
	if __err != nil {
		return handleFromPtr_flowcontrol_RateLimiter(nil)
	}
	return handleFromPtr_flowcontrol_RateLimiter(gopyh.Embed(vifc, reflect.TypeOf(rest.RESTClient{})).(*rest.RESTClient).GetRateLimiter())

}

//export rest_RESTClient_Verb
func rest_RESTClient_Verb(_handle CGoHandle, verb *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.RESTClient{})).(*rest.RESTClient).Verb(C.GoString(verb)))

}

//export rest_RESTClient_Post
func rest_RESTClient_Post(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.RESTClient{})).(*rest.RESTClient).Post())

}

//export rest_RESTClient_Put
func rest_RESTClient_Put(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.RESTClient{})).(*rest.RESTClient).Put())

}

//export rest_RESTClient_Patch
func rest_RESTClient_Patch(_handle CGoHandle, pt *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.RESTClient{})).(*rest.RESTClient).Patch(types.PatchType(C.GoString(pt))))

}

//export rest_RESTClient_Get
func rest_RESTClient_Get(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.RESTClient{})).(*rest.RESTClient).Get())

}

//export rest_RESTClient_Delete
func rest_RESTClient_Delete(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.RESTClient{})).(*rest.RESTClient).Delete())

}

//export rest_RESTClient_APIVersion
func rest_RESTClient_APIVersion(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.RESTClient")
	if __err != nil {
		return handleFromPtr_schema_GroupVersion(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(rest.RESTClient{})).(*rest.RESTClient).APIVersion()

	return handleFromPtr_schema_GroupVersion(&cret)
}

// --- wrapping struct: rest.Request ---
//
//export rest_Request_CTor
func rest_Request_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_Request(&rest.Request{}))
}

//export rest_Request_UseProtobufAsDefaultIfPreferred
func rest_Request_UseProtobufAsDefaultIfPreferred(_handle CGoHandle, prefersProtobuf C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).UseProtobufAsDefaultIfPreferred(boolPyToGo(prefersProtobuf)))

}

//export rest_Request_UseProtobufAsDefault
func rest_Request_UseProtobufAsDefault(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).UseProtobufAsDefault())

}

//export rest_Request_Verb
func rest_Request_Verb(_handle CGoHandle, verb *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Verb(C.GoString(verb)))

}

//export rest_Request_Prefix
func rest_Request_Prefix(_handle CGoHandle, segments CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Prefix(deptrFromHandle_Slice_string(segments)...))

}

//export rest_Request_Suffix
func rest_Request_Suffix(_handle CGoHandle, segments CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Suffix(deptrFromHandle_Slice_string(segments)...))

}

//export rest_Request_Resource
func rest_Request_Resource(_handle CGoHandle, resource *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Resource(C.GoString(resource)))

}

//export rest_Request_BackOff
func rest_Request_BackOff(_handle CGoHandle, manager CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).BackOff(ptrFromHandle_rest_BackoffManager(manager)))

}

//export rest_Request_WarningHandler
func rest_Request_WarningHandler(_handle CGoHandle, handler CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).WarningHandler(ptrFromHandle_rest_WarningHandler(handler)))

}

//export rest_Request_Throttle
func rest_Request_Throttle(_handle CGoHandle, limiter CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Throttle(ptrFromHandle_flowcontrol_RateLimiter(limiter)))

}

//export rest_Request_SubResource
func rest_Request_SubResource(_handle CGoHandle, subresources CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).SubResource(deptrFromHandle_Slice_string(subresources)...))

}

//export rest_Request_Name
func rest_Request_Name(_handle CGoHandle, resourceName *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Name(C.GoString(resourceName)))

}

//export rest_Request_Namespace
func rest_Request_Namespace(_handle CGoHandle, namespace *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Namespace(C.GoString(namespace)))

}

//export rest_Request_NamespaceIfScoped
func rest_Request_NamespaceIfScoped(_handle CGoHandle, namespace *C.char, scoped C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).NamespaceIfScoped(C.GoString(namespace), boolPyToGo(scoped)))

}

//export rest_Request_AbsPath
func rest_Request_AbsPath(_handle CGoHandle, segments CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).AbsPath(deptrFromHandle_Slice_string(segments)...))

}

//export rest_Request_RequestURI
func rest_Request_RequestURI(_handle CGoHandle, uri *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).RequestURI(C.GoString(uri)))

}

//export rest_Request_Param
func rest_Request_Param(_handle CGoHandle, paramName *C.char, s *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Param(C.GoString(paramName), C.GoString(s)))

}

//export rest_Request_VersionedParams
func rest_Request_VersionedParams(_handle CGoHandle, obj CGoHandle, codec CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).VersionedParams(ptrFromHandle_runtime_Object(obj), ptrFromHandle_runtime_ParameterCodec(codec)))

}

//export rest_Request_SpecificallyVersionedParams
func rest_Request_SpecificallyVersionedParams(_handle CGoHandle, obj CGoHandle, codec CGoHandle, version CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).SpecificallyVersionedParams(ptrFromHandle_runtime_Object(obj), ptrFromHandle_runtime_ParameterCodec(codec), *ptrFromHandle_schema_GroupVersion(version)))

}

//export rest_Request_SetHeader
func rest_Request_SetHeader(_handle CGoHandle, key *C.char, values CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).SetHeader(C.GoString(key), deptrFromHandle_Slice_string(values)...))

}

//export rest_Request_Timeout
func rest_Request_Timeout(_handle CGoHandle, d C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Timeout(time.Duration(int64(d))))

}

//export rest_Request_MaxRetries
func rest_Request_MaxRetries(_handle CGoHandle, maxRetries C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).MaxRetries(int(maxRetries)))

}

//export rest_Request_Body
func rest_Request_Body(_handle CGoHandle, obj *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Body(C.GoString(obj)))

}

//export rest_Request_Error
func rest_Request_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Error()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export rest_Request_URL
func rest_Request_URL(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Ptr_url_URL(nil)
	}
	return handleFromPtr_Ptr_url_URL(gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).URL())

}

//export rest_Request_Watch
func rest_Request_Watch(_handle CGoHandle, ctx CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_watch_Interface(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Watch(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_watch_Interface(nil)
	}
	return handleFromPtr_watch_Interface(cret)
}

//export rest_Request_WatchList
func rest_Request_WatchList(_handle CGoHandle, ctx CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_rest_WatchListResult(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).WatchList(ptrFromHandle_context_Context(ctx))

	return handleFromPtr_rest_WatchListResult(&cret)
}

//export rest_Request_Stream
func rest_Request_Stream(_handle CGoHandle, ctx CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_io_ReadCloser(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Stream(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_io_ReadCloser(nil)
	}
	return handleFromPtr_io_ReadCloser(cret)
}

//export rest_Request_Do
func rest_Request_Do(_handle CGoHandle, ctx CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_rest_Result(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).Do(ptrFromHandle_context_Context(ctx))

	return handleFromPtr_rest_Result(&cret)
}

//export rest_Request_DoRaw
func rest_Request_DoRaw(_handle CGoHandle, ctx CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Request")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(rest.Request{})).(*rest.Request).DoRaw(ptrFromHandle_context_Context(ctx))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

// --- wrapping struct: rest.RequestConstructionError ---
//
//export rest_RequestConstructionError_CTor
func rest_RequestConstructionError_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_RequestConstructionError(&rest.RequestConstructionError{}))
}

//export rest_RequestConstructionError_Error
func rest_RequestConstructionError_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.RequestConstructionError")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(rest.RequestConstructionError{})).(*rest.RequestConstructionError).Error())

}

// --- wrapping struct: rest.Result ---
//
//export rest_Result_CTor
func rest_Result_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_Result(&rest.Result{}))
}

//export rest_Result_Raw
func rest_Result_Raw(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Result")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(rest.Result{})).(*rest.Result).Raw()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export rest_Result_Get
func rest_Result_Get(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Result")
	if __err != nil {
		return handleFromPtr_runtime_Object(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(rest.Result{})).(*rest.Result).Get()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_runtime_Object(nil)
	}
	return handleFromPtr_runtime_Object(cret)
}

//export rest_Result_Into
func rest_Result_Into(_handle CGoHandle, obj CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Result")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(rest.Result{})).(*rest.Result).Into(ptrFromHandle_runtime_Object(obj))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export rest_Result_Error
func rest_Result_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Result")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(rest.Result{})).(*rest.Result).Error()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export rest_Result_Warnings
func rest_Result_Warnings(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.Result")
	if __err != nil {
		return handleFromPtr_Slice_s1_net_WarningHeader(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(rest.Result{})).(*rest.Result).Warnings()

	return handleFromPtr_Slice_s1_net_WarningHeader(&cret)
}

// --- wrapping struct: rest.WarningWriterOptions ---
//
//export rest_WarningWriterOptions_CTor
func rest_WarningWriterOptions_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_WarningWriterOptions(&rest.WarningWriterOptions{}))
}

//export rest_WarningWriterOptions_Deduplicate_Get
func rest_WarningWriterOptions_Deduplicate_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_rest_WarningWriterOptions(handle)
	return boolGoToPy(op.Deduplicate)
}

//export rest_WarningWriterOptions_Deduplicate_Set
func rest_WarningWriterOptions_Deduplicate_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_rest_WarningWriterOptions(handle)
	op.Deduplicate = boolPyToGo(val)
}

//export rest_WarningWriterOptions_Color_Get
func rest_WarningWriterOptions_Color_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_rest_WarningWriterOptions(handle)
	return boolGoToPy(op.Color)
}

//export rest_WarningWriterOptions_Color_Set
func rest_WarningWriterOptions_Color_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_rest_WarningWriterOptions(handle)
	op.Color = boolPyToGo(val)
}

// --- wrapping struct: rest.NoWarnings ---
//
//export rest_NoWarnings_CTor
func rest_NoWarnings_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_NoWarnings(&rest.NoWarnings{}))
}

//export rest_NoWarnings_HandleWarningHeader
func rest_NoWarnings_HandleWarningHeader(_handle CGoHandle, code C.longlong, agent *C.char, message *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.NoWarnings")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(rest.NoWarnings{})).(*rest.NoWarnings).HandleWarningHeader(int(code), C.GoString(agent), C.GoString(message))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(rest.NoWarnings{})).(*rest.NoWarnings).HandleWarningHeader(int(code), C.GoString(agent), C.GoString(message))
	}
}

// --- wrapping struct: rest.TLSClientConfig ---
//
//export rest_TLSClientConfig_CTor
func rest_TLSClientConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_TLSClientConfig(&rest.TLSClientConfig{}))
}

//export rest_TLSClientConfig_Insecure_Get
func rest_TLSClientConfig_Insecure_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	return boolGoToPy(op.Insecure)
}

//export rest_TLSClientConfig_Insecure_Set
func rest_TLSClientConfig_Insecure_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	op.Insecure = boolPyToGo(val)
}

//export rest_TLSClientConfig_ServerName_Get
func rest_TLSClientConfig_ServerName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	return C.CString(op.ServerName)
}

//export rest_TLSClientConfig_ServerName_Set
func rest_TLSClientConfig_ServerName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	op.ServerName = C.GoString(val)
}

//export rest_TLSClientConfig_CertFile_Get
func rest_TLSClientConfig_CertFile_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	return C.CString(op.CertFile)
}

//export rest_TLSClientConfig_CertFile_Set
func rest_TLSClientConfig_CertFile_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	op.CertFile = C.GoString(val)
}

//export rest_TLSClientConfig_KeyFile_Get
func rest_TLSClientConfig_KeyFile_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	return C.CString(op.KeyFile)
}

//export rest_TLSClientConfig_KeyFile_Set
func rest_TLSClientConfig_KeyFile_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	op.KeyFile = C.GoString(val)
}

//export rest_TLSClientConfig_CAFile_Get
func rest_TLSClientConfig_CAFile_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	return C.CString(op.CAFile)
}

//export rest_TLSClientConfig_CAFile_Set
func rest_TLSClientConfig_CAFile_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	op.CAFile = C.GoString(val)
}

//export rest_TLSClientConfig_CertData_Get
func rest_TLSClientConfig_CertData_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	return handleFromPtr_Slice_byte(&op.CertData)
}

//export rest_TLSClientConfig_CertData_Set
func rest_TLSClientConfig_CertData_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	op.CertData = deptrFromHandle_Slice_byte(val)
}

//export rest_TLSClientConfig_KeyData_Get
func rest_TLSClientConfig_KeyData_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	return handleFromPtr_Slice_byte(&op.KeyData)
}

//export rest_TLSClientConfig_KeyData_Set
func rest_TLSClientConfig_KeyData_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	op.KeyData = deptrFromHandle_Slice_byte(val)
}

//export rest_TLSClientConfig_CAData_Get
func rest_TLSClientConfig_CAData_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	return handleFromPtr_Slice_byte(&op.CAData)
}

//export rest_TLSClientConfig_CAData_Set
func rest_TLSClientConfig_CAData_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	op.CAData = deptrFromHandle_Slice_byte(val)
}

//export rest_TLSClientConfig_NextProtos_Get
func rest_TLSClientConfig_NextProtos_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	return handleFromPtr_Slice_string(&op.NextProtos)
}

//export rest_TLSClientConfig_NextProtos_Set
func rest_TLSClientConfig_NextProtos_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_TLSClientConfig(handle)
	op.NextProtos = deptrFromHandle_Slice_string(val)
}

//export rest_TLSClientConfig_GoString
func rest_TLSClientConfig_GoString(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.TLSClientConfig")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(rest.TLSClientConfig{})).(*rest.TLSClientConfig).GoString())

}

//export rest_TLSClientConfig_String
func rest_TLSClientConfig_String(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.TLSClientConfig")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(rest.TLSClientConfig{})).(*rest.TLSClientConfig).String())

}

//export rest_TLSClientConfig_DeepCopyInto
func rest_TLSClientConfig_DeepCopyInto(_handle CGoHandle, out CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.TLSClientConfig")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(rest.TLSClientConfig{})).(*rest.TLSClientConfig).DeepCopyInto(ptrFromHandle_Ptr_rest_TLSClientConfig(out))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(rest.TLSClientConfig{})).(*rest.TLSClientConfig).DeepCopyInto(ptrFromHandle_Ptr_rest_TLSClientConfig(out))
	}
}

//export rest_TLSClientConfig_DeepCopy
func rest_TLSClientConfig_DeepCopy(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.TLSClientConfig")
	if __err != nil {
		return handleFromPtr_Ptr_rest_TLSClientConfig(nil)
	}
	return handleFromPtr_Ptr_rest_TLSClientConfig(gopyh.Embed(vifc, reflect.TypeOf(rest.TLSClientConfig{})).(*rest.TLSClientConfig).DeepCopy())

}

// --- wrapping struct: rest.ContentConfig ---
//
//export rest_ContentConfig_CTor
func rest_ContentConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_ContentConfig(&rest.ContentConfig{}))
}

//export rest_ContentConfig_AcceptContentTypes_Get
func rest_ContentConfig_AcceptContentTypes_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_ContentConfig(handle)
	return C.CString(op.AcceptContentTypes)
}

//export rest_ContentConfig_AcceptContentTypes_Set
func rest_ContentConfig_AcceptContentTypes_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_ContentConfig(handle)
	op.AcceptContentTypes = C.GoString(val)
}

//export rest_ContentConfig_ContentType_Get
func rest_ContentConfig_ContentType_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_ContentConfig(handle)
	return C.CString(op.ContentType)
}

//export rest_ContentConfig_ContentType_Set
func rest_ContentConfig_ContentType_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_ContentConfig(handle)
	op.ContentType = C.GoString(val)
}

//export rest_ContentConfig_GroupVersion_Get
func rest_ContentConfig_GroupVersion_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_ContentConfig(handle)
	return handleFromPtr_Ptr_schema_GroupVersion(op.GroupVersion)
}

//export rest_ContentConfig_GroupVersion_Set
func rest_ContentConfig_GroupVersion_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_ContentConfig(handle)
	op.GroupVersion = ptrFromHandle_Ptr_schema_GroupVersion(val)
}

//export rest_ContentConfig_NegotiatedSerializer_Get
func rest_ContentConfig_NegotiatedSerializer_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_ContentConfig(handle)
	return handleFromPtr_runtime_NegotiatedSerializer(op.NegotiatedSerializer)
}

//export rest_ContentConfig_NegotiatedSerializer_Set
func rest_ContentConfig_NegotiatedSerializer_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_ContentConfig(handle)
	op.NegotiatedSerializer = ptrFromHandle_runtime_NegotiatedSerializer(val)
}

// --- wrapping struct: rest.NoBackoff ---
//
//export rest_NoBackoff_CTor
func rest_NoBackoff_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_NoBackoff(&rest.NoBackoff{}))
}

//export rest_NoBackoff_UpdateBackoff
func rest_NoBackoff_UpdateBackoff(_handle CGoHandle, actualUrl CGoHandle, err *C.char, responseCode C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.NoBackoff")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(rest.NoBackoff{})).(*rest.NoBackoff).UpdateBackoff(ptrFromHandle_Ptr_url_URL(actualUrl), errors.New(C.GoString(err)), int(responseCode))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(rest.NoBackoff{})).(*rest.NoBackoff).UpdateBackoff(ptrFromHandle_Ptr_url_URL(actualUrl), errors.New(C.GoString(err)), int(responseCode))
	}
}

//export rest_NoBackoff_CalculateBackoff
func rest_NoBackoff_CalculateBackoff(_handle CGoHandle, actualUrl CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.NoBackoff")
	if __err != nil {
		return C.longlong(int64(0))
	}
	return C.longlong(int64(gopyh.Embed(vifc, reflect.TypeOf(rest.NoBackoff{})).(*rest.NoBackoff).CalculateBackoff(ptrFromHandle_Ptr_url_URL(actualUrl))))

}

//export rest_NoBackoff_Sleep
func rest_NoBackoff_Sleep(_handle CGoHandle, d C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.NoBackoff")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(rest.NoBackoff{})).(*rest.NoBackoff).Sleep(time.Duration(int64(d)))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(rest.NoBackoff{})).(*rest.NoBackoff).Sleep(time.Duration(int64(d)))
	}
}

// --- wrapping struct: rest.URLBackoff ---
//
//export rest_URLBackoff_CTor
func rest_URLBackoff_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_URLBackoff(&rest.URLBackoff{}))
}

//export rest_URLBackoff_Backoff_Get
func rest_URLBackoff_Backoff_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_URLBackoff(handle)
	return handleFromPtr_Ptr_flowcontrol_Backoff(op.Backoff)
}

//export rest_URLBackoff_Backoff_Set
func rest_URLBackoff_Backoff_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_URLBackoff(handle)
	op.Backoff = ptrFromHandle_Ptr_flowcontrol_Backoff(val)
}

//export rest_URLBackoff_Disable
func rest_URLBackoff_Disable(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.URLBackoff")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(rest.URLBackoff{})).(*rest.URLBackoff).Disable()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(rest.URLBackoff{})).(*rest.URLBackoff).Disable()
	}
}

//export rest_URLBackoff_UpdateBackoff
func rest_URLBackoff_UpdateBackoff(_handle CGoHandle, actualUrl CGoHandle, err *C.char, responseCode C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.URLBackoff")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(rest.URLBackoff{})).(*rest.URLBackoff).UpdateBackoff(ptrFromHandle_Ptr_url_URL(actualUrl), errors.New(C.GoString(err)), int(responseCode))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(rest.URLBackoff{})).(*rest.URLBackoff).UpdateBackoff(ptrFromHandle_Ptr_url_URL(actualUrl), errors.New(C.GoString(err)), int(responseCode))
	}
}

//export rest_URLBackoff_CalculateBackoff
func rest_URLBackoff_CalculateBackoff(_handle CGoHandle, actualUrl CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.URLBackoff")
	if __err != nil {
		return C.longlong(int64(0))
	}
	return C.longlong(int64(gopyh.Embed(vifc, reflect.TypeOf(rest.URLBackoff{})).(*rest.URLBackoff).CalculateBackoff(ptrFromHandle_Ptr_url_URL(actualUrl))))

}

//export rest_URLBackoff_Sleep
func rest_URLBackoff_Sleep(_handle CGoHandle, d C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.URLBackoff")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(rest.URLBackoff{})).(*rest.URLBackoff).Sleep(time.Duration(int64(d)))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(rest.URLBackoff{})).(*rest.URLBackoff).Sleep(time.Duration(int64(d)))
	}
}

// --- wrapping struct: rest.WatchListResult ---
//
//export rest_WatchListResult_CTor
func rest_WatchListResult_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_WatchListResult(&rest.WatchListResult{}))
}

//export rest_WatchListResult_Into
func rest_WatchListResult_Into(_handle CGoHandle, obj CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.WatchListResult")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(rest.WatchListResult{})).(*rest.WatchListResult).Into(ptrFromHandle_runtime_Object(obj))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: rest.ClientContentConfig ---
//
//export rest_ClientContentConfig_CTor
func rest_ClientContentConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_ClientContentConfig(&rest.ClientContentConfig{}))
}

//export rest_ClientContentConfig_AcceptContentTypes_Get
func rest_ClientContentConfig_AcceptContentTypes_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_ClientContentConfig(handle)
	return C.CString(op.AcceptContentTypes)
}

//export rest_ClientContentConfig_AcceptContentTypes_Set
func rest_ClientContentConfig_AcceptContentTypes_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_ClientContentConfig(handle)
	op.AcceptContentTypes = C.GoString(val)
}

//export rest_ClientContentConfig_ContentType_Get
func rest_ClientContentConfig_ContentType_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_ClientContentConfig(handle)
	return C.CString(op.ContentType)
}

//export rest_ClientContentConfig_ContentType_Set
func rest_ClientContentConfig_ContentType_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_ClientContentConfig(handle)
	op.ContentType = C.GoString(val)
}

//export rest_ClientContentConfig_GroupVersion_Get
func rest_ClientContentConfig_GroupVersion_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_ClientContentConfig(handle)
	return handleFromPtr_schema_GroupVersion(&op.GroupVersion)
}

//export rest_ClientContentConfig_GroupVersion_Set
func rest_ClientContentConfig_GroupVersion_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_ClientContentConfig(handle)
	op.GroupVersion = *ptrFromHandle_schema_GroupVersion(val)
}

//export rest_ClientContentConfig_Negotiator_Get
func rest_ClientContentConfig_Negotiator_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_ClientContentConfig(handle)
	return handleFromPtr_runtime_ClientNegotiator(op.Negotiator)
}

//export rest_ClientContentConfig_Negotiator_Set
func rest_ClientContentConfig_Negotiator_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_ClientContentConfig(handle)
	op.Negotiator = ptrFromHandle_runtime_ClientNegotiator(val)
}

// --- wrapping struct: rest.ImpersonationConfig ---
//
//export rest_ImpersonationConfig_CTor
func rest_ImpersonationConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_ImpersonationConfig(&rest.ImpersonationConfig{}))
}

//export rest_ImpersonationConfig_UserName_Get
func rest_ImpersonationConfig_UserName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_ImpersonationConfig(handle)
	return C.CString(op.UserName)
}

//export rest_ImpersonationConfig_UserName_Set
func rest_ImpersonationConfig_UserName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_ImpersonationConfig(handle)
	op.UserName = C.GoString(val)
}

//export rest_ImpersonationConfig_UID_Get
func rest_ImpersonationConfig_UID_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_ImpersonationConfig(handle)
	return C.CString(op.UID)
}

//export rest_ImpersonationConfig_UID_Set
func rest_ImpersonationConfig_UID_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_ImpersonationConfig(handle)
	op.UID = C.GoString(val)
}

//export rest_ImpersonationConfig_Groups_Get
func rest_ImpersonationConfig_Groups_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_ImpersonationConfig(handle)
	return handleFromPtr_Slice_string(&op.Groups)
}

//export rest_ImpersonationConfig_Groups_Set
func rest_ImpersonationConfig_Groups_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_ImpersonationConfig(handle)
	op.Groups = deptrFromHandle_Slice_string(val)
}

//export rest_ImpersonationConfig_Extra_Get
func rest_ImpersonationConfig_Extra_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_rest_ImpersonationConfig(handle)
	return handleFromPtr_Map_string_Slice_string(&op.Extra)
}

//export rest_ImpersonationConfig_Extra_Set
func rest_ImpersonationConfig_Extra_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_rest_ImpersonationConfig(handle)
	op.Extra = deptrFromHandle_Map_string_Slice_string(val)
}

// --- wrapping struct: rest.RetryAfter ---
//
//export rest_RetryAfter_CTor
func rest_RetryAfter_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_RetryAfter(&rest.RetryAfter{}))
}

//export rest_RetryAfter_Wait_Get
func rest_RetryAfter_Wait_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_rest_RetryAfter(handle)
	return C.longlong(int64(op.Wait))
}

//export rest_RetryAfter_Wait_Set
func rest_RetryAfter_Wait_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_rest_RetryAfter(handle)
	op.Wait = time.Duration(int64(val))
}

//export rest_RetryAfter_Attempt_Get
func rest_RetryAfter_Attempt_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_rest_RetryAfter(handle)
	return C.longlong(op.Attempt)
}

//export rest_RetryAfter_Attempt_Set
func rest_RetryAfter_Attempt_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_rest_RetryAfter(handle)
	op.Attempt = int(val)
}

//export rest_RetryAfter_Reason_Get
func rest_RetryAfter_Reason_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_rest_RetryAfter(handle)
	return C.CString(op.Reason)
}

//export rest_RetryAfter_Reason_Set
func rest_RetryAfter_Reason_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_rest_RetryAfter(handle)
	op.Reason = C.GoString(val)
}

// --- wrapping struct: rest.WarningLogger ---
//
//export rest_WarningLogger_CTor
func rest_WarningLogger_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_rest_WarningLogger(&rest.WarningLogger{}))
}

//export rest_WarningLogger_HandleWarningHeader
func rest_WarningLogger_HandleWarningHeader(_handle CGoHandle, code C.longlong, agent *C.char, message *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*rest.WarningLogger")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(rest.WarningLogger{})).(*rest.WarningLogger).HandleWarningHeader(int(code), C.GoString(agent), C.GoString(message))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(rest.WarningLogger{})).(*rest.WarningLogger).HandleWarningHeader(int(code), C.GoString(agent), C.GoString(message))
	}
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export rest_AddUserAgent
func rest_AddUserAgent(config CGoHandle, userAgent *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_rest_Config(rest.AddUserAgent(ptrFromHandle_Ptr_rest_Config(config), C.GoString(userAgent)))

}

//export rest_AnonymousClientConfig
func rest_AnonymousClientConfig(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_rest_Config(rest.AnonymousClientConfig(ptrFromHandle_Ptr_rest_Config(config)))

}

//export rest_InClusterConfig
func rest_InClusterConfig() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.InClusterConfig()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_rest_Config(nil)
	}
	return handleFromPtr_Ptr_rest_Config(cret)
}

//export rest_CopyConfig
func rest_CopyConfig(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_rest_Config(rest.CopyConfig(ptrFromHandle_Ptr_rest_Config(config)))

}

//export rest_ExecClusterToConfig
func rest_ExecClusterToConfig(cluster CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.ExecClusterToConfig(ptrFromHandle_Ptr_clientauthentication_Cluster(cluster))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_rest_Config(nil)
	}
	return handleFromPtr_Ptr_rest_Config(cret)
}

//export rest_UnversionedRESTClientForConfigAndClient
func rest_UnversionedRESTClientForConfigAndClient(config CGoHandle, httpClient CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.UnversionedRESTClientForConfigAndClient(ptrFromHandle_Ptr_rest_Config(config), ptrFromHandle_Ptr_http_Client(httpClient))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_rest_RESTClient(nil)
	}
	return handleFromPtr_Ptr_rest_RESTClient(cret)
}

//export rest_NewRESTClient
func rest_NewRESTClient(baseURL CGoHandle, versionedAPIPath *C.char, config CGoHandle, rateLimiter CGoHandle, client CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.NewRESTClient(ptrFromHandle_Ptr_url_URL(baseURL), C.GoString(versionedAPIPath), *ptrFromHandle_rest_ClientContentConfig(config), ptrFromHandle_flowcontrol_RateLimiter(rateLimiter), ptrFromHandle_Ptr_http_Client(client))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_rest_RESTClient(nil)
	}
	return handleFromPtr_Ptr_rest_RESTClient(cret)
}

//export rest_UnversionedRESTClientFor
func rest_UnversionedRESTClientFor(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.UnversionedRESTClientFor(ptrFromHandle_Ptr_rest_Config(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_rest_RESTClient(nil)
	}
	return handleFromPtr_Ptr_rest_RESTClient(cret)
}

//export rest_RESTClientFor
func rest_RESTClientFor(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.RESTClientFor(ptrFromHandle_Ptr_rest_Config(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_rest_RESTClient(nil)
	}
	return handleFromPtr_Ptr_rest_RESTClient(cret)
}

//export rest_RESTClientForConfigAndClient
func rest_RESTClientForConfigAndClient(config CGoHandle, httpClient CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.RESTClientForConfigAndClient(ptrFromHandle_Ptr_rest_Config(config), ptrFromHandle_Ptr_http_Client(httpClient))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_rest_RESTClient(nil)
	}
	return handleFromPtr_Ptr_rest_RESTClient(cret)
}

//export rest_NewRequest
func rest_NewRequest(c CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_rest_Request(rest.NewRequest(ptrFromHandle_Ptr_rest_RESTClient(c)))

}

//export rest_NewRequestWithClient
func rest_NewRequestWithClient(base CGoHandle, versionedAPIPath *C.char, content CGoHandle, client CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_rest_Request(rest.NewRequestWithClient(ptrFromHandle_Ptr_url_URL(base), C.GoString(versionedAPIPath), *ptrFromHandle_rest_ClientContentConfig(content), ptrFromHandle_Ptr_http_Client(client)))

}

// ---- Functions ---

//export rest_GetAuthProvider
func rest_GetAuthProvider(clusterAddress *C.char, apc CGoHandle, persister CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.GetAuthProvider(C.GoString(clusterAddress), ptrFromHandle_Ptr_api_AuthProviderConfig(apc), ptrFromHandle_rest_AuthProviderConfigPersister(persister))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_rest_AuthProvider(nil)
	}
	return handleFromPtr_rest_AuthProvider(cret)
}

//export rest_IsValidPathSegmentName
func rest_IsValidPathSegmentName(name *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := rest.IsValidPathSegmentName(C.GoString(name))

	return handleFromPtr_Slice_string(&cret)
}

//export rest_DefaultVersionedAPIPath
func rest_DefaultVersionedAPIPath(apiPath *C.char, groupVersion CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(rest.DefaultVersionedAPIPath(C.GoString(apiPath), *ptrFromHandle_schema_GroupVersion(groupVersion)))

}

//export rest_ConfigToExecCluster
func rest_ConfigToExecCluster(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.ConfigToExecCluster(ptrFromHandle_Ptr_rest_Config(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_clientauthentication_Cluster(nil)
	}
	return handleFromPtr_Ptr_clientauthentication_Cluster(cret)
}

//export rest_DefaultKubernetesUserAgent
func rest_DefaultKubernetesUserAgent() *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(rest.DefaultKubernetesUserAgent())

}

//export rest_CodecFactoryForGeneratedClient
func rest_CodecFactoryForGeneratedClient(scheme CGoHandle, codecs CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := rest.CodecFactoryForGeneratedClient(ptrFromHandle_Ptr_runtime_Scheme(scheme), *ptrFromHandle_serializer_CodecFactory(codecs))

	return handleFromPtr_serializer_CodecFactory(&cret)
}

//export rest_LoadTLSFiles
func rest_LoadTLSFiles(c CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = rest.LoadTLSFiles(ptrFromHandle_Ptr_rest_Config(c))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export rest_SetKubernetesDefaults
func rest_SetKubernetesDefaults(config CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = rest.SetKubernetesDefaults(ptrFromHandle_Ptr_rest_Config(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export rest_SetDefaultWarningHandler
func rest_SetDefaultWarningHandler(l CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go rest.SetDefaultWarningHandler(ptrFromHandle_rest_WarningHandler(l))
	} else {
		rest.SetDefaultWarningHandler(ptrFromHandle_rest_WarningHandler(l))
	}
}

//export rest_TransportFor
func rest_TransportFor(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.TransportFor(ptrFromHandle_Ptr_rest_Config(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_http_RoundTripper(nil)
	}
	return handleFromPtr_http_RoundTripper(cret)
}

//export rest_TLSConfigFor
func rest_TLSConfigFor(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.TLSConfigFor(ptrFromHandle_Ptr_rest_Config(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_tls_Config(nil)
	}
	return handleFromPtr_Ptr_tls_Config(cret)
}

//export rest_HTTPClientFor
func rest_HTTPClientFor(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.HTTPClientFor(ptrFromHandle_Ptr_rest_Config(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_http_Client(nil)
	}
	return handleFromPtr_Ptr_http_Client(cret)
}

//export rest_HTTPWrappersForConfig
func rest_HTTPWrappersForConfig(config CGoHandle, rt CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := rest.HTTPWrappersForConfig(ptrFromHandle_Ptr_rest_Config(config), ptrFromHandle_http_RoundTripper(rt))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_http_RoundTripper(nil)
	}
	return handleFromPtr_http_RoundTripper(cret)
}

//export rest_ValidatePathSegmentName
func rest_ValidatePathSegmentName(name *C.char, prefix C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := rest.ValidatePathSegmentName(C.GoString(name), boolPyToGo(prefix))

	return handleFromPtr_Slice_string(&cret)
}

//export rest_IsValidPathSegmentPrefix
func rest_IsValidPathSegmentPrefix(name *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := rest.IsValidPathSegmentPrefix(C.GoString(name))

	return handleFromPtr_Slice_string(&cret)
}

//export rest_IsConfigTransportTLS
func rest_IsConfigTransportTLS(config CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return boolGoToPy(rest.IsConfigTransportTLS(*ptrFromHandle_rest_Config(config)))

}

// ---- Package: fake ---

// ---- Types ---

// Converters for pointer handles for type: *fake.RESTClient
func ptrFromHandle_Ptr_fake_RESTClient(h CGoHandle) *fake.RESTClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*fake.RESTClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fake.RESTClient{})).(*fake.RESTClient)
}
func handleFromPtr_Ptr_fake_RESTClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*fake.RESTClient", p))
}

// Converters for non-pointer handles for type: fake.RESTClient
func ptrFromHandle_fake_RESTClient(h CGoHandle) *fake.RESTClient {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "fake.RESTClient")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(fake.RESTClient{})).(*fake.RESTClient)
}
func handleFromPtr_fake_RESTClient(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("fake.RESTClient", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: fake.RESTClient ---
//
//export fake_RESTClient_CTor
func fake_RESTClient_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_fake_RESTClient(&fake.RESTClient{}))
}

//export fake_RESTClient_NegotiatedSerializer_Get
func fake_RESTClient_NegotiatedSerializer_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_fake_RESTClient(handle)
	return handleFromPtr_runtime_NegotiatedSerializer(op.NegotiatedSerializer)
}

//export fake_RESTClient_NegotiatedSerializer_Set
func fake_RESTClient_NegotiatedSerializer_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_fake_RESTClient(handle)
	op.NegotiatedSerializer = ptrFromHandle_runtime_NegotiatedSerializer(val)
}

//export fake_RESTClient_GroupVersion_Get
func fake_RESTClient_GroupVersion_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_fake_RESTClient(handle)
	return handleFromPtr_schema_GroupVersion(&op.GroupVersion)
}

//export fake_RESTClient_GroupVersion_Set
func fake_RESTClient_GroupVersion_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_fake_RESTClient(handle)
	op.GroupVersion = *ptrFromHandle_schema_GroupVersion(val)
}

//export fake_RESTClient_VersionedAPIPath_Get
func fake_RESTClient_VersionedAPIPath_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_fake_RESTClient(handle)
	return C.CString(op.VersionedAPIPath)
}

//export fake_RESTClient_VersionedAPIPath_Set
func fake_RESTClient_VersionedAPIPath_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_fake_RESTClient(handle)
	op.VersionedAPIPath = C.GoString(val)
}

//export fake_RESTClient_Req_Get
func fake_RESTClient_Req_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_fake_RESTClient(handle)
	return handleFromPtr_Ptr_http_Request(op.Req)
}

//export fake_RESTClient_Req_Set
func fake_RESTClient_Req_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_fake_RESTClient(handle)
	op.Req = ptrFromHandle_Ptr_http_Request(val)
}

//export fake_RESTClient_Client_Get
func fake_RESTClient_Client_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_fake_RESTClient(handle)
	return handleFromPtr_Ptr_http_Client(op.Client)
}

//export fake_RESTClient_Client_Set
func fake_RESTClient_Client_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_fake_RESTClient(handle)
	op.Client = ptrFromHandle_Ptr_http_Client(val)
}

//export fake_RESTClient_Resp_Get
func fake_RESTClient_Resp_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_fake_RESTClient(handle)
	return handleFromPtr_Ptr_http_Response(op.Resp)
}

//export fake_RESTClient_Resp_Set
func fake_RESTClient_Resp_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_fake_RESTClient(handle)
	op.Resp = ptrFromHandle_Ptr_http_Response(val)
}

//export fake_RESTClient_Get
func fake_RESTClient_Get(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(fake.RESTClient{})).(*fake.RESTClient).Get())

}

//export fake_RESTClient_Put
func fake_RESTClient_Put(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(fake.RESTClient{})).(*fake.RESTClient).Put())

}

//export fake_RESTClient_Patch
func fake_RESTClient_Patch(_handle CGoHandle, pt *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(fake.RESTClient{})).(*fake.RESTClient).Patch(types.PatchType(C.GoString(pt))))

}

//export fake_RESTClient_Post
func fake_RESTClient_Post(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(fake.RESTClient{})).(*fake.RESTClient).Post())

}

//export fake_RESTClient_Delete
func fake_RESTClient_Delete(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(fake.RESTClient{})).(*fake.RESTClient).Delete())

}

//export fake_RESTClient_Verb
func fake_RESTClient_Verb(_handle CGoHandle, verb *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(fake.RESTClient{})).(*fake.RESTClient).Verb(C.GoString(verb)))

}

//export fake_RESTClient_APIVersion
func fake_RESTClient_APIVersion(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.RESTClient")
	if __err != nil {
		return handleFromPtr_schema_GroupVersion(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(fake.RESTClient{})).(*fake.RESTClient).APIVersion()

	return handleFromPtr_schema_GroupVersion(&cret)
}

//export fake_RESTClient_GetRateLimiter
func fake_RESTClient_GetRateLimiter(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.RESTClient")
	if __err != nil {
		return handleFromPtr_flowcontrol_RateLimiter(nil)
	}
	return handleFromPtr_flowcontrol_RateLimiter(gopyh.Embed(vifc, reflect.TypeOf(fake.RESTClient{})).(*fake.RESTClient).GetRateLimiter())

}

//export fake_RESTClient_Request
func fake_RESTClient_Request(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*fake.RESTClient")
	if __err != nil {
		return handleFromPtr_Ptr_rest_Request(nil)
	}
	return handleFromPtr_Ptr_rest_Request(gopyh.Embed(vifc, reflect.TypeOf(fake.RESTClient{})).(*fake.RESTClient).Request())

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

// ---- Package: watch ---

// ---- Types ---

// Converters for pointer handles for type: *s2_watch.Decoder
func ptrFromHandle_Ptr_s2_watch_Decoder(h CGoHandle) *s2_watch.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*s2_watch.Decoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(s2_watch.Decoder{})).(*s2_watch.Decoder)
}
func handleFromPtr_Ptr_s2_watch_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*s2_watch.Decoder", p))
}

// Converters for pointer handles for type: *s2_watch.Encoder
func ptrFromHandle_Ptr_s2_watch_Encoder(h CGoHandle) *s2_watch.Encoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*s2_watch.Encoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(s2_watch.Encoder{})).(*s2_watch.Encoder)
}
func handleFromPtr_Ptr_s2_watch_Encoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*s2_watch.Encoder", p))
}

// Converters for non-pointer handles for type: s2_watch.Decoder
func ptrFromHandle_s2_watch_Decoder(h CGoHandle) *s2_watch.Decoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "s2_watch.Decoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(s2_watch.Decoder{})).(*s2_watch.Decoder)
}
func handleFromPtr_s2_watch_Decoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("s2_watch.Decoder", p))
}

// Converters for non-pointer handles for type: s2_watch.Encoder
func ptrFromHandle_s2_watch_Encoder(h CGoHandle) *s2_watch.Encoder {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "s2_watch.Encoder")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(s2_watch.Encoder{})).(*s2_watch.Encoder)
}
func handleFromPtr_s2_watch_Encoder(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("s2_watch.Encoder", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: s2_watch.Decoder ---
//
//export s2_watch_Decoder_CTor
func s2_watch_Decoder_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_s2_watch_Decoder(&s2_watch.Decoder{}))
}

//export s2_watch_Decoder_Close
func s2_watch_Decoder_Close(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*s2_watch.Decoder")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(s2_watch.Decoder{})).(*s2_watch.Decoder).Close()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(s2_watch.Decoder{})).(*s2_watch.Decoder).Close()
	}
}

// --- wrapping struct: s2_watch.Encoder ---
//
//export s2_watch_Encoder_CTor
func s2_watch_Encoder_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_s2_watch_Encoder(&s2_watch.Encoder{}))
}

//export s2_watch_Encoder_Encode
func s2_watch_Encoder_Encode(_handle CGoHandle, event CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*s2_watch.Encoder")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(s2_watch.Encoder{})).(*s2_watch.Encoder).Encode(ptrFromHandle_Ptr_watch_Event(event))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export watch_NewDecoder
func watch_NewDecoder(decoder CGoHandle, embeddedDecoder CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_s2_watch_Decoder(s2_watch.NewDecoder(ptrFromHandle_streaming_Decoder(decoder), ptrFromHandle_runtime_Decoder(embeddedDecoder)))

}

//export watch_NewEncoder
func watch_NewEncoder(encoder CGoHandle, embeddedEncoder CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_s2_watch_Encoder(s2_watch.NewEncoder(ptrFromHandle_streaming_Encoder(encoder), ptrFromHandle_runtime_Encoder(embeddedEncoder)))

}

// ---- Functions ---
