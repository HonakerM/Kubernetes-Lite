
# python wrapper for package k8s.io/client-go/rest within overall package rest
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy pkg k8s.io/client-go/rest

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _rest
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from rest import rest
# and then refer to everything using rest. prefix
# packages imported by this package listed below:

from . import watch



# ---- Types ---

# Python type for slice [32]byte
class Array_32_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Array_32_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Array_32_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Array_32_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _rest.Array_32_byte_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Array_32_byte_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _rest.Array_32_byte_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice []*x509.Certificate
class Slice_Ptr_x509_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_Ptr_x509_Certificate_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_x509_Certificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_Ptr_x509_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_Ptr_x509_Certificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_Ptr_x509_Certificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_Ptr_x509_Certificate_len(self.handle)
				return Slice_Ptr_x509_Certificate(handle=_rest.Slice_Ptr_x509_Certificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_x509_Certificate(handle=_rest.Slice_Ptr_x509_Certificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_Ptr_x509_Certificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_x509_Certificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_x509_Certificate(handle=_rest.Slice_Ptr_x509_Certificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_Ptr_x509_Certificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*multipart.FileHeader
class Slice_Ptr_multipart_FileHeader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_Ptr_multipart_FileHeader_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_multipart_FileHeader.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_Ptr_multipart_FileHeader len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_Ptr_multipart_FileHeader([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_Ptr_multipart_FileHeader_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_Ptr_multipart_FileHeader_len(self.handle)
				return Slice_Ptr_multipart_FileHeader(handle=_rest.Slice_Ptr_multipart_FileHeader_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_multipart_FileHeader(handle=_rest.Slice_Ptr_multipart_FileHeader_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_Ptr_multipart_FileHeader_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_multipart_FileHeader.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_multipart_FileHeader(handle=_rest.Slice_Ptr_multipart_FileHeader_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_Ptr_multipart_FileHeader_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*net.IPNet
class Slice_Ptr_net_IPNet(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_Ptr_net_IPNet_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_net_IPNet.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_Ptr_net_IPNet len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_Ptr_net_IPNet([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_Ptr_net_IPNet_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_Ptr_net_IPNet_len(self.handle)
				return Slice_Ptr_net_IPNet(handle=_rest.Slice_Ptr_net_IPNet_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_net_IPNet(handle=_rest.Slice_Ptr_net_IPNet_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_Ptr_net_IPNet_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_net_IPNet.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_net_IPNet(handle=_rest.Slice_Ptr_net_IPNet_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_Ptr_net_IPNet_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*http.Cookie
class Slice_Ptr_http_Cookie(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_Ptr_http_Cookie_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_http_Cookie.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_Ptr_http_Cookie len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_Ptr_http_Cookie([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_Ptr_http_Cookie_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_Ptr_http_Cookie_len(self.handle)
				return Slice_Ptr_http_Cookie(handle=_rest.Slice_Ptr_http_Cookie_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_http_Cookie(handle=_rest.Slice_Ptr_http_Cookie_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_Ptr_http_Cookie_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_http_Cookie.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_http_Cookie(handle=_rest.Slice_Ptr_http_Cookie_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_Ptr_http_Cookie_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*url.URL
class Slice_Ptr_url_URL(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_Ptr_url_URL_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_url_URL.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_Ptr_url_URL len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_Ptr_url_URL([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_Ptr_url_URL_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_Ptr_url_URL_len(self.handle)
				return Slice_Ptr_url_URL(handle=_rest.Slice_Ptr_url_URL_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_url_URL(handle=_rest.Slice_Ptr_url_URL_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_Ptr_url_URL_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_url_URL.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_url_URL(handle=_rest.Slice_Ptr_url_URL_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_Ptr_url_URL_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][32]byte
class Slice__32_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice__32_byte_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice__32_byte.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice__32_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice__32_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice__32_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice__32_byte_len(self.handle)
				return Slice__32_byte(handle=_rest.Slice__32_byte_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Array_32_byte(handle=_rest.Slice__32_byte_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice__32_byte_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice__32_byte.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Array_32_byte(handle=_rest.Slice__32_byte_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice__32_byte_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]*x509.Certificate
class Slice_Slice_Ptr_x509_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_Slice_Ptr_x509_Certificate_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_Ptr_x509_Certificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_Slice_Ptr_x509_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_Slice_Ptr_x509_Certificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_Slice_Ptr_x509_Certificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_Slice_Ptr_x509_Certificate_len(self.handle)
				return Slice_Slice_Ptr_x509_Certificate(handle=_rest.Slice_Slice_Ptr_x509_Certificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Slice_Ptr_x509_Certificate(handle=_rest.Slice_Slice_Ptr_x509_Certificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_Slice_Ptr_x509_Certificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_Ptr_x509_Certificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Slice_Ptr_x509_Certificate(handle=_rest.Slice_Slice_Ptr_x509_Certificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_Slice_Ptr_x509_Certificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]byte
class Slice_Slice_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_Slice_byte_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_byte.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_Slice_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_Slice_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_Slice_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_Slice_byte_len(self.handle)
				return Slice_Slice_byte(handle=_rest.Slice_Slice_byte_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_byte(handle=_rest.Slice_Slice_byte_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_Slice_byte_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_byte.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_byte(handle=_rest.Slice_Slice_byte_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_Slice_byte_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []tls.Certificate
class Slice_tls_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_tls_Certificate_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_tls_Certificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_tls_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_tls_Certificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_tls_Certificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_tls_Certificate_len(self.handle)
				return Slice_tls_Certificate(handle=_rest.Slice_tls_Certificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.tls_Certificate(handle=_rest.Slice_tls_Certificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_tls_Certificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_tls_Certificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.tls_Certificate(handle=_rest.Slice_tls_Certificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_tls_Certificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []tls.CurveID
class Slice_tls_CurveID(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_tls_CurveID_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_tls_CurveID.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_tls_CurveID len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_tls_CurveID([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_tls_CurveID_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_tls_CurveID_len(self.handle)
				return Slice_tls_CurveID(handle=_rest.Slice_tls_CurveID_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _rest.Slice_tls_CurveID_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_tls_CurveID_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_tls_CurveID.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _rest.Slice_tls_CurveID_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_tls_CurveID_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []tls.SignatureScheme
class Slice_tls_SignatureScheme(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_tls_SignatureScheme_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_tls_SignatureScheme.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_tls_SignatureScheme len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_tls_SignatureScheme([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_tls_SignatureScheme_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_tls_SignatureScheme_len(self.handle)
				return Slice_tls_SignatureScheme(handle=_rest.Slice_tls_SignatureScheme_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _rest.Slice_tls_SignatureScheme_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_tls_SignatureScheme_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_tls_SignatureScheme.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _rest.Slice_tls_SignatureScheme_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_tls_SignatureScheme_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []x509.ExtKeyUsage
class Slice_x509_ExtKeyUsage(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_x509_ExtKeyUsage_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_x509_ExtKeyUsage.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_x509_ExtKeyUsage len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_x509_ExtKeyUsage([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_x509_ExtKeyUsage_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_x509_ExtKeyUsage_len(self.handle)
				return Slice_x509_ExtKeyUsage(handle=_rest.Slice_x509_ExtKeyUsage_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _rest.Slice_x509_ExtKeyUsage_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_x509_ExtKeyUsage_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_x509_ExtKeyUsage.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _rest.Slice_x509_ExtKeyUsage_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_x509_ExtKeyUsage_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []x509.OID
class Slice_x509_OID(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_x509_OID_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_x509_OID.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_x509_OID len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_x509_OID([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_x509_OID_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_x509_OID_len(self.handle)
				return Slice_x509_OID(handle=_rest.Slice_x509_OID_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.x509_OID(handle=_rest.Slice_x509_OID_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_x509_OID_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_x509_OID.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.x509_OID(handle=_rest.Slice_x509_OID_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_x509_OID_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.AttributeTypeAndValue
class Slice_pkix_AttributeTypeAndValue(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_pkix_AttributeTypeAndValue_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_AttributeTypeAndValue.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_pkix_AttributeTypeAndValue len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_pkix_AttributeTypeAndValue([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_pkix_AttributeTypeAndValue_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_pkix_AttributeTypeAndValue_len(self.handle)
				return Slice_pkix_AttributeTypeAndValue(handle=_rest.Slice_pkix_AttributeTypeAndValue_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_AttributeTypeAndValue(handle=_rest.Slice_pkix_AttributeTypeAndValue_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_pkix_AttributeTypeAndValue_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_AttributeTypeAndValue.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_AttributeTypeAndValue(handle=_rest.Slice_pkix_AttributeTypeAndValue_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_pkix_AttributeTypeAndValue_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.Extension
class Slice_pkix_Extension(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_pkix_Extension_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_Extension.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_pkix_Extension len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_pkix_Extension([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_pkix_Extension_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_pkix_Extension_len(self.handle)
				return Slice_pkix_Extension(handle=_rest.Slice_pkix_Extension_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_Extension(handle=_rest.Slice_pkix_Extension_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_pkix_Extension_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_Extension.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_Extension(handle=_rest.Slice_pkix_Extension_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_pkix_Extension_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.RevokedCertificate
class Slice_pkix_RevokedCertificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_pkix_RevokedCertificate_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_RevokedCertificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_pkix_RevokedCertificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_pkix_RevokedCertificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_pkix_RevokedCertificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_pkix_RevokedCertificate_len(self.handle)
				return Slice_pkix_RevokedCertificate(handle=_rest.Slice_pkix_RevokedCertificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_RevokedCertificate(handle=_rest.Slice_pkix_RevokedCertificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_pkix_RevokedCertificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_RevokedCertificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_RevokedCertificate(handle=_rest.Slice_pkix_RevokedCertificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_pkix_RevokedCertificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []asn1.ObjectIdentifier
class Slice_asn1_ObjectIdentifier(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_asn1_ObjectIdentifier_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_asn1_ObjectIdentifier.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_asn1_ObjectIdentifier len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_asn1_ObjectIdentifier([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_asn1_ObjectIdentifier_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_asn1_ObjectIdentifier_len(self.handle)
				return Slice_asn1_ObjectIdentifier(handle=_rest.Slice_asn1_ObjectIdentifier_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.asn1_ObjectIdentifier(handle=_rest.Slice_asn1_ObjectIdentifier_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_asn1_ObjectIdentifier_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_asn1_ObjectIdentifier.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.asn1_ObjectIdentifier(handle=_rest.Slice_asn1_ObjectIdentifier_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_asn1_ObjectIdentifier_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []runtime.Object
class Slice_runtime_Object(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_runtime_Object_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_runtime_Object.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_runtime_Object len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_runtime_Object([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_runtime_Object_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_runtime_Object_len(self.handle)
				return Slice_runtime_Object(handle=_rest.Slice_runtime_Object_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.runtime_Object(handle=_rest.Slice_runtime_Object_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_runtime_Object_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_runtime_Object.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.runtime_Object(handle=_rest.Slice_runtime_Object_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_runtime_Object_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []runtime.SerializerInfo
class Slice_runtime_SerializerInfo(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_runtime_SerializerInfo_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_runtime_SerializerInfo.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_runtime_SerializerInfo len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_runtime_SerializerInfo([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_runtime_SerializerInfo_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_runtime_SerializerInfo_len(self.handle)
				return Slice_runtime_SerializerInfo(handle=_rest.Slice_runtime_SerializerInfo_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.runtime_SerializerInfo(handle=_rest.Slice_runtime_SerializerInfo_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_runtime_SerializerInfo_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_runtime_SerializerInfo.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.runtime_SerializerInfo(handle=_rest.Slice_runtime_SerializerInfo_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_runtime_SerializerInfo_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []schema.GroupVersion
class Slice_schema_GroupVersion(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_schema_GroupVersion_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_schema_GroupVersion.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_schema_GroupVersion len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_schema_GroupVersion([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_schema_GroupVersion_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_schema_GroupVersion_len(self.handle)
				return Slice_schema_GroupVersion(handle=_rest.Slice_schema_GroupVersion_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.schema_GroupVersion(handle=_rest.Slice_schema_GroupVersion_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_schema_GroupVersion_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_schema_GroupVersion.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.schema_GroupVersion(handle=_rest.Slice_schema_GroupVersion_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_schema_GroupVersion_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []schema.GroupVersionKind
class Slice_schema_GroupVersionKind(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_schema_GroupVersionKind_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_schema_GroupVersionKind.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_schema_GroupVersionKind len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_schema_GroupVersionKind([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_schema_GroupVersionKind_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_schema_GroupVersionKind_len(self.handle)
				return Slice_schema_GroupVersionKind(handle=_rest.Slice_schema_GroupVersionKind_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.schema_GroupVersionKind(handle=_rest.Slice_schema_GroupVersionKind_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_schema_GroupVersionKind_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_schema_GroupVersionKind.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.schema_GroupVersionKind(handle=_rest.Slice_schema_GroupVersionKind_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_schema_GroupVersionKind_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []s1_net.WarningHeader
class Slice_s1_net_WarningHeader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_s1_net_WarningHeader_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_s1_net_WarningHeader.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_s1_net_WarningHeader len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_s1_net_WarningHeader([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_s1_net_WarningHeader_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_s1_net_WarningHeader_len(self.handle)
				return Slice_s1_net_WarningHeader(handle=_rest.Slice_s1_net_WarningHeader_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.s1_net_WarningHeader(handle=_rest.Slice_s1_net_WarningHeader_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_s1_net_WarningHeader_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_s1_net_WarningHeader.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.s1_net_WarningHeader(handle=_rest.Slice_s1_net_WarningHeader_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_s1_net_WarningHeader_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []api.ExecEnvVar
class Slice_api_ExecEnvVar(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_api_ExecEnvVar_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_api_ExecEnvVar.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_api_ExecEnvVar len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_api_ExecEnvVar([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_api_ExecEnvVar_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_api_ExecEnvVar_len(self.handle)
				return Slice_api_ExecEnvVar(handle=_rest.Slice_api_ExecEnvVar_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.api_ExecEnvVar(handle=_rest.Slice_api_ExecEnvVar_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_api_ExecEnvVar_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_api_ExecEnvVar.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.api_ExecEnvVar(handle=_rest.Slice_api_ExecEnvVar_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_api_ExecEnvVar_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []big.Word
class Slice_big_Word(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_big_Word_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_big_Word.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_big_Word len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_big_Word([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_big_Word_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_big_Word_len(self.handle)
				return Slice_big_Word(handle=_rest.Slice_big_Word_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _rest.Slice_big_Word_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_big_Word_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_big_Word.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _rest.Slice_big_Word_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_big_Word_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []net.IP
class Slice_net_IP(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Slice_net_IP_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_net_IP.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Slice_net_IP len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'rest.Slice_net_IP([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _rest.Slice_net_IP_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _rest.Slice_net_IP_len(self.handle)
				return Slice_net_IP(handle=_rest.Slice_net_IP_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.net_IP(handle=_rest.Slice_net_IP_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_rest.Slice_net_IP_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_net_IP.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.net_IP(handle=_rest.Slice_net_IP_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_rest.Slice_net_IP_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[schema.GroupVersionKind]reflect.Type
class Map_schema_GroupVersionKind_reflect_Type(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Map_schema_GroupVersionKind_reflect_Type_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_schema_GroupVersionKind_reflect_Type.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_rest.Map_schema_GroupVersionKind_reflect_Type_set(self.handle, k, v)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Map_schema_GroupVersionKind_reflect_Type len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'rest.Map_schema_GroupVersionKind_reflect_Type({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _rest.Map_schema_GroupVersionKind_reflect_Type_len(self.handle)
	def __getitem__(self, key):
		return go.reflect_Type(handle=_rest.Map_schema_GroupVersionKind_reflect_Type_elem(self.handle, key.handle))
	def __setitem__(self, key, value):
		_rest.Map_schema_GroupVersionKind_reflect_Type_set(self.handle, key.handle, value.handle)
	def __delitem__(self, key):
		return _rest.Map_schema_GroupVersionKind_reflect_Type_delete(self.handle, key.handle)
	def keys(self):
		return Slice_schema_GroupVersionKind(handle=_rest.Map_schema_GroupVersionKind_reflect_Type_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _rest.Map_schema_GroupVersionKind_reflect_Type_contains(self.handle, key.handle)

# Python type for map map[string]*tls.Certificate
class Map_string_Ptr_tls_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Map_string_Ptr_tls_Certificate_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Ptr_tls_Certificate.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_rest.Map_string_Ptr_tls_Certificate_set(self.handle, k, v)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Map_string_Ptr_tls_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'rest.Map_string_Ptr_tls_Certificate({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _rest.Map_string_Ptr_tls_Certificate_len(self.handle)
	def __getitem__(self, key):
		return go.Ptr_tls_Certificate(handle=_rest.Map_string_Ptr_tls_Certificate_elem(self.handle, key))
	def __setitem__(self, key, value):
		_rest.Map_string_Ptr_tls_Certificate_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _rest.Map_string_Ptr_tls_Certificate_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_rest.Map_string_Ptr_tls_Certificate_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _rest.Map_string_Ptr_tls_Certificate_contains(self.handle, key)

# Python type for map map[string][]*multipart.FileHeader
class Map_string_Slice_Ptr_multipart_FileHeader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Map_string_Slice_Ptr_multipart_FileHeader_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_Ptr_multipart_FileHeader.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_rest.Map_string_Slice_Ptr_multipart_FileHeader_set(self.handle, k, v)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Map_string_Slice_Ptr_multipart_FileHeader len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'rest.Map_string_Slice_Ptr_multipart_FileHeader({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _rest.Map_string_Slice_Ptr_multipart_FileHeader_len(self.handle)
	def __getitem__(self, key):
		return Slice_Ptr_multipart_FileHeader(handle=_rest.Map_string_Slice_Ptr_multipart_FileHeader_elem(self.handle, key))
	def __setitem__(self, key, value):
		_rest.Map_string_Slice_Ptr_multipart_FileHeader_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _rest.Map_string_Slice_Ptr_multipart_FileHeader_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_rest.Map_string_Slice_Ptr_multipart_FileHeader_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _rest.Map_string_Slice_Ptr_multipart_FileHeader_contains(self.handle, key)

# Python type for map map[string][]string
class Map_string_Slice_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Map_string_Slice_string_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_rest.Map_string_Slice_string_set(self.handle, k, v)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Map_string_Slice_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'rest.Map_string_Slice_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _rest.Map_string_Slice_string_len(self.handle)
	def __getitem__(self, key):
		return go.Slice_string(handle=_rest.Map_string_Slice_string_elem(self.handle, key))
	def __setitem__(self, key, value):
		_rest.Map_string_Slice_string_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _rest.Map_string_Slice_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_rest.Map_string_Slice_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _rest.Map_string_Slice_string_contains(self.handle, key)

# Python type for map map[string]bool
class Map_string_bool(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Map_string_bool_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_bool.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_rest.Map_string_bool_set(self.handle, k, v)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Map_string_bool len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'rest.Map_string_bool({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _rest.Map_string_bool_len(self.handle)
	def __getitem__(self, key):
		return _rest.Map_string_bool_elem(self.handle, key)
	def __setitem__(self, key, value):
		_rest.Map_string_bool_set(self.handle, key, value)
	def __delitem__(self, key):
		return _rest.Map_string_bool_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_rest.Map_string_bool_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _rest.Map_string_bool_contains(self.handle, key)

# Python type for map map[string]reflect.Type
class Map_string_reflect_Type(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Map_string_reflect_Type_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_reflect_Type.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_rest.Map_string_reflect_Type_set(self.handle, k, v)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Map_string_reflect_Type len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'rest.Map_string_reflect_Type({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _rest.Map_string_reflect_Type_len(self.handle)
	def __getitem__(self, key):
		return go.reflect_Type(handle=_rest.Map_string_reflect_Type_elem(self.handle, key))
	def __setitem__(self, key, value):
		_rest.Map_string_reflect_Type_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _rest.Map_string_reflect_Type_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_rest.Map_string_reflect_Type_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _rest.Map_string_reflect_Type_contains(self.handle, key)

# Python type for map map[string]string
class Map_string_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.Map_string_string_CTor()
			_rest.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_rest.Map_string_string_set(self.handle, k, v)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		s = 'rest.Map_string_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'rest.Map_string_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _rest.Map_string_string_len(self.handle)
	def __getitem__(self, key):
		return _rest.Map_string_string_elem(self.handle, key)
	def __setitem__(self, key, value):
		_rest.Map_string_string_set(self.handle, key, value)
	def __delitem__(self, key):
		return _rest.Map_string_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_rest.Map_string_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _rest.Map_string_string_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---
DefaultBurst = 10
DefaultQPS = 5


# ---- Global Variables: can only use functions to access ---
def NameMayNotBe():
	"""
	NameMayNotBe Gets Go Variable: rest.NameMayNotBe
	NameMayNotBe specifies strings that cannot be used as names specified as path segments (like the REST API or etcd store)
	
	"""
	return go.Slice_string(handle=_rest.rest_NameMayNotBe())

def Set_NameMayNotBe(value):
	"""
	Set_NameMayNotBe Sets Go Variable: rest.NameMayNotBe
	NameMayNotBe specifies strings that cannot be used as names specified as path segments (like the REST API or etcd store)
	
	"""
	if isinstance(value, go.GoClass):
		_rest.rest_Set_NameMayNotBe(value.handle)
	else:
		_rest.rest_Set_NameMayNotBe(value)

def NameMayNotContain():
	"""
	NameMayNotContain Gets Go Variable: rest.NameMayNotContain
	NameMayNotContain specifies substrings that cannot be used in names specified as path segments (like the REST API or etcd store)
	
	"""
	return go.Slice_string(handle=_rest.rest_NameMayNotContain())

def Set_NameMayNotContain(value):
	"""
	Set_NameMayNotContain Sets Go Variable: rest.NameMayNotContain
	NameMayNotContain specifies substrings that cannot be used in names specified as path segments (like the REST API or etcd store)
	
	"""
	if isinstance(value, go.GoClass):
		_rest.rest_Set_NameMayNotContain(value.handle)
	else:
		_rest.rest_Set_NameMayNotContain(value)



# ---- Interfaces ---

# Python type for interface rest.WarningHandler
class WarningHandler(go.GoClass):
	"""WarningHandler is an interface for handling warning headers\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = 0
	def HandleWarningHeader(self, code, agent, text, goRun=False):
		"""HandleWarningHeader(int code, str agent, str text) """
		_rest.rest_WarningHandler_HandleWarningHeader(self.handle, code, agent, text, goRun)

# Python type for interface rest.WithRetry
class WithRetry(go.GoClass):
	"""WithRetry allows the client to retry a request up to a certain number of times\nNote that WithRetry is not safe for concurrent use by multiple\ngoroutines without additional locking or coordination.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = 0
	def After(self, ctx, r, resp, err, goRun=False):
		"""After(object ctx, object r, object resp, str err) """
		_rest.rest_WithRetry_After(self.handle, ctx.handle, r.handle, resp.handle, err, goRun)
	def Before(self, ctx, r):
		"""Before(object ctx, object r) str"""
		return _rest.rest_WithRetry_Before(self.handle, ctx.handle, r.handle)
	def WrapPreviousError(self, finalErr):
		"""WrapPreviousError(str finalErr) str err"""
		return _rest.rest_WithRetry_WrapPreviousError(self.handle, finalErr)

# Python type for interface rest.AuthProvider
class AuthProvider(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = 0
	def Login(self):
		"""Login() str"""
		return _rest.rest_AuthProvider_Login(self.handle)
	def WrapTransport(self, arg_0):
		"""WrapTransport(object) object"""
		return go.http_RoundTripper(handle=_rest.rest_AuthProvider_WrapTransport(self.handle, arg_0.handle))

# Python type for interface rest.AuthProviderConfigPersister
class AuthProviderConfigPersister(go.GoClass):
	"""AuthProviderConfigPersister allows a plugin to persist configuration info\nfor just itself.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = 0
	def Persist(self, arg_0):
		"""Persist(object) str"""
		return _rest.rest_AuthProviderConfigPersister_Persist(self.handle, arg_0.handle)

# Python type for interface rest.BackoffManager
class BackoffManager(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = 0
	def CalculateBackoff(self, actualUrl):
		"""CalculateBackoff(object actualUrl) long"""
		return _rest.rest_BackoffManager_CalculateBackoff(self.handle, actualUrl.handle)
	def Sleep(self, d, goRun=False):
		"""Sleep(long d) """
		_rest.rest_BackoffManager_Sleep(self.handle, d, goRun)
	def UpdateBackoff(self, actualUrl, err, responseCode, goRun=False):
		"""UpdateBackoff(object actualUrl, str err, int responseCode) """
		_rest.rest_BackoffManager_UpdateBackoff(self.handle, actualUrl.handle, err, responseCode, goRun)

# Python type for interface rest.HTTPClient
class HTTPClient(go.GoClass):
	"""HTTPClient is an interface for testing a request object.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = 0
	def Do(self, req):
		"""Do(object req) object, str"""
		return go.Ptr_http_Response(handle=_rest.rest_HTTPClient_Do(self.handle, req.handle))

# Python type for interface rest.Interface
class Interface(go.GoClass):
	"""Interface captures the set of operations for generically interacting with Kubernetes REST apis.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = 0
	def APIVersion(self):
		"""APIVersion() object"""
		return go.schema_GroupVersion(handle=_rest.rest_Interface_APIVersion(self.handle))
	def Delete(self):
		"""Delete() object"""
		return Request(handle=_rest.rest_Interface_Delete(self.handle))
	def Get(self):
		"""Get() object"""
		return Request(handle=_rest.rest_Interface_Get(self.handle))
	def GetRateLimiter(self):
		"""GetRateLimiter() object"""
		return go.flowcontrol_RateLimiter(handle=_rest.rest_Interface_GetRateLimiter(self.handle))
	def Patch(self, pt):
		"""Patch(str pt) object"""
		return Request(handle=_rest.rest_Interface_Patch(self.handle, pt))
	def Post(self):
		"""Post() object"""
		return Request(handle=_rest.rest_Interface_Post(self.handle))
	def Put(self):
		"""Put() object"""
		return Request(handle=_rest.rest_Interface_Put(self.handle))
	def Verb(self, verb):
		"""Verb(str verb) object"""
		return Request(handle=_rest.rest_Interface_Verb(self.handle, verb))

# Python type for interface rest.ResponseWrapper
class ResponseWrapper(go.GoClass):
	"""ResponseWrapper is an interface for getting a response.\nThe response may be either accessed as a raw data (the whole output is put into memory) or as a stream.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = 0
	def DoRaw(self, arg_0):
		"""DoRaw(object) []int, str"""
		return go.Slice_byte(handle=_rest.rest_ResponseWrapper_DoRaw(self.handle, arg_0.handle))
	def Stream(self, arg_0):
		"""Stream(object) object, str"""
		return go.io_ReadCloser(handle=_rest.rest_ResponseWrapper_Stream(self.handle, arg_0.handle))


# ---- Structs ---

# Python type for struct rest.Config
class Config(go.GoClass):
	"""Config holds the common attributes that can be passed to a Kubernetes client on\ninitialization.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_Config_CTor()
			_rest.IncRef(self.handle)
			if  0 < len(args):
				self.Host = args[0]
			if "Host" in kwargs:
				self.Host = kwargs["Host"]
			if  1 < len(args):
				self.APIPath = args[1]
			if "APIPath" in kwargs:
				self.APIPath = kwargs["APIPath"]
			if  3 < len(args):
				self.Username = args[3]
			if "Username" in kwargs:
				self.Username = kwargs["Username"]
			if  4 < len(args):
				self.Password = args[4]
			if "Password" in kwargs:
				self.Password = kwargs["Password"]
			if  5 < len(args):
				self.BearerToken = args[5]
			if "BearerToken" in kwargs:
				self.BearerToken = kwargs["BearerToken"]
			if  6 < len(args):
				self.BearerTokenFile = args[6]
			if "BearerTokenFile" in kwargs:
				self.BearerTokenFile = kwargs["BearerTokenFile"]
			if  7 < len(args):
				self.Impersonate = args[7]
			if "Impersonate" in kwargs:
				self.Impersonate = kwargs["Impersonate"]
			if  8 < len(args):
				self.AuthProvider = args[8]
			if "AuthProvider" in kwargs:
				self.AuthProvider = kwargs["AuthProvider"]
			if  9 < len(args):
				self.AuthConfigPersister = args[9]
			if "AuthConfigPersister" in kwargs:
				self.AuthConfigPersister = kwargs["AuthConfigPersister"]
			if  10 < len(args):
				self.ExecProvider = args[10]
			if "ExecProvider" in kwargs:
				self.ExecProvider = kwargs["ExecProvider"]
			if  12 < len(args):
				self.UserAgent = args[12]
			if "UserAgent" in kwargs:
				self.UserAgent = kwargs["UserAgent"]
			if  13 < len(args):
				self.DisableCompression = args[13]
			if "DisableCompression" in kwargs:
				self.DisableCompression = kwargs["DisableCompression"]
			if  14 < len(args):
				self.Transport = args[14]
			if "Transport" in kwargs:
				self.Transport = kwargs["Transport"]
			if  16 < len(args):
				self.QPS = args[16]
			if "QPS" in kwargs:
				self.QPS = kwargs["QPS"]
			if  17 < len(args):
				self.Burst = args[17]
			if "Burst" in kwargs:
				self.Burst = kwargs["Burst"]
			if  18 < len(args):
				self.RateLimiter = args[18]
			if "RateLimiter" in kwargs:
				self.RateLimiter = kwargs["RateLimiter"]
			if  19 < len(args):
				self.WarningHandler = args[19]
			if "WarningHandler" in kwargs:
				self.WarningHandler = kwargs["WarningHandler"]
			if  20 < len(args):
				self.Timeout = args[20]
			if "Timeout" in kwargs:
				self.Timeout = kwargs["Timeout"]
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		return self.String()
	
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.Config ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Host(self):
		"""Host must be a host string, a host:port pair, or a URL to the base of the apiserver.
		If a URL is given then the (optional) Path of that URL represents a prefix that must
		be appended to all request URIs used to access the apiserver. This allows a frontend
		proxy to easily relocate all of the apiserver endpoints.
		"""
		return _rest.rest_Config_Host_Get(self.handle)
	@Host.setter
	def Host(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_Host_Set(self.handle, value.handle)
		else:
			_rest.rest_Config_Host_Set(self.handle, value)
	@property
	def APIPath(self):
		"""APIPath is a sub-path that points to an API root.
		"""
		return _rest.rest_Config_APIPath_Get(self.handle)
	@APIPath.setter
	def APIPath(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_APIPath_Set(self.handle, value.handle)
		else:
			_rest.rest_Config_APIPath_Set(self.handle, value)
	@property
	def Username(self):
		"""Server requires Basic authentication
		"""
		return _rest.rest_Config_Username_Get(self.handle)
	@Username.setter
	def Username(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_Username_Set(self.handle, value.handle)
		else:
			_rest.rest_Config_Username_Set(self.handle, value)
	@property
	def Password(self):
		return _rest.rest_Config_Password_Get(self.handle)
	@Password.setter
	def Password(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_Password_Set(self.handle, value.handle)
		else:
			_rest.rest_Config_Password_Set(self.handle, value)
	@property
	def BearerToken(self):
		"""Server requires Bearer authentication. This client will not attempt to use
		refresh tokens for an OAuth2 flow.
		TODO: demonstrate an OAuth2 compatible client.
		"""
		return _rest.rest_Config_BearerToken_Get(self.handle)
	@BearerToken.setter
	def BearerToken(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_BearerToken_Set(self.handle, value.handle)
		else:
			_rest.rest_Config_BearerToken_Set(self.handle, value)
	@property
	def BearerTokenFile(self):
		"""Path to a file containing a BearerToken.
		If set, the contents are periodically read.
		The last successfully read value takes precedence over BearerToken.
		"""
		return _rest.rest_Config_BearerTokenFile_Get(self.handle)
	@BearerTokenFile.setter
	def BearerTokenFile(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_BearerTokenFile_Set(self.handle, value.handle)
		else:
			_rest.rest_Config_BearerTokenFile_Set(self.handle, value)
	@property
	def Impersonate(self):
		"""Impersonate is the configuration that RESTClient will use for impersonation.
		"""
		return ImpersonationConfig(handle=_rest.rest_Config_Impersonate_Get(self.handle))
	@Impersonate.setter
	def Impersonate(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_Impersonate_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AuthProvider(self):
		"""Server requires plugin-specified authentication.
		"""
		return go.Ptr_api_AuthProviderConfig(handle=_rest.rest_Config_AuthProvider_Get(self.handle))
	@AuthProvider.setter
	def AuthProvider(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_AuthProvider_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def AuthConfigPersister(self):
		"""Callback to persist config for AuthProvider.
		"""
		return AuthProviderConfigPersister(handle=_rest.rest_Config_AuthConfigPersister_Get(self.handle))
	@AuthConfigPersister.setter
	def AuthConfigPersister(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_AuthConfigPersister_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ExecProvider(self):
		"""Exec-based authentication provider.
		"""
		return go.Ptr_api_ExecConfig(handle=_rest.rest_Config_ExecProvider_Get(self.handle))
	@ExecProvider.setter
	def ExecProvider(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_ExecProvider_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def UserAgent(self):
		"""UserAgent is an optional field that specifies the caller of this request.
		"""
		return _rest.rest_Config_UserAgent_Get(self.handle)
	@UserAgent.setter
	def UserAgent(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_UserAgent_Set(self.handle, value.handle)
		else:
			_rest.rest_Config_UserAgent_Set(self.handle, value)
	@property
	def DisableCompression(self):
		"""DisableCompression bypasses automatic GZip compression requests to the
		server.
		"""
		return _rest.rest_Config_DisableCompression_Get(self.handle)
	@DisableCompression.setter
	def DisableCompression(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_DisableCompression_Set(self.handle, value.handle)
		else:
			_rest.rest_Config_DisableCompression_Set(self.handle, value)
	@property
	def Transport(self):
		"""Transport may be used for custom HTTP behavior. This attribute may not
		be specified with the TLS client certificate options. Use WrapTransport
		to provide additional per-server middleware behavior.
		"""
		return go.http_RoundTripper(handle=_rest.rest_Config_Transport_Get(self.handle))
	@Transport.setter
	def Transport(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_Transport_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def QPS(self):
		"""QPS indicates the maximum QPS to the master from this client.
		If it's zero, the created RESTClient will use DefaultQPS: 5
		
		Setting this to a negative value will disable client-side ratelimiting
		unless `Ratelimiter` is also set.
		"""
		return _rest.rest_Config_QPS_Get(self.handle)
	@QPS.setter
	def QPS(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_QPS_Set(self.handle, value.handle)
		else:
			_rest.rest_Config_QPS_Set(self.handle, value)
	@property
	def Burst(self):
		"""Maximum burst for throttle.
		If it's zero, the created RESTClient will use DefaultBurst: 10.
		"""
		return _rest.rest_Config_Burst_Get(self.handle)
	@Burst.setter
	def Burst(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_Burst_Set(self.handle, value.handle)
		else:
			_rest.rest_Config_Burst_Set(self.handle, value)
	@property
	def RateLimiter(self):
		"""Rate limiter for limiting connections to the master from this client. If present overwrites QPS/Burst
		"""
		return go.flowcontrol_RateLimiter(handle=_rest.rest_Config_RateLimiter_Get(self.handle))
	@RateLimiter.setter
	def RateLimiter(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_RateLimiter_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def WarningHandler(self):
		"""WarningHandler handles warnings in server responses.
		If not set, the default warning handler is used.
		See documentation for SetDefaultWarningHandler() for details.
		"""
		return WarningHandler(handle=_rest.rest_Config_WarningHandler_Get(self.handle))
	@WarningHandler.setter
	def WarningHandler(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_WarningHandler_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Timeout(self):
		"""The maximum length of time to wait before giving up on a server request. A value of zero means no timeout.
		"""
		return _rest.rest_Config_Timeout_Get(self.handle)
	@Timeout.setter
	def Timeout(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_Config_Timeout_Set(self.handle, value.handle)
		else:
			_rest.rest_Config_Timeout_Set(self.handle, value)
	def GoString(self):
		"""GoString() str
		
		GoString implements fmt.GoStringer and sanitizes sensitive fields of Config
		to prevent accidental leaking via logs.
		"""
		return _rest.rest_Config_GoString(self.handle)
	def String(self):
		"""String() str
		
		String implements fmt.Stringer and sanitizes sensitive fields of Config to
		prevent accidental leaking via logs.
		"""
		return _rest.rest_Config_String(self.handle)
	def TransportConfig(self):
		"""TransportConfig() object, str
		
		TransportConfig converts a client config to an appropriate transport config.
		"""
		return go.Ptr_transport_Config(handle=_rest.rest_Config_TransportConfig(self.handle))

# Python type for struct rest.RESTClient
class RESTClient(go.GoClass):
	"""RESTClient imposes common Kubernetes API conventions on a set of resource paths.\nThe baseURL is expected to point to an HTTP or HTTPS path that is the parent\nof one or more resources.  The server should return a decodable API resource\nobject, or an api.Status object which contains information about the reason for\nany failure.\n\nMost consumers should use client.New() to get a Kubernetes API client.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_RESTClient_CTor()
			_rest.IncRef(self.handle)
			if  6 < len(args):
				self.Client = args[6]
			if "Client" in kwargs:
				self.Client = kwargs["Client"]
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.RESTClient{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.RESTClient ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Client(self):
		"""Set specific behavior of the client.  If not set http.DefaultClient will be used.
		"""
		return go.Ptr_http_Client(handle=_rest.rest_RESTClient_Client_Get(self.handle))
	@Client.setter
	def Client(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_RESTClient_Client_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def GetRateLimiter(self):
		"""GetRateLimiter() object
		
		GetRateLimiter returns rate limiter for a given client, or nil if it's called on a nil client
		"""
		return go.flowcontrol_RateLimiter(handle=_rest.rest_RESTClient_GetRateLimiter(self.handle))
	def Verb(self, verb):
		"""Verb(str verb) object
		
		Verb begins a request with a verb (GET, POST, PUT, DELETE).
		
		Example usage of RESTClient's request building interface:
		c, err := NewRESTClient(...)
		if err != nil { ... }
		resp, err := c.Verb("GET").
		
			Path("pods").
			SelectorParam("labels", "area=staging").
			Timeout(10*time.Second).
			Do()
		
		if err != nil { ... }
		list, ok := resp.(*api.PodList)
		"""
		return Request(handle=_rest.rest_RESTClient_Verb(self.handle, verb))
	def Post(self):
		"""Post() object
		
		Post begins a POST request. Short for c.Verb("POST").
		"""
		return Request(handle=_rest.rest_RESTClient_Post(self.handle))
	def Put(self):
		"""Put() object
		
		Put begins a PUT request. Short for c.Verb("PUT").
		"""
		return Request(handle=_rest.rest_RESTClient_Put(self.handle))
	def Patch(self, pt):
		"""Patch(str pt) object
		
		Patch begins a PATCH request. Short for c.Verb("Patch").
		"""
		return Request(handle=_rest.rest_RESTClient_Patch(self.handle, pt))
	def Get(self):
		"""Get() object
		
		Get begins a GET request. Short for c.Verb("GET").
		"""
		return Request(handle=_rest.rest_RESTClient_Get(self.handle))
	def Delete(self):
		"""Delete() object
		
		Delete begins a DELETE request. Short for c.Verb("DELETE").
		"""
		return Request(handle=_rest.rest_RESTClient_Delete(self.handle))
	def APIVersion(self):
		"""APIVersion() object
		
		APIVersion returns the APIVersion this RESTClient is expected to use.
		"""
		return go.schema_GroupVersion(handle=_rest.rest_RESTClient_APIVersion(self.handle))

# Python type for struct rest.Request
class Request(go.GoClass):
	"""Request allows for building up a request to a server in a chained fashion.\nAny errors are stored until the end of your call, so you only have to\ncheck once.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_Request_CTor()
			_rest.IncRef(self.handle)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.Request{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.Request ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def UseProtobufAsDefaultIfPreferred(self, prefersProtobuf):
		"""UseProtobufAsDefaultIfPreferred(bool prefersProtobuf) object"""
		return Request(handle=_rest.rest_Request_UseProtobufAsDefaultIfPreferred(self.handle, prefersProtobuf))
	def UseProtobufAsDefault(self):
		"""UseProtobufAsDefault() object"""
		return Request(handle=_rest.rest_Request_UseProtobufAsDefault(self.handle))
	def Verb(self, verb):
		"""Verb(str verb) object
		
		Verb sets the verb this request will use.
		"""
		return Request(handle=_rest.rest_Request_Verb(self.handle, verb))
	def Prefix(self, *args):
		"""Prefix([]str segments) object
		
		Prefix adds segments to the relative beginning to the request path. These
		items will be placed before the optional Namespace, Resource, or Name sections.
		Setting AbsPath will clear any previously set Prefix segments
		"""
		segments = go.Slice_string(args)
		return Request(handle=_rest.rest_Request_Prefix(self.handle, segments.handle))
	def Suffix(self, *args):
		"""Suffix([]str segments) object
		
		Suffix appends segments to the end of the path. These items will be placed after the prefix and optional
		Namespace, Resource, or Name sections.
		"""
		segments = go.Slice_string(args)
		return Request(handle=_rest.rest_Request_Suffix(self.handle, segments.handle))
	def Resource(self, resource):
		"""Resource(str resource) object
		
		Resource sets the resource to access (<resource>/[ns/<namespace>/]<name>)
		"""
		return Request(handle=_rest.rest_Request_Resource(self.handle, resource))
	def BackOff(self, manager):
		"""BackOff(object manager) object
		
		BackOff sets the request's backoff manager to the one specified,
		or defaults to the stub implementation if nil is provided
		"""
		return Request(handle=_rest.rest_Request_BackOff(self.handle, manager.handle))
	def WarningHandler(self, handler):
		"""WarningHandler(object handler) object
		
		WarningHandler sets the handler this client uses when warning headers are encountered.
		If set to nil, this client will use the default warning handler (see SetDefaultWarningHandler).
		"""
		return Request(handle=_rest.rest_Request_WarningHandler(self.handle, handler.handle))
	def Throttle(self, limiter):
		"""Throttle(object limiter) object
		
		Throttle receives a rate-limiter and sets or replaces an existing request limiter
		"""
		return Request(handle=_rest.rest_Request_Throttle(self.handle, limiter.handle))
	def SubResource(self, *args):
		"""SubResource([]str subresources) object
		
		SubResource sets a sub-resource path which can be multiple segments after the resource
		name but before the suffix.
		"""
		subresources = go.Slice_string(args)
		return Request(handle=_rest.rest_Request_SubResource(self.handle, subresources.handle))
	def Name(self, resourceName):
		"""Name(str resourceName) object
		
		Name sets the name of a resource to access (<resource>/[ns/<namespace>/]<name>)
		"""
		return Request(handle=_rest.rest_Request_Name(self.handle, resourceName))
	def Namespace(self, namespace):
		"""Namespace(str namespace) object
		
		Namespace applies the namespace scope to a request (<resource>/[ns/<namespace>/]<name>)
		"""
		return Request(handle=_rest.rest_Request_Namespace(self.handle, namespace))
	def NamespaceIfScoped(self, namespace, scoped):
		"""NamespaceIfScoped(str namespace, bool scoped) object
		
		NamespaceIfScoped is a convenience function to set a namespace if scoped is true
		"""
		return Request(handle=_rest.rest_Request_NamespaceIfScoped(self.handle, namespace, scoped))
	def AbsPath(self, *args):
		"""AbsPath([]str segments) object
		
		AbsPath overwrites an existing path with the segments provided. Trailing slashes are preserved
		when a single segment is passed.
		"""
		segments = go.Slice_string(args)
		return Request(handle=_rest.rest_Request_AbsPath(self.handle, segments.handle))
	def RequestURI(self, uri):
		"""RequestURI(str uri) object
		
		RequestURI overwrites existing path and parameters with the value of the provided server relative
		URI.
		"""
		return Request(handle=_rest.rest_Request_RequestURI(self.handle, uri))
	def Param(self, paramName, s):
		"""Param(str paramName, str s) object
		
		Param creates a query parameter with the given string value.
		"""
		return Request(handle=_rest.rest_Request_Param(self.handle, paramName, s))
	def VersionedParams(self, obj, codec):
		"""VersionedParams(object obj, object codec) object
		
		VersionedParams will take the provided object, serialize it to a map[string][]string using the
		implicit RESTClient API version and the default parameter codec, and then add those as parameters
		to the request. Use this to provide versioned query parameters from client libraries.
		VersionedParams will not write query parameters that have omitempty set and are empty. If a
		parameter has already been set it is appended to (Params and VersionedParams are additive).
		"""
		return Request(handle=_rest.rest_Request_VersionedParams(self.handle, obj.handle, codec.handle))
	def SpecificallyVersionedParams(self, obj, codec, version):
		"""SpecificallyVersionedParams(object obj, object codec, object version) object"""
		return Request(handle=_rest.rest_Request_SpecificallyVersionedParams(self.handle, obj.handle, codec.handle, version.handle))
	def SetHeader(self, key, *args):
		"""SetHeader(str key, []str values) object"""
		values = go.Slice_string(args)
		return Request(handle=_rest.rest_Request_SetHeader(self.handle, key, values.handle))
	def Timeout(self, d):
		"""Timeout(long d) object
		
		Timeout makes the request use the given duration as an overall timeout for the
		request. Additionally, if set passes the value as "timeout" parameter in URL.
		"""
		return Request(handle=_rest.rest_Request_Timeout(self.handle, d))
	def MaxRetries(self, maxRetries):
		"""MaxRetries(int maxRetries) object
		
		MaxRetries makes the request use the given integer as a ceiling of retrying upon receiving
		"Retry-After" headers and 429 status-code in the response. The default is 10 unless this
		function is specifically called with a different value.
		A zero maxRetries prevent it from doing retires and return an error immediately.
		"""
		return Request(handle=_rest.rest_Request_MaxRetries(self.handle, maxRetries))
	def Body(self, obj):
		"""Body(str obj) object
		
		Body makes the request use obj as the body. Optional.
		If obj is a string, try to read a file of that name.
		If obj is a []byte, send it directly.
		If obj is an io.Reader, use it directly.
		If obj is a runtime.Object, marshal it correctly, and set Content-Type header.
		If obj is a runtime.Object and nil, do nothing.
		Otherwise, set an error.
		"""
		return Request(handle=_rest.rest_Request_Body(self.handle, obj))
	def Error(self):
		"""Error() str
		
		Error returns any error encountered constructing the request, if any.
		"""
		return _rest.rest_Request_Error(self.handle)
	def URL(self):
		"""URL() object
		
		URL returns the current working URL. Check the result of Error() to ensure
		that the returned URL is valid.
		"""
		return go.Ptr_url_URL(handle=_rest.rest_Request_URL(self.handle))
	def Watch(self, ctx):
		"""Watch(object ctx) object, str
		
		Watch attempts to begin watching the requested location.
		Returns a watch.Interface, or an error.
		"""
		return go.watch_Interface(handle=_rest.rest_Request_Watch(self.handle, ctx.handle))
	def WatchList(self, ctx):
		"""WatchList(object ctx) object
		
		WatchList establishes a stream to get a consistent snapshot of data
		from the server as described in https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/3157-watch-list#proposal
		
		Note that the watchlist requires properly setting the ListOptions
		otherwise it just establishes a regular watch with the server.
		Check the documentation https://kubernetes.io/docs/reference/using-api/api-concepts/#streaming-lists
		to see what parameters are currently required.
		"""
		return WatchListResult(handle=_rest.rest_Request_WatchList(self.handle, ctx.handle))
	def Stream(self, ctx):
		"""Stream(object ctx) object, str
		
		Stream formats and executes the request, and offers streaming of the response.
		Returns io.ReadCloser which could be used for streaming of the response, or an error
		Any non-2xx http status code causes an error.  If we get a non-2xx code, we try to convert the body into an APIStatus object.
		If we can, we return that as an error.  Otherwise, we create an error that lists the http status and the content of the response.
		"""
		return go.io_ReadCloser(handle=_rest.rest_Request_Stream(self.handle, ctx.handle))
	def Do(self, ctx):
		"""Do(object ctx) object
		
		Do formats and executes the request. Returns a Result object for easy response
		processing.
		
		Error type:
		  - If the server responds with a status: *errors.StatusError or *errors.UnexpectedObjectError
		  - http.Client.Do errors are returned directly.
		"""
		return Result(handle=_rest.rest_Request_Do(self.handle, ctx.handle))
	def DoRaw(self, ctx):
		"""DoRaw(object ctx) []int, str
		
		DoRaw executes the request but does not process the response body.
		"""
		return go.Slice_byte(handle=_rest.rest_Request_DoRaw(self.handle, ctx.handle))

# Python type for struct rest.RequestConstructionError
class RequestConstructionError(go.GoClass):
	"""RequestConstructionError is returned when there's an error assembling a request.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_RequestConstructionError_CTor()
			_rest.IncRef(self.handle)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.RequestConstructionError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.RequestConstructionError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Error(self):
		"""Error() str
		
		Error returns a textual description of 'r'.
		"""
		return _rest.rest_RequestConstructionError_Error(self.handle)

# Python type for struct rest.Result
class Result(go.GoClass):
	"""Result contains the result of calling Request.Do().\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_Result_CTor()
			_rest.IncRef(self.handle)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.Result{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.Result ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Raw(self):
		"""Raw() []int, str
		
		Raw returns the raw result.
		"""
		return go.Slice_byte(handle=_rest.rest_Result_Raw(self.handle))
	def Get(self):
		"""Get() object, str
		
		Get returns the result as an object, which means it passes through the decoder.
		If the returned object is of type Status and has .Status != StatusSuccess, the
		additional information in Status will be used to enrich the error.
		"""
		return go.runtime_Object(handle=_rest.rest_Result_Get(self.handle))
	def Into(self, obj):
		"""Into(object obj) str
		
		Into stores the result into obj, if possible. If obj is nil it is ignored.
		If the returned object is of type Status and has .Status != StatusSuccess, the
		additional information in Status will be used to enrich the error.
		"""
		return _rest.rest_Result_Into(self.handle, obj.handle)
	def Error(self):
		"""Error() str
		
		Error returns the error executing the request, nil if no error occurred.
		If the returned object is of type Status and has Status != StatusSuccess, the
		additional information in Status will be used to enrich the error.
		See the Request.Do() comment for what errors you might get.
		"""
		return _rest.rest_Result_Error(self.handle)
	def Warnings(self):
		"""Warnings() []object
		
		Warnings returns any warning headers received in the response
		"""
		return Slice_s1_net_WarningHeader(handle=_rest.rest_Result_Warnings(self.handle))

# Python type for struct rest.WarningWriterOptions
class WarningWriterOptions(go.GoClass):
	"""WarningWriterOptions controls the behavior of a WarningHandler constructed using NewWarningWriter()\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_WarningWriterOptions_CTor()
			_rest.IncRef(self.handle)
			if  0 < len(args):
				self.Deduplicate = args[0]
			if "Deduplicate" in kwargs:
				self.Deduplicate = kwargs["Deduplicate"]
			if  1 < len(args):
				self.Color = args[1]
			if "Color" in kwargs:
				self.Color = kwargs["Color"]
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.WarningWriterOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.WarningWriterOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Deduplicate(self):
		"""Deduplicate indicates a given warning message should only be written once.
		Setting this to true in a long-running process handling many warnings can result in increased memory use.
		"""
		return _rest.rest_WarningWriterOptions_Deduplicate_Get(self.handle)
	@Deduplicate.setter
	def Deduplicate(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_WarningWriterOptions_Deduplicate_Set(self.handle, value.handle)
		else:
			_rest.rest_WarningWriterOptions_Deduplicate_Set(self.handle, value)
	@property
	def Color(self):
		"""Color indicates that warning output can include ANSI color codes
		"""
		return _rest.rest_WarningWriterOptions_Color_Get(self.handle)
	@Color.setter
	def Color(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_WarningWriterOptions_Color_Set(self.handle, value.handle)
		else:
			_rest.rest_WarningWriterOptions_Color_Set(self.handle, value)

# Python type for struct rest.NoWarnings
class NoWarnings(go.GoClass):
	"""NoWarnings is an implementation of WarningHandler that suppresses warnings.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_NoWarnings_CTor()
			_rest.IncRef(self.handle)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.NoWarnings{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.NoWarnings ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def HandleWarningHeader(self, code, agent, message, goRun=False):
		"""HandleWarningHeader(int code, str agent, str message) """
		_rest.rest_NoWarnings_HandleWarningHeader(self.handle, code, agent, message, goRun)

# Python type for struct rest.TLSClientConfig
class TLSClientConfig(go.GoClass):
	"""+k8s:deepcopy-gen=true\nTLSClientConfig contains settings to enable transport layer security\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_TLSClientConfig_CTor()
			_rest.IncRef(self.handle)
			if  0 < len(args):
				self.Insecure = args[0]
			if "Insecure" in kwargs:
				self.Insecure = kwargs["Insecure"]
			if  1 < len(args):
				self.ServerName = args[1]
			if "ServerName" in kwargs:
				self.ServerName = kwargs["ServerName"]
			if  2 < len(args):
				self.CertFile = args[2]
			if "CertFile" in kwargs:
				self.CertFile = kwargs["CertFile"]
			if  3 < len(args):
				self.KeyFile = args[3]
			if "KeyFile" in kwargs:
				self.KeyFile = kwargs["KeyFile"]
			if  4 < len(args):
				self.CAFile = args[4]
			if "CAFile" in kwargs:
				self.CAFile = kwargs["CAFile"]
			if  5 < len(args):
				self.CertData = args[5]
			if "CertData" in kwargs:
				self.CertData = kwargs["CertData"]
			if  6 < len(args):
				self.KeyData = args[6]
			if "KeyData" in kwargs:
				self.KeyData = kwargs["KeyData"]
			if  7 < len(args):
				self.CAData = args[7]
			if "CAData" in kwargs:
				self.CAData = kwargs["CAData"]
			if  8 < len(args):
				self.NextProtos = args[8]
			if "NextProtos" in kwargs:
				self.NextProtos = kwargs["NextProtos"]
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		return self.String()
	
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.TLSClientConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Insecure(self):
		"""Server should be accessed without verifying the TLS certificate. For testing only.
		"""
		return _rest.rest_TLSClientConfig_Insecure_Get(self.handle)
	@Insecure.setter
	def Insecure(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_TLSClientConfig_Insecure_Set(self.handle, value.handle)
		else:
			_rest.rest_TLSClientConfig_Insecure_Set(self.handle, value)
	@property
	def ServerName(self):
		"""ServerName is passed to the server for SNI and is used in the client to check server
		certificates against. If ServerName is empty, the hostname used to contact the
		server is used.
		"""
		return _rest.rest_TLSClientConfig_ServerName_Get(self.handle)
	@ServerName.setter
	def ServerName(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_TLSClientConfig_ServerName_Set(self.handle, value.handle)
		else:
			_rest.rest_TLSClientConfig_ServerName_Set(self.handle, value)
	@property
	def CertFile(self):
		"""Server requires TLS client certificate authentication
		"""
		return _rest.rest_TLSClientConfig_CertFile_Get(self.handle)
	@CertFile.setter
	def CertFile(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_TLSClientConfig_CertFile_Set(self.handle, value.handle)
		else:
			_rest.rest_TLSClientConfig_CertFile_Set(self.handle, value)
	@property
	def KeyFile(self):
		"""Server requires TLS client certificate authentication
		"""
		return _rest.rest_TLSClientConfig_KeyFile_Get(self.handle)
	@KeyFile.setter
	def KeyFile(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_TLSClientConfig_KeyFile_Set(self.handle, value.handle)
		else:
			_rest.rest_TLSClientConfig_KeyFile_Set(self.handle, value)
	@property
	def CAFile(self):
		"""Trusted root certificates for server
		"""
		return _rest.rest_TLSClientConfig_CAFile_Get(self.handle)
	@CAFile.setter
	def CAFile(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_TLSClientConfig_CAFile_Set(self.handle, value.handle)
		else:
			_rest.rest_TLSClientConfig_CAFile_Set(self.handle, value)
	@property
	def CertData(self):
		"""CertData holds PEM-encoded bytes (typically read from a client certificate file).
		CertData takes precedence over CertFile
		"""
		return go.Slice_byte(handle=_rest.rest_TLSClientConfig_CertData_Get(self.handle))
	@CertData.setter
	def CertData(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_TLSClientConfig_CertData_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def KeyData(self):
		"""KeyData holds PEM-encoded bytes (typically read from a client certificate key file).
		KeyData takes precedence over KeyFile
		"""
		return go.Slice_byte(handle=_rest.rest_TLSClientConfig_KeyData_Get(self.handle))
	@KeyData.setter
	def KeyData(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_TLSClientConfig_KeyData_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def CAData(self):
		"""CAData holds PEM-encoded bytes (typically read from a root certificates bundle).
		CAData takes precedence over CAFile
		"""
		return go.Slice_byte(handle=_rest.rest_TLSClientConfig_CAData_Get(self.handle))
	@CAData.setter
	def CAData(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_TLSClientConfig_CAData_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def NextProtos(self):
		"""NextProtos is a list of supported application level protocols, in order of preference.
		Used to populate tls.Config.NextProtos.
		To indicate to the server http/1.1 is preferred over http/2, set to ["http/1.1", "h2"] (though the server is free to ignore that preference).
		To use only http/1.1, set to ["http/1.1"].
		"""
		return go.Slice_string(handle=_rest.rest_TLSClientConfig_NextProtos_Get(self.handle))
	@NextProtos.setter
	def NextProtos(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_TLSClientConfig_NextProtos_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def GoString(self):
		"""GoString() str
		
		GoString implements fmt.GoStringer and sanitizes sensitive fields of
		TLSClientConfig to prevent accidental leaking via logs.
		"""
		return _rest.rest_TLSClientConfig_GoString(self.handle)
	def String(self):
		"""String() str
		
		String implements fmt.Stringer and sanitizes sensitive fields of
		TLSClientConfig to prevent accidental leaking via logs.
		"""
		return _rest.rest_TLSClientConfig_String(self.handle)
	def DeepCopyInto(self, out, goRun=False):
		"""DeepCopyInto(object out) 
		
		DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
		"""
		_rest.rest_TLSClientConfig_DeepCopyInto(self.handle, out.handle, goRun)
	def DeepCopy(self):
		"""DeepCopy() object
		
		DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TLSClientConfig.
		"""
		return TLSClientConfig(handle=_rest.rest_TLSClientConfig_DeepCopy(self.handle))

# Python type for struct rest.ContentConfig
class ContentConfig(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_ContentConfig_CTor()
			_rest.IncRef(self.handle)
			if  0 < len(args):
				self.AcceptContentTypes = args[0]
			if "AcceptContentTypes" in kwargs:
				self.AcceptContentTypes = kwargs["AcceptContentTypes"]
			if  1 < len(args):
				self.ContentType = args[1]
			if "ContentType" in kwargs:
				self.ContentType = kwargs["ContentType"]
			if  2 < len(args):
				self.GroupVersion = args[2]
			if "GroupVersion" in kwargs:
				self.GroupVersion = kwargs["GroupVersion"]
			if  3 < len(args):
				self.NegotiatedSerializer = args[3]
			if "NegotiatedSerializer" in kwargs:
				self.NegotiatedSerializer = kwargs["NegotiatedSerializer"]
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.ContentConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.ContentConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def AcceptContentTypes(self):
		"""AcceptContentTypes specifies the types the client will accept and is optional.
		If not set, ContentType will be used to define the Accept header
		"""
		return _rest.rest_ContentConfig_AcceptContentTypes_Get(self.handle)
	@AcceptContentTypes.setter
	def AcceptContentTypes(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ContentConfig_AcceptContentTypes_Set(self.handle, value.handle)
		else:
			_rest.rest_ContentConfig_AcceptContentTypes_Set(self.handle, value)
	@property
	def ContentType(self):
		"""ContentType specifies the wire format used to communicate with the server.
		This value will be set as the Accept header on requests made to the server, and
		as the default content type on any object sent to the server. If not set,
		"application/json" is used.
		"""
		return _rest.rest_ContentConfig_ContentType_Get(self.handle)
	@ContentType.setter
	def ContentType(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ContentConfig_ContentType_Set(self.handle, value.handle)
		else:
			_rest.rest_ContentConfig_ContentType_Set(self.handle, value)
	@property
	def GroupVersion(self):
		"""GroupVersion is the API version to talk to. Must be provided when initializing
		a RESTClient directly. When initializing a Client, will be set with the default
		code version.
		"""
		return go.Ptr_schema_GroupVersion(handle=_rest.rest_ContentConfig_GroupVersion_Get(self.handle))
	@GroupVersion.setter
	def GroupVersion(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ContentConfig_GroupVersion_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def NegotiatedSerializer(self):
		"""NegotiatedSerializer is used for obtaining encoders and decoders for multiple
		supported media types.
		
		TODO: NegotiatedSerializer will be phased out as internal clients are removed
		  from Kubernetes.
		"""
		return go.runtime_NegotiatedSerializer(handle=_rest.rest_ContentConfig_NegotiatedSerializer_Get(self.handle))
	@NegotiatedSerializer.setter
	def NegotiatedSerializer(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ContentConfig_NegotiatedSerializer_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct rest.NoBackoff
class NoBackoff(go.GoClass):
	"""NoBackoff is a stub implementation, can be used for mocking or else as a default.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_NoBackoff_CTor()
			_rest.IncRef(self.handle)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.NoBackoff{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.NoBackoff ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def UpdateBackoff(self, actualUrl, err, responseCode, goRun=False):
		"""UpdateBackoff(object actualUrl, str err, int responseCode) """
		_rest.rest_NoBackoff_UpdateBackoff(self.handle, actualUrl.handle, err, responseCode, goRun)
	def CalculateBackoff(self, actualUrl):
		"""CalculateBackoff(object actualUrl) long"""
		return _rest.rest_NoBackoff_CalculateBackoff(self.handle, actualUrl.handle)
	def Sleep(self, d, goRun=False):
		"""Sleep(long d) """
		_rest.rest_NoBackoff_Sleep(self.handle, d, goRun)

# Python type for struct rest.URLBackoff
class URLBackoff(go.GoClass):
	"""URLBackoff struct implements the semantics on top of Backoff which\nwe need for URL specific exponential backoff.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_URLBackoff_CTor()
			_rest.IncRef(self.handle)
			if  0 < len(args):
				self.Backoff = args[0]
			if "Backoff" in kwargs:
				self.Backoff = kwargs["Backoff"]
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.URLBackoff{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.URLBackoff ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Backoff(self):
		"""Uses backoff as underlying implementation.
		"""
		return go.Ptr_flowcontrol_Backoff(handle=_rest.rest_URLBackoff_Backoff_Get(self.handle))
	@Backoff.setter
	def Backoff(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_URLBackoff_Backoff_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Disable(self, goRun=False):
		"""Disable() 
		
		Disable makes the backoff trivial, i.e., sets it to zero.  This might be used
		by tests which want to run 1000s of mock requests without slowing down.
		"""
		_rest.rest_URLBackoff_Disable(self.handle, goRun)
	def UpdateBackoff(self, actualUrl, err, responseCode, goRun=False):
		"""UpdateBackoff(object actualUrl, str err, int responseCode) 
		
		UpdateBackoff updates backoff metadata
		"""
		_rest.rest_URLBackoff_UpdateBackoff(self.handle, actualUrl.handle, err, responseCode, goRun)
	def CalculateBackoff(self, actualUrl):
		"""CalculateBackoff(object actualUrl) long
		
		CalculateBackoff takes a url and back's off exponentially,
		based on its knowledge of existing failures.
		"""
		return _rest.rest_URLBackoff_CalculateBackoff(self.handle, actualUrl.handle)
	def Sleep(self, d, goRun=False):
		"""Sleep(long d) """
		_rest.rest_URLBackoff_Sleep(self.handle, d, goRun)

# Python type for struct rest.WatchListResult
class WatchListResult(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_WatchListResult_CTor()
			_rest.IncRef(self.handle)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.WatchListResult{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.WatchListResult ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Into(self, obj):
		"""Into(object obj) str
		
		Into stores the result into obj. The passed obj parameter must be a pointer to a list type.
		
		Note:
		
		Special attention should be given to the type *unstructured.Unstructured,
		which represents a list type but does not have an "Items" field.
		Users who directly use RESTClient may store the response in such an object.
		This particular case is not handled by the current implementation of this function,
		but may be considered for future updates.
		"""
		return _rest.rest_WatchListResult_Into(self.handle, obj.handle)

# Python type for struct rest.ClientContentConfig
class ClientContentConfig(go.GoClass):
	"""ClientContentConfig controls how RESTClient communicates with the server.\n\nTODO: ContentConfig will be updated to accept a Negotiator instead of a\nNegotiatedSerializer and NegotiatedSerializer will be removed.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_ClientContentConfig_CTor()
			_rest.IncRef(self.handle)
			if  0 < len(args):
				self.AcceptContentTypes = args[0]
			if "AcceptContentTypes" in kwargs:
				self.AcceptContentTypes = kwargs["AcceptContentTypes"]
			if  1 < len(args):
				self.ContentType = args[1]
			if "ContentType" in kwargs:
				self.ContentType = kwargs["ContentType"]
			if  2 < len(args):
				self.GroupVersion = args[2]
			if "GroupVersion" in kwargs:
				self.GroupVersion = kwargs["GroupVersion"]
			if  3 < len(args):
				self.Negotiator = args[3]
			if "Negotiator" in kwargs:
				self.Negotiator = kwargs["Negotiator"]
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.ClientContentConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.ClientContentConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def AcceptContentTypes(self):
		"""AcceptContentTypes specifies the types the client will accept and is optional.
		If not set, ContentType will be used to define the Accept header
		"""
		return _rest.rest_ClientContentConfig_AcceptContentTypes_Get(self.handle)
	@AcceptContentTypes.setter
	def AcceptContentTypes(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ClientContentConfig_AcceptContentTypes_Set(self.handle, value.handle)
		else:
			_rest.rest_ClientContentConfig_AcceptContentTypes_Set(self.handle, value)
	@property
	def ContentType(self):
		"""ContentType specifies the wire format used to communicate with the server.
		This value will be set as the Accept header on requests made to the server if
		AcceptContentTypes is not set, and as the default content type on any object
		sent to the server. If not set, "application/json" is used.
		"""
		return _rest.rest_ClientContentConfig_ContentType_Get(self.handle)
	@ContentType.setter
	def ContentType(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ClientContentConfig_ContentType_Set(self.handle, value.handle)
		else:
			_rest.rest_ClientContentConfig_ContentType_Set(self.handle, value)
	@property
	def GroupVersion(self):
		"""GroupVersion is the API version to talk to. Must be provided when initializing
		a RESTClient directly. When initializing a Client, will be set with the default
		code version. This is used as the default group version for VersionedParams.
		"""
		return go.schema_GroupVersion(handle=_rest.rest_ClientContentConfig_GroupVersion_Get(self.handle))
	@GroupVersion.setter
	def GroupVersion(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ClientContentConfig_GroupVersion_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Negotiator(self):
		"""Negotiator is used for obtaining encoders and decoders for multiple
		supported media types.
		"""
		return go.runtime_ClientNegotiator(handle=_rest.rest_ClientContentConfig_Negotiator_Get(self.handle))
	@Negotiator.setter
	def Negotiator(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ClientContentConfig_Negotiator_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct rest.ImpersonationConfig
class ImpersonationConfig(go.GoClass):
	"""ImpersonationConfig has all the available impersonation options\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_ImpersonationConfig_CTor()
			_rest.IncRef(self.handle)
			if  0 < len(args):
				self.UserName = args[0]
			if "UserName" in kwargs:
				self.UserName = kwargs["UserName"]
			if  1 < len(args):
				self.UID = args[1]
			if "UID" in kwargs:
				self.UID = kwargs["UID"]
			if  2 < len(args):
				self.Groups = args[2]
			if "Groups" in kwargs:
				self.Groups = kwargs["Groups"]
			if  3 < len(args):
				self.Extra = args[3]
			if "Extra" in kwargs:
				self.Extra = kwargs["Extra"]
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.ImpersonationConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.ImpersonationConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def UserName(self):
		"""UserName is the username to impersonate on each request.
		"""
		return _rest.rest_ImpersonationConfig_UserName_Get(self.handle)
	@UserName.setter
	def UserName(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ImpersonationConfig_UserName_Set(self.handle, value.handle)
		else:
			_rest.rest_ImpersonationConfig_UserName_Set(self.handle, value)
	@property
	def UID(self):
		"""UID is a unique value that identifies the user.
		"""
		return _rest.rest_ImpersonationConfig_UID_Get(self.handle)
	@UID.setter
	def UID(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ImpersonationConfig_UID_Set(self.handle, value.handle)
		else:
			_rest.rest_ImpersonationConfig_UID_Set(self.handle, value)
	@property
	def Groups(self):
		"""Groups are the groups to impersonate on each request.
		"""
		return go.Slice_string(handle=_rest.rest_ImpersonationConfig_Groups_Get(self.handle))
	@Groups.setter
	def Groups(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ImpersonationConfig_Groups_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Extra(self):
		"""Extra is a free-form field which can be used to link some authentication information
		to authorization information.  This field allows you to impersonate it.
		"""
		return Map_string_Slice_string(handle=_rest.rest_ImpersonationConfig_Extra_Get(self.handle))
	@Extra.setter
	def Extra(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_ImpersonationConfig_Extra_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct rest.RetryAfter
class RetryAfter(go.GoClass):
	"""RetryAfter holds information associated with the next retry.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_RetryAfter_CTor()
			_rest.IncRef(self.handle)
			if  0 < len(args):
				self.Wait = args[0]
			if "Wait" in kwargs:
				self.Wait = kwargs["Wait"]
			if  1 < len(args):
				self.Attempt = args[1]
			if "Attempt" in kwargs:
				self.Attempt = kwargs["Attempt"]
			if  2 < len(args):
				self.Reason = args[2]
			if "Reason" in kwargs:
				self.Reason = kwargs["Reason"]
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.RetryAfter{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.RetryAfter ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Wait(self):
		"""Wait is the duration the server has asked us to wait before
		the next retry is initiated.
		This is the value of the 'Retry-After' response header in seconds.
		"""
		return _rest.rest_RetryAfter_Wait_Get(self.handle)
	@Wait.setter
	def Wait(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_RetryAfter_Wait_Set(self.handle, value.handle)
		else:
			_rest.rest_RetryAfter_Wait_Set(self.handle, value)
	@property
	def Attempt(self):
		"""Attempt is the Nth attempt after which we have received a retryable
		error or a 'Retry-After' response header from the server.
		"""
		return _rest.rest_RetryAfter_Attempt_Get(self.handle)
	@Attempt.setter
	def Attempt(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_RetryAfter_Attempt_Set(self.handle, value.handle)
		else:
			_rest.rest_RetryAfter_Attempt_Set(self.handle, value)
	@property
	def Reason(self):
		"""Reason describes why we are retrying the request
		"""
		return _rest.rest_RetryAfter_Reason_Get(self.handle)
	@Reason.setter
	def Reason(self, value):
		if isinstance(value, go.GoClass):
			_rest.rest_RetryAfter_Reason_Set(self.handle, value.handle)
		else:
			_rest.rest_RetryAfter_Reason_Set(self.handle, value)

# Python type for struct rest.WarningLogger
class WarningLogger(go.GoClass):
	"""WarningLogger is an implementation of WarningHandler that logs code 299 warnings\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_rest.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_rest.IncRef(self.handle)
		else:
			self.handle = _rest.rest_WarningLogger_CTor()
			_rest.IncRef(self.handle)
	def __del__(self):
		_rest.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.WarningLogger{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'rest.WarningLogger ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def HandleWarningHeader(self, code, agent, message, goRun=False):
		"""HandleWarningHeader(int code, str agent, str message) """
		_rest.rest_WarningLogger_HandleWarningHeader(self.handle, code, agent, message, goRun)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def AddUserAgent(config, userAgent):
	"""AddUserAgent(object config, str userAgent) object"""
	return Config(handle=_rest.rest_AddUserAgent(config.handle, userAgent))
def AnonymousClientConfig(config):
	"""AnonymousClientConfig(object config) object
	
	AnonymousClientConfig returns a copy of the given config with all user credentials (cert/key, bearer token, and username/password) and custom transports (WrapTransport, Transport) removed
	"""
	return Config(handle=_rest.rest_AnonymousClientConfig(config.handle))
def InClusterConfig():
	"""InClusterConfig() object, str
	
	InClusterConfig returns a config object which uses the service account
	kubernetes gives to pods. It's intended for clients that expect to be
	running inside a pod running on kubernetes. It will return ErrNotInCluster
	if called from a process not running in a kubernetes environment.
	"""
	return Config(handle=_rest.rest_InClusterConfig())
def CopyConfig(config):
	"""CopyConfig(object config) object
	
	CopyConfig returns a copy of the given config
	"""
	return Config(handle=_rest.rest_CopyConfig(config.handle))
def ExecClusterToConfig(cluster):
	"""ExecClusterToConfig(object cluster) object, str
	
	ExecClusterToConfig creates a Config with the corresponding fields from the provided
	clientauthenticationapi.Cluster. The returned Config will be anonymous (i.e., it will not have
	any authentication-related fields set).
	"""
	return Config(handle=_rest.rest_ExecClusterToConfig(cluster.handle))
def UnversionedRESTClientForConfigAndClient(config, httpClient):
	"""UnversionedRESTClientForConfigAndClient(object config, object httpClient) object, str
	
	UnversionedRESTClientForConfigAndClient is the same as RESTClientForConfigAndClient,
	except that it allows the config.Version to be empty.
	"""
	return RESTClient(handle=_rest.rest_UnversionedRESTClientForConfigAndClient(config.handle, httpClient.handle))
def NewRESTClient(baseURL, versionedAPIPath, config, rateLimiter, client):
	"""NewRESTClient(object baseURL, str versionedAPIPath, object config, object rateLimiter, object client) object, str
	
	NewRESTClient creates a new RESTClient. This client performs generic REST functions
	such as Get, Put, Post, and Delete on specified paths.
	"""
	return RESTClient(handle=_rest.rest_NewRESTClient(baseURL.handle, versionedAPIPath, config.handle, rateLimiter.handle, client.handle))
def UnversionedRESTClientFor(config):
	"""UnversionedRESTClientFor(object config) object, str
	
	UnversionedRESTClientFor is the same as RESTClientFor, except that it allows
	the config.Version to be empty.
	"""
	return RESTClient(handle=_rest.rest_UnversionedRESTClientFor(config.handle))
def RESTClientFor(config):
	"""RESTClientFor(object config) object, str
	
	RESTClientFor returns a RESTClient that satisfies the requested attributes on a client Config
	object. Note that a RESTClient may require fields that are optional when initializing a Client.
	A RESTClient created by this method is generic - it expects to operate on an API that follows
	the Kubernetes conventions, but may not be the Kubernetes API.
	RESTClientFor is equivalent to calling RESTClientForConfigAndClient(config, httpClient),
	where httpClient was generated with HTTPClientFor(config).
	"""
	return RESTClient(handle=_rest.rest_RESTClientFor(config.handle))
def RESTClientForConfigAndClient(config, httpClient):
	"""RESTClientForConfigAndClient(object config, object httpClient) object, str
	
	RESTClientForConfigAndClient returns a RESTClient that satisfies the requested attributes on a
	client Config object.
	Unlike RESTClientFor, RESTClientForConfigAndClient allows to pass an http.Client that is shared
	between all the API Groups and Versions.
	Note that the http client takes precedence over the transport values configured.
	The http client defaults to the `http.DefaultClient` if nil.
	"""
	return RESTClient(handle=_rest.rest_RESTClientForConfigAndClient(config.handle, httpClient.handle))
def NewRequest(c):
	"""NewRequest(object c) object
	
	NewRequest creates a new request helper object for accessing runtime.Objects on a server.
	"""
	return Request(handle=_rest.rest_NewRequest(c.handle))
def NewRequestWithClient(base, versionedAPIPath, content, client):
	"""NewRequestWithClient(object base, str versionedAPIPath, object content, object client) object
	
	NewRequestWithClient creates a Request with an embedded RESTClient for use in test scenarios.
	"""
	return Request(handle=_rest.rest_NewRequestWithClient(base.handle, versionedAPIPath, content.handle, client.handle))


# ---- Functions ---
def GetAuthProvider(clusterAddress, apc, persister):
	"""GetAuthProvider(str clusterAddress, object apc, object persister) object, str"""
	return AuthProvider(handle=_rest.rest_GetAuthProvider(clusterAddress, apc.handle, persister.handle))
def IsValidPathSegmentName(name):
	"""IsValidPathSegmentName(str name) []str
	
	IsValidPathSegmentName validates the name can be safely encoded as a path segment
	"""
	return go.Slice_string(handle=_rest.rest_IsValidPathSegmentName(name))
def DefaultVersionedAPIPath(apiPath, groupVersion):
	"""DefaultVersionedAPIPath(str apiPath, object groupVersion) str
	
	DefaultVersionedAPIPath constructs the default path for the given group version, assuming the given
	API path, following the standard conventions of the Kubernetes API.
	"""
	return _rest.rest_DefaultVersionedAPIPath(apiPath, groupVersion.handle)
def ConfigToExecCluster(config):
	"""ConfigToExecCluster(object config) object, str
	
	ConfigToExecCluster creates a clientauthenticationapi.Cluster with the corresponding fields from
	the provided Config.
	"""
	return go.Ptr_clientauthentication_Cluster(handle=_rest.rest_ConfigToExecCluster(config.handle))
def DefaultKubernetesUserAgent():
	"""DefaultKubernetesUserAgent() str
	
	DefaultKubernetesUserAgent returns a User-Agent string built from static global vars.
	"""
	return _rest.rest_DefaultKubernetesUserAgent()
def CodecFactoryForGeneratedClient(scheme, codecs):
	"""CodecFactoryForGeneratedClient(object scheme, object codecs) object
	
	CodecFactoryForGeneratedClient returns the provided CodecFactory if there are no enabled client
	feature gates affecting serialization. Otherwise, it constructs and returns a new CodecFactory
	from the provided Scheme.
	
	This is supported ONLY for use by clients generated with client-gen. The caller is responsible
	for ensuring that the CodecFactory argument was constructed using the Scheme argument.
	"""
	return go.serializer_CodecFactory(handle=_rest.rest_CodecFactoryForGeneratedClient(scheme.handle, codecs.handle))
def LoadTLSFiles(c):
	"""LoadTLSFiles(object c) str
	
	LoadTLSFiles copies the data from the CertFile, KeyFile, and CAFile fields into the CertData,
	KeyData, and CAFile fields, or returns an error. If no error is returned, all three fields are
	either populated or were empty to start.
	"""
	return _rest.rest_LoadTLSFiles(c.handle)
def SetKubernetesDefaults(config):
	"""SetKubernetesDefaults(object config) str
	
	SetKubernetesDefaults sets default values on the provided client config for accessing the
	Kubernetes API or returns an error if any of the defaults are impossible or invalid.
	"""
	return _rest.rest_SetKubernetesDefaults(config.handle)
def SetDefaultWarningHandler(l, goRun=False):
	"""SetDefaultWarningHandler(object l) 
	
	SetDefaultWarningHandler sets the default handler clients use when warning headers are encountered.
	By default, warnings are logged. Several built-in implementations are provided:
	  - NoWarnings suppresses warnings.
	  - WarningLogger logs warnings.
	  - NewWarningWriter() outputs warnings to the provided writer.
	"""
	_rest.rest_SetDefaultWarningHandler(l.handle, goRun)
def TransportFor(config):
	"""TransportFor(object config) object, str
	
	TransportFor returns an http.RoundTripper that will provide the authentication
	or transport level security defined by the provided Config. Will return the
	default http.DefaultTransport if no special case behavior is needed.
	"""
	return go.http_RoundTripper(handle=_rest.rest_TransportFor(config.handle))
def TLSConfigFor(config):
	"""TLSConfigFor(object config) object, str
	
	TLSConfigFor returns a tls.Config that will provide the transport level security defined
	by the provided Config. Will return nil if no transport level security is requested.
	"""
	return go.Ptr_tls_Config(handle=_rest.rest_TLSConfigFor(config.handle))
def HTTPClientFor(config):
	"""HTTPClientFor(object config) object, str
	
	HTTPClientFor returns an http.Client that will provide the authentication
	or transport level security defined by the provided Config. Will return the
	default http.DefaultClient if no special case behavior is needed.
	"""
	return go.Ptr_http_Client(handle=_rest.rest_HTTPClientFor(config.handle))
def HTTPWrappersForConfig(config, rt):
	"""HTTPWrappersForConfig(object config, object rt) object, str
	
	HTTPWrappersForConfig wraps a round tripper with any relevant layered behavior from the
	config. Exposed to allow more clients that need HTTP-like behavior but then must hijack
	the underlying connection (like WebSocket or HTTP2 clients). Pure HTTP clients should use
	the higher level TransportFor or RESTClientFor methods.
	"""
	return go.http_RoundTripper(handle=_rest.rest_HTTPWrappersForConfig(config.handle, rt.handle))
def ValidatePathSegmentName(name, prefix):
	"""ValidatePathSegmentName(str name, bool prefix) []str
	
	ValidatePathSegmentName validates the name can be safely encoded as a path segment
	"""
	return go.Slice_string(handle=_rest.rest_ValidatePathSegmentName(name, prefix))
def IsValidPathSegmentPrefix(name):
	"""IsValidPathSegmentPrefix(str name) []str
	
	IsValidPathSegmentPrefix validates the name can be used as a prefix for a name which will be encoded as a path segment
	It does not check for exact matches with disallowed names, since an arbitrary suffix might make the name valid
	"""
	return go.Slice_string(handle=_rest.rest_IsValidPathSegmentPrefix(name))
def IsConfigTransportTLS(config):
	"""IsConfigTransportTLS(object config) bool
	
	IsConfigTransportTLS returns true if and only if the provided
	config will result in a protected connection to the server when it
	is passed to restclient.RESTClientFor().  Use to determine when to
	send credentials over the wire.
	
	Note: the Insecure flag is ignored when testing for this value, so MITM attacks are
	still possible.
	"""
	return _rest.rest_IsConfigTransportTLS(config.handle)


